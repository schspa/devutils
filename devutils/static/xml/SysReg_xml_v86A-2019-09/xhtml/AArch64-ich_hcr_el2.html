<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ICH_HCR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">ICH_HCR_EL2, Interrupt Controller Hyp Control Register</h1><p>The ICH_HCR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Controls the environment for VMs.</p>
      <h2>Configuration</h2><p>AArch64 System register ICH_HCR_EL2 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-ich_hcr.html">ICH_HCR[31:0]
            </a>.
          </p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>

      
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>
      <p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>ICH_HCR_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The ICH_HCR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="5"><a href="#EOIcount_31">EOIcount</a></td><td class="lr" colspan="12"><a href="#0_26">RES0</a></td><td class="lr" colspan="1"><a href="#TDIR_14">TDIR</a></td><td class="lr" colspan="1"><a href="#TSEI_13">TSEI</a></td><td class="lr" colspan="1"><a href="#TALL1_12">TALL1</a></td><td class="lr" colspan="1"><a href="#TALL0_11">TALL0</a></td><td class="lr" colspan="1"><a href="#TC_10">TC</a></td><td class="lr" colspan="2"><a href="#0_9">RES0</a></td><td class="lr" colspan="1"><a href="#VGrp1DIE_7">VGrp1DIE</a></td><td class="lr" colspan="1"><a href="#VGrp1EIE_6">VGrp1EIE</a></td><td class="lr" colspan="1"><a href="#VGrp0DIE_5">VGrp0DIE</a></td><td class="lr" colspan="1"><a href="#VGrp0EIE_4">VGrp0EIE</a></td><td class="lr" colspan="1"><a href="#NPIE_3">NPIE</a></td><td class="lr" colspan="1"><a href="#LRENPIE_2">LRENPIE</a></td><td class="lr" colspan="1"><a href="#UIE_1">UIE</a></td><td class="lr" colspan="1"><a href="#En_0">En</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="0_63">
                Bits [63:32]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="EOIcount_31">EOIcount, bits [31:27]
                  </h4>
          
  <p>This field is incremented whenever a successful write to a virtual EOIR or DIR register would have resulted in a virtual interrupt deactivation.  That is either:</p>
<ul>
<li>A virtual write to EOIR with a valid interrupt identifier that is not in the LPI range (that is &lt; 8192) when EOI mode is zero and no List Register was found.
</li><li>A virtual write to DIR with a valid interrupt identifier that is not in the LPI range (that is &lt; 8192) when EOI mode is one and no List Register was found.
</li></ul>
<p>This allows software to manage more active interrupts than there are implemented List Registers.</p>
<p>It is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> whether a virtual write to EOIR that does not clear a bit in the Active Priorities registers (<a href="AArch64-ich_ap0rn_el2.html">ICH_AP0R&lt;n&gt;_EL2</a>/<a href="AArch64-ich_ap1rn_el2.html">ICH_AP1R&lt;n&gt;_EL2</a>) increments EOIcount. Permitted behaviors are:</p>
<ul>
<li>Increment EOIcount.
</li><li>Leave EOIcount unchanged.
</li></ul>

        <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_26">
                Bits [26:15]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TDIR_14">TDIR, bit [14]
              </h4>
          
  <p>Trap EL1 writes to <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a> and <a href="AArch64-icv_dir_el1.html">ICV_DIR_EL1</a>.</p>

        <table class="valuetable"><tr><th>TDIR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL1 writes of <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a> and <a href="AArch64-icv_dir_el1.html">ICV_DIR_EL1</a> are not trapped to EL2, unless trapped by other mechanisms.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 writes of <a href="AArch64-icv_dir_el1.html">ICV_DIR_EL1</a> are trapped to EL2. It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether writes of <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a> are trapped. Not trapping <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a> writes is DEPRECATED.</p>
</td></tr></table>
              
  <p>Support for this bit is <span class="arm-defined-word">OPTIONAL</span>, with support indicated by <a href="AArch64-ich_vtr_el2.html">ICH_VTR_EL2</a>.</p>
<p>If the implementation does not support this trap, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>Arm deprecates not including this trap bit.</p>

            <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="TSEI_13">TSEI, bit [13]
              </h4>
          
  <p>Trap all locally generated SEIs. This bit allows the hypervisor to intercept locally generated SEIs that would otherwise be taken at EL1.</p>

        <table class="valuetable"><tr><th>TSEI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Locally generated SEIs do not cause a trap to EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Locally generated SEIs trap to EL2.</p>
</td></tr></table>
              
  <p>If <a href="AArch64-ich_vtr_el2.html">ICH_VTR_EL2</a>.SEIS is 0, this bit is <span class="arm-defined-word">RES0</span>.</p>

            <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="TALL1_12">TALL1, bit [12]
              </h4>
          
  <p>Trap all EL1 accesses to ICC_* and ICV_* System registers for Group 1 interrupts to EL2.</p>

        <table class="valuetable"><tr><th>TALL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL1 accesses to ICC_* and ICV_* registers for Group 1 interrupts proceed as normal.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 accesses to ICC_* and ICV_* registers for Group 1 interrupts trap to EL2.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="TALL0_11">TALL0, bit [11]
              </h4>
          
  <p>Trap all EL1 accesses to ICC_* and ICV_* System registers for Group 0 interrupts to EL2.</p>

        <table class="valuetable"><tr><th>TALL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL1 accesses to ICC_* and ICV_* registers for Group 0 interrupts proceed as normal.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 accesses to ICC_* and ICV_* registers for Group 0 interrupts trap to EL2.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="TC_10">TC, bit [10]
              </h4>
          
  <p>Trap all EL1 accesses to System registers that are common to Group 0 and Group 1 to EL2.</p>

        <table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL1 accesses to common registers proceed as normal.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 accesses to common registers trap to EL2.</p>
</td></tr></table>
              
  <p>This affects accesses to <a href="AArch64-icc_sgi0r_el1.html">ICC_SGI0R_EL1</a>, <a href="AArch64-icc_sgi1r_el1.html">ICC_SGI1R_EL1</a>, <a href="AArch64-icc_asgi1r_el1.html">ICC_ASGI1R_EL1</a>, <a href="AArch64-icc_ctlr_el1.html">ICC_CTLR_EL1</a>, <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a>, <a href="AArch64-icc_pmr_el1.html">ICC_PMR_EL1</a>, <a href="AArch64-icc_rpr_el1.html">ICC_RPR_EL1</a>, <a href="AArch64-icv_ctlr_el1.html">ICV_CTLR_EL1</a>, <a href="AArch64-icv_dir_el1.html">ICV_DIR_EL1</a>, <a href="AArch64-icv_pmr_el1.html">ICV_PMR_EL1</a>, and <a href="AArch64-icv_rpr_el1.html">ICV_RPR_EL1</a>.</p>

            <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_9">
                Bits [9:8]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="VGrp1DIE_7">VGrp1DIE, bit [7]
              </h4>
          
  <p>VM Group 1 Disabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected vPE is disabled:</p>

        <table class="valuetable"><tr><th>VGrp1DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG1 is 0.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="VGrp1EIE_6">VGrp1EIE, bit [6]
              </h4>
          
  <p>VM Group 1 Enabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected vPE is enabled:</p>

        <table class="valuetable"><tr><th>VGrp1EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG1 is 1.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="VGrp0DIE_5">VGrp0DIE, bit [5]
              </h4>
          
  <p>VM Group 0 Disabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected vPE is disabled:</p>

        <table class="valuetable"><tr><th>VGrp0DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG0 is 0.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="VGrp0EIE_4">VGrp0EIE, bit [4]
              </h4>
          
  <p>VM Group 0 Enabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected vPE is enabled:</p>

        <table class="valuetable"><tr><th>VGrp0EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG0 is 1.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="NPIE_3">NPIE, bit [3]
              </h4>
          
  <p>No Pending Interrupt Enable. Enables the signaling of a maintenance interrupt when there are no List registers with the State field set to <span class="binarynumber">0b01</span> (pending):</p>

        <table class="valuetable"><tr><th>NPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled while the List registers contain no interrupts in the pending state.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="LRENPIE_2">LRENPIE, bit [2]
              </h4>
          
  <p>List Register Entry Not Present Interrupt Enable. Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request:</p>

        <table class="valuetable"><tr><th>LRENPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt is asserted while the EOIcount field is not 0.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="UIE_1">UIE, bit [1]
              </h4>
          
  <p>Underflow Interrupt Enable. Enables the signaling of a maintenance interrupt when the List registers are empty, or hold only one valid entry:</p>

        <table class="valuetable"><tr><th>UIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt is asserted if none, or only one, of the List register entries is marked as a valid interrupt.</p>
</td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="En_0">En, bit [0]
              </h4>
          
  <p>Enable. Global enable bit for the virtual CPU interface:</p>

        <table class="valuetable"><tr><th>En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Virtual CPU interface operation disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Virtual CPU interface operation enabled.</p>
</td></tr></table>
              
  <p>When this field is set to 0:</p>
<ul>
<li>The virtual CPU interface does not signal any maintenance interrupts.
</li><li>The virtual CPU interface does not signal any virtual interrupts.
</li><li>A read of <a href="AArch64-icv_iar0_el1.html">ICV_IAR0_EL1</a>, <a href="AArch64-icv_iar1_el1.html">ICV_IAR1_EL1</a>, <a href="ext-gicv_iar.html">GICV_IAR</a> or <a href="ext-gicv_aiar.html">GICV_AIAR</a> returns a spurious interrupt ID.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>This field is <span class="arm-defined-word">RES0</span> when SCR_EL3.{NS,EEL2}=={0,0}</p></div>

            <p>This field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the ICH_HCR_EL2</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, ICH_HCR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1100</td><td>0b1011</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        return NVMem[0x4C0];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if ICC_SRE_EL2.SRE == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        return ICH_HCR_EL2;
elsif PSTATE.EL == EL3 then
    if ICC_SRE_EL3.SRE == '0' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return ICH_HCR_EL2;
              </p><h4 class="assembler">MSR ICH_HCR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1100</td><td>0b1011</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        NVMem[0x4C0] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if ICC_SRE_EL2.SRE == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        ICH_HCR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    if ICC_SRE_EL3.SRE == '0' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        ICH_HCR_EL2 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
