<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>EDSCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">EDSCR, External Debug Status and Control Register</h1><p>The EDSCR characteristics are:</p><h2>Purpose</h2>
        <p>Main control register for the debug implementation.</p>
      <h2>Configuration</h2><p>External register EDSCR bits [30:29]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-mdccsr_el0.html">MDCCSR_EL0[30:29]
            </a>.
          </p><p>EDSCR is in the Core power domain.
      Some or all RW fields of this register have defined reset values. These apply only on a Cold reset. The register is not affected by a Warm reset and is not affected by an External debug reset.</p><h2>Attributes</h2>
            <p>EDSCR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The EDSCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#TFO_31">TFO</a></td><td class="lr" colspan="1"><a href="#RXfull_30">RXfull</a></td><td class="lr" colspan="1"><a href="#TXfull_29">TXfull</a></td><td class="lr" colspan="1"><a href="#ITO_28">ITO</a></td><td class="lr" colspan="1"><a href="#RXO_27">RXO</a></td><td class="lr" colspan="1"><a href="#TXU_26">TXU</a></td><td class="lr" colspan="1"><a href="#PipeAdv_25">PipeAdv</a></td><td class="lr" colspan="1"><a href="#ITE_24">ITE</a></td><td class="lr" colspan="2"><a href="#INTdis_23">INTdis</a></td><td class="lr" colspan="1"><a href="#TDA_21">TDA</a></td><td class="lr" colspan="1"><a href="#MA_20">MA</a></td><td class="lr" colspan="1"><a href="#SC2_19">SC2</a></td><td class="lr" colspan="1"><a href="#NS_18">NS</a></td><td class="lr" colspan="1"><a href="#0_17">RES0</a></td><td class="lr" colspan="1"><a href="#SDD_16">SDD</a></td><td class="lr" colspan="1"><a href="#0_15">RES0</a></td><td class="lr" colspan="1"><a href="#HDE_14">HDE</a></td><td class="lr" colspan="4"><a href="#RW_13">RW</a></td><td class="lr" colspan="2"><a href="#EL_9">EL</a></td><td class="lr" colspan="1"><a href="#A_7">A</a></td><td class="lr" colspan="1"><a href="#ERR_6">ERR</a></td><td class="lr" colspan="6"><a href="#STATUS_5">STATUS</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="TFO_31">TFO, bit [31]
              <div style="font-size:smaller;"><br />When ARMv8.4-Trace is implemented:
                </div></h4>
          
  <p>Trace Filter Override. Overrides the Trace Filter controls allowing the external debugger to trace any visible Exception level.</p>

        <table class="valuetable"><tr><th>TFO</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Trace Filter controls are not affected.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Trace Filter controls in <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a>, <a href="AArch64-trfcr_el2.html">TRFCR_EL2</a>, <a href="AArch32-trfcr.html">TRFCR</a>, and <a href="AArch32-htrfcr.html">HTRFCR</a> are ignored.</p>
</td></tr></table>
              
  <p>When <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>.OSLK == 1, this bit can be indirectly read and written through the <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> and <a href="AArch32-dbgdscrext.html">DBGDSCRext</a> System registers.</p>
<p>This bit is ignored by the PE when ExternalSecureNoninvasiveDebugEnabled() == FALSE and the Effective value of <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.STE == 1.</p>

            <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_31"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="RXfull_30">RXfull, bit [30]
              </h4>
          
  <p>DTRRX full.</p>

        <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="TXfull_29">TXfull, bit [29]
              </h4>
          
  <p>DTRTX full.</p>

        <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="ITO_28">ITO, bit [28]
              </h4>
          
  <p>ITR overrun.</p>
<p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. ITO is set to 0 on entry to Debug state.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="RXO_27">RXO, bit [27]
              </h4>
          
  <p>DTRRX overrun.</p>

        <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="TXU_26">TXU, bit [26]
              </h4>
          
  <p>DTRTX underrun.</p>

        <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="PipeAdv_25">PipeAdv, bit [25]
              </h4>
          
  <p>Pipeline advance. Set to 1 every time the PE pipeline retires one or more instructions. Cleared to 0 by a write to <a href="ext-edrcr.html">EDRCR</a>.CSPA.</p>
<p>The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="ITE_24">ITE, bit [24]
              </h4>
          
  <p>ITR empty.</p>
<p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. It is always valid in Debug state.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="INTdis_23">INTdis, bits [23:22]
                  <div style="font-size:smaller;"><br />When ARMv8.4-Debug is implemented:
                </div></h4>
          
  <p>Interrupt disable. Disables taking interrupts in Non-Debug state.</p>

        <table class="valuetable"><tr><th>INTdis</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Masking of interrupts is controlled by PSTATE and interrupt routing controls.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>If ExternalSecureDebugEnabled() == TRUE, then all interrupts, including virtual and SError interrupts, are masked.</p>
<p>If ExternalSecureDebugEnabled() == FALSE, then all interrupts targetting Non-secure state are masked.</p>
</td></tr></table>
              
  <p>When <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>.OSLK == 1, this field can be indirectly read and written through the <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> and <a href="AArch32-dbgdscrext.html">DBGDSCRext</a> System registers.</p>
<p>This field is ignored by the PE and treated as zero when ExternalDebugEnabled() == FALSE.</p>

            <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="INTdis_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
          
  <p>Interrupt disable.</p>
<p>When <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>.OSLK == 1, this field can be indirectly read and written through the <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> and <a href="AArch32-dbgdscrext.html">DBGDSCRext</a> System registers.</p>

        <table class="valuetable"><tr><th>INTdis</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Do not disable interrupts.</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Disable interrupts taken to Non-secure EL1.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Disable interrupts taken only to Non-secure EL1 and Non-secure EL2. If ExternalSecureInvasiveDebugEnabled() == TRUE, also disable interrupts taken to Secure EL1.</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Disable interrupts taken only to Non-secure EL1 and Non-secure EL2. If ExternalSecureInvasiveDebugEnabled() == TRUE, also disable all other interrupts.</p>
</td></tr></table><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TDA_21">TDA, bit [21]
              </h4>
          
  <p>Traps accesses to the following debug System registers:</p>
<ul>
<li>AArch64: <a href="ext-dbgbcrn_el1.html">DBGBCR&lt;n&gt;_EL1</a>, <a href="ext-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1</a>, <a href="ext-dbgwcrn_el1.html">DBGWCR&lt;n&gt;_EL1</a>, <a href="ext-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1</a>.
</li><li>AArch32: <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>, <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n&gt;</a>, <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a>, <a href="AArch32-dbgwcrn.html">DBGWCR&lt;n&gt;</a>, <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;</a>.
</li></ul>
<p>The possible values of this field are:</p>

        <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Accesses to debug System registers do not generate a Software Access Debug event.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Accesses to debug System registers generate a Software Access Debug event, if <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>.OSLK is 0 and if halting is allowed.</p>
</td></tr></table><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="MA_20">MA, bit [20]
              </h4>
          
  <p>Memory access mode. Controls the use of memory-access mode for accessing ITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.</p>
<p>Possible values of this field are:</p>

        <table class="valuetable"><tr><th>MA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Normal access mode.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Memory access mode.</p>
</td></tr></table><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="SC2_19">SC2, bit [19]
              <div style="font-size:smaller;"><br />When ARMv8.0-PCSample is implemented, ARMv8.1-VHE is implemented and ARMv8.2-PCSample is not implemented:
                </div></h4>
          
  <p>Sample <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>. Controls whether the PC Sample-based Profiling Extension samples <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> or <a href="AArch64-vttbr_el2.html">VTTBR_EL2</a>.VMID.</p>

        <table class="valuetable"><tr><th>SC2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Sample <a href="AArch64-vttbr_el2.html">VTTBR_EL2</a>.VMID.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Sample <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p>
</td></tr></table><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_19"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="NS_18">NS, bit [18]
              </h4>
          
  <p>Non-secure status. When in Debug state, gives the current Security state:</p>

        <table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Secure state, IsSecure() == TRUE.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Non-secure state, IsSecure() == FALSE.</p>
</td></tr></table>
              
  <p>In Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p>

            <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="0_17">
                Bit [17]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="SDD_16">SDD, bit [16]
              </h4>
          
  <p>Secure debug disabled.</p>
<p>On entry to Debug state:</p>
<ul>
<li>If entering in Secure state, SDD is set to 0.
</li><li>If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().
</li></ul>
<p>In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.</p>
<p>In Non-debug state:</p>
<ul>
<li>SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization event is required to guarantee their effect.
</li><li>This bit is unaffected by the Security state of the PE.
</li></ul>
<p>If EL3 is not implemented and the implementation is Non-secure, this bit is <span class="arm-defined-word">RES1</span>.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="0_15">
                Bit [15]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="HDE_14">HDE, bit [14]
              </h4>
          
  <p>Halting debug enable. The possible values of this field are:</p>

        <table class="valuetable"><tr><th>HDE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Halting disabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Halting enabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
</td></tr></table><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="RW_13">RW, bits [13:10]
                  </h4>
          
  <p>Exception level Execution state status. In Debug state, each bit gives the current Execution state of each Exception level:</p>

        <table class="valuetable"><tr><th>RW</th><th>Meaning</th></tr><tr><td class="bitfield">0b1111</td><td>
  <p>All Exception levels are using AArch64 or the PE is in Non-debug state.</p>
</td></tr><tr><td class="bitfield">0b1110</td><td>
  <p>The PE is in Debug state. EL0 is using AArch32. All other Exception levels are using AArch64. Only permitted if the PE is executing at EL0.</p>
</td></tr><tr><td class="bitfield">0b110x</td><td>
  <p>The PE is in Debug state. EL0 and EL1 are using AArch32. EL2 and EL3 are using AArch64. Only permitted if EL2 is implemented and enabled in the current Security state.</p>
</td></tr><tr><td class="bitfield">0b10xx</td><td>
  <p>The PE is in Debug state. EL0, EL1, and, if implemented in the current Security state, EL2 are using AArch32. EL3 is using AArch64. Only permitted if EL3 is implemented.</p>
</td></tr><tr><td class="bitfield">0b0xxx</td><td>
  <p>The PE is in Debug state. All Exception levels are using AArch32.</p>
</td></tr></table>
              
  <p>In Non-debug state, this field is RAO.</p>

            <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="EL_9">EL, bits [9:8]
                  </h4>
          
  <p>Exception level. In Debug state, this gives the current EL of the PE.</p>
<p>In Non-debug state, this field is RAZ.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="A_7">A, bit [7]
              </h4>
          
  <p>SError interrupt pending. In Debug state, indicates whether an SError interrupt is pending:</p>
<ul>
<li>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{AMO, TGE} = {1, 0}, EL2 is enabled in the current Security state, and the PE is executing at EL0 or EL1, a virtual SError interrupt.
</li><li>Otherwise, a physical SError interrupt.
</li></ul>

        <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>No SError interrupt pending.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>SError interrupt pending.</p>
</td></tr></table>
              
  <p>A debugger can read EDSCR to check whether an SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.</p>
<p><span class="arm-defined-word">UNKNOWN</span> in Non-debug state.</p>

            <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="ERR_6">ERR, bit [6]
              </h4>
          
  <p>Cumulative error flag. This bit is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</p>

        <p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="STATUS_5">STATUS, bits [5:0]
                  </h4>
          
  <p>Debug status flags.</p>

        <table class="valuetable"><tr><th>STATUS</th><th>Meaning</th></tr><tr><td class="bitfield">0b000001</td><td>
  <p>PE is restarting, exiting Debug state.</p>
</td></tr><tr><td class="bitfield">0b000010</td><td>
  <p>PE is in Non-debug state.</p>
</td></tr><tr><td class="bitfield">0b000111</td><td>
  <p>Breakpoint.</p>
</td></tr><tr><td class="bitfield">0b010011</td><td>
  <p>External debug request.</p>
</td></tr><tr><td class="bitfield">0b011011</td><td>
  <p>Halting step, normal.</p>
</td></tr><tr><td class="bitfield">0b011111</td><td>
  <p>Halting step, exclusive.</p>
</td></tr><tr><td class="bitfield">0b100011</td><td>
  <p>OS Unlock Catch.</p>
</td></tr><tr><td class="bitfield">0b100111</td><td>
  <p>Reset Catch.</p>
</td></tr><tr><td class="bitfield">0b101011</td><td>
  <p>Watchpoint.</p>
</td></tr><tr><td class="bitfield">0b101111</td><td>
  <p>HLT instruction.</p>
</td></tr><tr><td class="bitfield">0b110011</td><td>
  <p>Software access to debug register.</p>
</td></tr><tr><td class="bitfield">0b110111</td><td>
  <p>Exception Catch.</p>
</td></tr><tr><td class="bitfield">0b111011</td><td>
  <p>Halting step, no syndrome.</p>
</td></tr></table>
              
  <p>All other values of STATUS are reserved.</p>

            <p>Access to this field is <span class="access_level">RO</span>.</p><div class="text_after_fields">
    
  

    </div><h2>Accessing the EDSCR</h2><h4>EDSCR can be accessed through the external debug interface:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>Debug</td><td><span class="hexnumber">0x088</span></td><td>EDSCR</td></tr></table><p>This interface is accessible as follows:</p><ul><li>When IsCorePowered(), !DoubleLockStatus(), !OSLockStatus() and SoftwareLockStatus()
            accesses to this register are <span class="access_level">RO</span>.
          </li><li>When IsCorePowered(), !DoubleLockStatus(), !OSLockStatus() and !SoftwareLockStatus()
            accesses to this register are <span class="access_level">RW</span>.
          </li><li>Otherwise 
            accesses to this register generate an error response.
          </li></ul><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
