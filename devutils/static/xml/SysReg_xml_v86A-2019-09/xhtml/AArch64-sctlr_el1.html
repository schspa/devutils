<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SCTLR_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">SCTLR_EL1, System Control Register (EL1)</h1><p>The SCTLR_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Provides top level control of the system, including its memory system, at EL1 and EL0.</p>
      <h2>Configuration</h2><p>AArch64 System register SCTLR_EL1 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-sctlr.html">SCTLR[31:0]
            </a>.
          </p><p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into EL1 using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>SCTLR_EL1 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The SCTLR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="14"><a href="#0_63">RES0</a></td><td class="lr" colspan="4"><a href="#TWEDEL_49">TWEDEL</a></td><td class="lr" colspan="1"><a href="#TWEDEn_45">TWEDEn</a></td><td class="lr" colspan="1"><a href="#DSSBS_44">DSSBS</a></td><td class="lr" colspan="1"><a href="#ATA_43">ATA</a></td><td class="lr" colspan="1"><a href="#ATA0_42">ATA0</a></td><td class="lr" colspan="2"><a href="#TCF_41">TCF</a></td><td class="lr" colspan="2"><a href="#TCF0_39">TCF0</a></td><td class="lr" colspan="1"><a href="#ITFSB_37">ITFSB</a></td><td class="lr" colspan="1"><a href="#BT1_36">BT1</a></td><td class="lr" colspan="1"><a href="#BT0_35">BT0</a></td><td class="lr" colspan="3"><a href="#0_34">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#EnIA_31">EnIA</a></td><td class="lr" colspan="1"><a href="#EnIB_30">EnIB</a></td><td class="lr" colspan="1"><a href="#LSMAOE_29">LSMAOE</a></td><td class="lr" colspan="1"><a href="#nTLSMD_28">nTLSMD</a></td><td class="lr" colspan="1"><a href="#EnDA_27">EnDA</a></td><td class="lr" colspan="1"><a href="#UCI_26">UCI</a></td><td class="lr" colspan="1"><a href="#EE_25">EE</a></td><td class="lr" colspan="1"><a href="#E0E_24">E0E</a></td><td class="lr" colspan="1"><a href="#SPAN_23">SPAN</a></td><td class="lr" colspan="1"><a href="#EIS_22">EIS</a></td><td class="lr" colspan="1"><a href="#IESB_21">IESB</a></td><td class="lr" colspan="1"><a href="#TSCXT_20">TSCXT</a></td><td class="lr" colspan="1"><a href="#WXN_19">WXN</a></td><td class="lr" colspan="1"><a href="#nTWE_18">nTWE</a></td><td class="lr" colspan="1"><a href="#0_17">RES0</a></td><td class="lr" colspan="1"><a href="#nTWI_16">nTWI</a></td><td class="lr" colspan="1"><a href="#UCT_15">UCT</a></td><td class="lr" colspan="1"><a href="#DZE_14">DZE</a></td><td class="lr" colspan="1"><a href="#EnDB_13">EnDB</a></td><td class="lr" colspan="1"><a href="#I_12">I</a></td><td class="lr" colspan="1"><a href="#EOS_11">EOS</a></td><td class="lr" colspan="1"><a href="#EnRCTX_10">EnRCTX</a></td><td class="lr" colspan="1"><a href="#UMA_9">UMA</a></td><td class="lr" colspan="1"><a href="#SED_8">SED</a></td><td class="lr" colspan="1"><a href="#ITD_7">ITD</a></td><td class="lr" colspan="1"><a href="#nAA_6">nAA</a></td><td class="lr" colspan="1"><a href="#CP15BEN_5">CP15BEN</a></td><td class="lr" colspan="1"><a href="#SA0_4">SA0</a></td><td class="lr" colspan="1"><a href="#SA_3">SA</a></td><td class="lr" colspan="1"><a href="#C_2">C</a></td><td class="lr" colspan="1"><a href="#A_1">A</a></td><td class="lr" colspan="1"><a href="#M_0">M</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="0_63">
                Bits [63:50]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TWEDEL_49">TWEDEL, bits [49:46]
                  <div style="font-size:smaller;"><br />When ARMv8.6-TWED is implemented:
                </div></h4>
          
  <p>TWE Delay. A 4-bit unsigned number that, when SCTLR_EL1.TWEDEn is 1, encodes the minimum delay in taking a trap of WFE caused by SCTLR_EL1.nTWE as 2^(TWEDEL + 8) cycles.</p>

        <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_49"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TWEDEn_45">TWEDEn, bit [45]
              <div style="font-size:smaller;"><br />When ARMv8.6-TWED is implemented:
                </div></h4>
          
  <p>TWE Delay Enable. Enables a configurable delayed trap of the WFE instruction caused by SCTLR_EL1.nTWE.</p>

        <table class="valuetable"><tr><th>TWEDEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The delay for taking a WFE trap is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The delay for taking a WFE trap is at least the number of cycles defined in SCTLR_EL1.TWEDEL.</p>
</td></tr></table><p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_45"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="DSSBS_44">DSSBS, bit [44]
              <div style="font-size:smaller;"><br />When ARMv8.0-SSBS is implemented:
                </div></h4>
          
  <p>Default PSTATE.SSBS value on Exception Entry. The defined values are:</p>

        <table class="valuetable"><tr><th>DSSBS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>PSTATE.SSBS is set to 0 on an exception to EL1</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>PSTATE.SSBS is set to 1 on an exception to EL1</p>
</td></tr></table><p>In a system where the PE resets into EL1, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0_44"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="ATA_43">ATA, bit [43]
              <div style="font-size:smaller;"><br />When ARMv8.5-MemTag is implemented:
                </div></h4>
          
  <p>Allocation Tag Access in EL1. When <a href="AArch64-scr_el3.html">SCR_EL3</a>.ATA=1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.ATA=1, controls EL1 access to Allocation Tags.</p>
<p>When access to Allocation Tags is prevented:</p>
<ul>
<li>
<p>Instructions which Load or Store data are Unchecked.</p>

</li><li>
<p>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</p>

</li><li>
<p>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</p>

</li><li>
<p>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</p>

</li></ul>

        <table class="valuetable"><tr><th>ATA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Access to Allocation Tags is prevented.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Access to Allocation Tags is not prevented.</p>
</td></tr></table>
              
  <p>This bit is permitted to be cached in a TLB.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_43"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="ATA0_42">ATA0, bit [42]
              <div style="font-size:smaller;"><br />When ARMv8.5-MemTag is implemented:
                </div></h4>
          
  <p>Allocation Tag Access in EL0. When <a href="AArch64-scr_el3.html">SCR_EL3</a>.ATA=1, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.ATA=1, and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H,TGE} != {1,1}, controls EL0 access to Allocation Tags.</p>
<p>When access to Allocation Tags is prevented:</p>
<ul>
<li>
<p>Instructions which Load or Store data are Unchecked.</p>

</li><li>
<p>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</p>

</li><li>
<p>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</p>

</li><li>
<p>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</p>

</li></ul>

        <table class="valuetable"><tr><th>ATA0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Access to Allocation Tags is prevented.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Access to Allocation Tags is not prevented.</p>
</td></tr></table>
              
  <p>This field is permitted to be cached in a TLB.</p>
<div class="note"><span class="note-header">Note</span><p>Software may change this control bit on a context switch.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_42"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TCF_41">TCF, bits [41:40]
                  <div style="font-size:smaller;"><br />When ARMv8.5-MemTag is implemented:
                </div></h4>
          
  <p>Tag Check Fail in EL1. Controls the effect of tag check fails due to Loads and Stores in EL1.</p>

        <table class="valuetable"><tr><th>TCF</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Tag check fails have no effect on the PE.</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Tag check fails causes a synchronous exception.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Tag check fails are asynchronously accumulated.</p>
</td></tr></table>
              
  <p>The value <span class="binarynumber">0b11</span> is reserved.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_41"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TCF0_39">TCF0, bits [39:38]
                  <div style="font-size:smaller;"><br />When ARMv8.5-MemTag is implemented:
                </div></h4>
          
  <p>Tag Check Fail in EL0. When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H,TGE} != {1,1}, controls the effect of tag check fails due to Loads and Stores in EL0.</p>

        <table class="valuetable"><tr><th>TCF0</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Tag check fails have no effect on the PE.</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Tag check fails causes a synchronous exception.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Tag check fails are asynchronously accumulated.</p>
</td></tr></table>
              
  <p>The value <span class="binarynumber">0b11</span> is reserved.</p>
<div class="note"><span class="note-header">Note</span><p>Software may change this control bit on a context switch.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_39"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="ITFSB_37">ITFSB, bit [37]
              <div style="font-size:smaller;"><br />When ARMv8.5-MemTag is implemented:
                </div></h4>
          
  <p>When synchronous exceptions are not being generated by Tag Check fails which are generated for Loads and Stores in EL0 or EL1, controls the auto-synchronization of Tag Check fails into <a href="AArch64-tfsre0_el1.html">TFSRE0_EL1</a> and <a href="AArch64-tfsr_el1.html">TFSR_EL1</a>.</p>

        <table class="valuetable"><tr><th>ITFSB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Tag check fails are not synchronized on entry to EL1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Tag check fails are synchronized on entry to EL1.</p>
</td></tr></table><p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_37"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="BT1_36">BT1, bit [36]
              <div style="font-size:smaller;"><br />When ARMv8.5-BTI is implemented:
                </div></h4>
          
  <p>PAC Branch Type compatibility at EL1.</p>

        <table class="valuetable"><tr><th>BT1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>When the PE is executing at EL1, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>When the PE is executing at EL1, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p>
</td></tr></table><p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_36"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="BT0_35">BT0, bit [35]
              <div style="font-size:smaller;"><br />When ARMv8.5-BTI is implemented:
                </div></h4>
          
  <p>PAC Branch Type compatibility at EL0.</p>

        <table class="valuetable"><tr><th>BT0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>When the PE is executing at EL0, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>When the PE is executing at EL0, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p>
</td></tr></table>
              
  <p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 1 &amp;&amp; <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1, the value of the SCTLR_EL1.BT0 has no effect on execution at EL0</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_35"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="0_34">
                Bits [34:32]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="EnIA_31">EnIA, bit [31]
              <div style="font-size:smaller;"><br />When ARMv8.3-PAuth is implemented:
                </div></h4>
          
  <p>Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL1&amp;0 translation regime.</p>
<p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p>

        <table class="valuetable"><tr><th>EnIA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is not enabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is enabled.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACIA and AuthIA pseudocode functions. Specifically, when the field is 1, AddPACIA returns a copy of a pointer to which a pointer authentication code has been added, and AuthIA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_31"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="EnIB_30">EnIB, bit [30]
              <div style="font-size:smaller;"><br />When ARMv8.3-PAuth is implemented:
                </div></h4>
          
  <p>Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL1&amp;0 translation regime.</p>
<p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p>

        <table class="valuetable"><tr><th>EnIB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is not enabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is enabled.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACIB and AuthIB pseudocode functions. Specifically, when the field is 1, AddPACIB returns a copy of a pointer to which a pointer authentication code has been added, and AuthIB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_30"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="LSMAOE_29">LSMAOE, bit [29]
              <div style="font-size:smaller;"><br />When ARMv8.2-LSMAOC is implemented:
                </div></h4>
          
  <p>Load Multiple and Store Multiple Atomicity and Ordering Enable.</p>

        <table class="valuetable"><tr><th>LSMAOE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>For all memory accesses at EL0, A32 and T32 Load Multiple and Store Multiple can have an interrupt taken during the sequence memory accesses, and the memory accesses are not required to be ordered.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The ordering and interrupt behavior of A32 and T32 Load Multiple and Store Multiple at EL0 is as defined for Armv8.0.</p>
</td></tr></table>
              
  <p>This bit is permitted to be cached in a TLB.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_29"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="nTLSMD_28">nTLSMD, bit [28]
              <div style="font-size:smaller;"><br />When ARMv8.2-LSMAOC is implemented:
                </div></h4>
          
  <p>No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.</p>

        <table class="valuetable"><tr><th>nTLSMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are trapped and generate a stage 1 Alignment fault.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are not trapped.</p>
</td></tr></table>
              
  <p>This bit is permitted to be cached in a TLB.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_28"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="EnDA_27">EnDA, bit [27]
              <div style="font-size:smaller;"><br />When ARMv8.3-PAuth is implemented:
                </div></h4>
          
  <p>Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL1&amp;0 translation regime.</p>
<p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p>

        <table class="valuetable"><tr><th>EnDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Pointer authentication (using the APDAKey_EL1 key) of data addresses is not enabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Pointer authentication (using the APDAKey_EL1 key) of data addresses is enabled.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACDA and AuthDA pseudocode functions. Specifically, when the field is 1, AddPACDA returns a copy of a pointer to which a pointer authentication code has been added, and AuthDA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_27"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="UCI_26">UCI, bit [26]
              </h4>
          
  <p>Traps EL0 execution of cache maintenance instructions, to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from AArch64 state only, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>This applies to <a href="AArch64-dc-cvau.html">DC CVAU</a>, <a href="AArch64-dc-civac.html">DC CIVAC</a>, <a href="AArch64-dc-cvac.html">DC CVAC</a>, <a href="AArch64-dc-cvap.html">DC CVAP</a>, and <a href="AArch64-ic-ivau.html">IC IVAU</a>.</p>
<p>If <span class="xref">ARMv8.2-DCCVADP</span> is implemented, this trap also applies to <a href="AArch64-dc-cvadp.html">DC CVADP</a>.</p>
<p>If <span class="xref">ARMv8.5-MemTag</span> is implemented, this trap also applies to <a href="AArch64-dc-cigvac.html">DC CIGVAC</a>, <a href="AArch64-dc-cigdvac.html">DC CIGDVAC</a>, <a href="AArch64-dc-cgvac.html">DC CGVAC</a>, <a href="AArch64-dc-cgdvac.html">DC CGDVAC</a>, <a href="AArch64-dc-cgvap.html">DC CGVAP</a>, and <a href="AArch64-dc-cgdvap.html">DC CGDVAP</a>.</p>
<p>If <span class="xref">ARMv8.2-DCCVADP</span> and <span class="xref">ARMv8.5-MemTag</span> are implemented, this trap also applies to <a href="AArch64-dc-cgvadp.html">DC CGVADP</a> and <a href="AArch64-dc-cgdvadp.html">DC CGDVADP</a>.</p>

        <table class="valuetable"><tr><th>UCI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Execution of the specified instructions at EL0 using AArch64 is trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>
<p>If the Point of Coherency is before any level of data cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any data or unified cache clean, or clean and invalidate instruction that operates by VA to the point of coherency can be trapped when the value of this control is 1.</p>
<p>If the Point of Unification is before any level of data cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any data or unified cache clean by VA to the Point of Unification instruction can be trapped when the value of this control is 1.</p>
<p>If the Point of Unification is before any level of instruction cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any instruction cache invalidate by VA to the Point of Unification instruction can be trapped when the value of this control is 1.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EE_25">EE, bit [25]
              </h4>
          
  <p>Endianness of data accesses at EL1, and stage 1 translation table walks in the EL1&amp;0 translation regime.</p>
<p>The possible values of this bit are:</p>

        <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&amp;0 translation regime are little-endian.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&amp;0 translation regime are big-endian.</p>
</td></tr></table>
              
  <p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
<p>The EE bit is permitted to be cached in a TLB.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

            <p>In a system where the PE resets into EL1, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="E0E_24">E0E, bit [24]
              </h4>
          
  <p>Endianness of data accesses at EL0.</p>
<p>The possible values of this bit are:</p>

        <table class="valuetable"><tr><th>E0E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Explicit data accesses at EL0 are little-endian.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Explicit data accesses at EL0 are big-endian.</p>
</td></tr></table>
              
  <p>If an implementation only supports Little-endian accesses at EL0 then this bit is <span class="arm-defined-word">RES0</span>. This option is not permitted when SCTLR_EL1.EE is <span class="arm-defined-word">RES1</span>.</p>
<p>If an implementation only supports Big-endian accesses at EL0 then this bit is <span class="arm-defined-word">RES1</span>. This option is not permitted when SCTLR_EL1.EE is <span class="arm-defined-word">RES0</span>.</p>
<p>This bit has no effect on the endianness of <span class="instruction">LDTR</span>, <span class="instruction">LDTRH</span>, <span class="instruction">LDTRSH</span>, <span class="instruction">LDTRSW</span>, <span class="instruction">STTR</span>, and <span class="instruction">STTRH</span> instructions executed at EL1.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SPAN_23">SPAN, bit [23]
              <div style="font-size:smaller;"><br />When ARMv8.1-PAN is implemented:
                </div></h4>
          
  <p>Set Privileged Access Never, on taking an exception to EL1.</p>

        <table class="valuetable"><tr><th>SPAN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>PSTATE.PAN is set to 1 on taking an exception to EL1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The value of PSTATE.PAN is left unchanged on taking an exception to EL1.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="EIS_22">EIS, bit [22]
              <div style="font-size:smaller;"><br />When ARMv8.5-CSEH is implemented:
                </div></h4>
          
  <p>Exception Entry is Context Synchronizing. The defined values are:</p>

        <table class="valuetable"><tr><th>EIS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The taking of an exception to EL1 is not a context synchronizing event.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The taking of an exception to EL1 is a context synchronizing event.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>
<p>If SCTLR_EL1.EIS is set to <span class="binarynumber">0b0</span>:</p>
<ul>
<li>Indirect writes to <a href="AArch64-esr_el1.html">ESR_EL1</a>, <a href="AArch64-far_el1.html">FAR_EL1</a>, <a href="AArch64-spsr_el1.html">SPSR_EL1</a>, <a href="AArch64-elr_el1.html">ELR_EL1</a> are synchronized on exception entry to EL1, so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.
</li><li>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
</li><li>Exception Catch debug events are synchronous debug events.
</li><li>DCPS* and DRPS instructions are context synchronization events.
</li></ul>
<p>The following are not affected by the value of SCTLR_EL1.EIS:</p>
<ul>
<li>Changes to the PSTATE information on entry to EL1.
</li><li>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
</li><li>Exit from Debug state.
</li></ul>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_22"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="IESB_21">IESB, bit [21]
              <div style="font-size:smaller;"><br />When ARMv8.2-IESB is implemented:
                </div></h4>
          
  <p>Implicit Error Synchronization event enable. Possible values are:</p>

        <table class="valuetable"><tr><th>IESB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>An implicit error synchronization event is added:</p>
<ul>
<li>At each exception taken to EL1.
</li><li>Before the operational pseudocode of each <span class="instruction">ERET</span> instruction executed at EL1.
</li></ul>
</td></tr></table>
              
  <p>When the PE is in Debug state, the effect of this field is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and its Effective value might be 0 or 1 regardless of the value of the field. If the Effective value of the field is 1, then an implicit error synchronization event is added after each <span class="instruction">DCPSx</span> instruction taken to EL1 and before each <span class="instruction">DRPS</span> instruction executed at EL1, in addition to the other cases where it is added.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_21"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TSCXT_20">TSCXT, bit [20]
              <div style="font-size:smaller;"><br />When ARMv8.0-CSV2 is implemented:
                </div></h4>
          
  <p>Trap EL0 Access to the <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> register, when EL0 is using AArch64. The defined values are:</p>

        <table class="valuetable"><tr><th>TSCXT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL0 access to <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> is not disabled by this mechanism.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 access to <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> is disabled, causing an exception to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1.</p>
<p>The value of <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> is treated as 0.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_20"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="WXN_19">WXN, bit [19]
              </h4>
          
  <p>Write permission implies XN (Execute-never). For the EL1&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>

        <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control has no effect on memory access permissions.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Any region that is writable in the EL1&amp;0 translation regime is forced to XN for accesses from software executing at EL1 or EL0.</p>
</td></tr></table>
              
  <p>This bit applies only when SCTLR_EL1.M bit is set.</p>
<p>The WXN bit is permitted to be cached in a TLB.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="nTWE_18">nTWE, bit [18]
              </h4>
          
  <p>Traps EL0 execution of WFE instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from both Execution states, reported using EC syndrome value <span class="hexnumber">0x01</span>.</p>

        <table class="valuetable"><tr><th>nTWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Any attempt to execute a WFE instruction at EL0 is trapped, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_17">
                Bit [17]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="nTWI_16">nTWI, bit [16]
              </h4>
          
  <p>Traps EL0 execution of WFI instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from both Execution states, reported using EC syndrome value <span class="hexnumber">0x01</span>.</p>

        <table class="valuetable"><tr><th>nTWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Any attempt to execute a WFI instruction at EL0 is trapped, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UCT_15">UCT, bit [15]
              </h4>
          
  <p>Traps EL0 accesses to the <a href="AArch64-ctr_el0.html">CTR_EL0</a> to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from AArch64 state only, reported using EC value <span class="hexnumber">0x18</span>.</p>

        <table class="valuetable"><tr><th>UCT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Accesses to the <a href="AArch64-ctr_el0.html">CTR_EL0</a> from EL0 using AArch64 are trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DZE_14">DZE, bit [14]
              </h4>
          
  <p>Traps EL0 execution of <a href="AArch64-dc-zva.html">DC ZVA</a> instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from AArch64 state only, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>If <span class="xref">ARMv8.5-MemTag</span> is implemented, this trap also applies to <a href="AArch64-dc-gva.html">DC GVA</a> and <a href="AArch64-dc-gzva.html">DC GZVA</a>.</p>

        <table class="valuetable"><tr><th>DZE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Any attempt to execute an instruction that this trap applies to at EL0 using AArch64 is trapped.</p>
<p>Reading <a href="AArch64-dczid_el0.html">DCZID_EL0</a>.DZP from EL0 returns 1, indicating that the instructions this trap applies to are not supported.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EnDB_13">EnDB, bit [13]
              <div style="font-size:smaller;"><br />When ARMv8.3-PAuth is implemented:
                </div></h4>
          
  <p>Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL1&amp;0 translation regime.</p>
<p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p>

        <table class="valuetable"><tr><th>EnDB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Pointer authentication (using the APDBKey_EL1 key) of data addresses is not enabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Pointer authentication (using the APDBKey_EL1 key) of data addresses is enabled.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACDB and AuthDB pseudocode functions. Specifically, when the field is 1, AddPACDB returns a copy of a pointer to which a pointer authentication code has been added, and AuthDB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="I_12">I, bit [12]
              </h4>
          
  <p>Instruction access Cacheability control, for accesses at EL0 and EL1:</p>

        <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>All instruction access to Normal memory from EL0 and EL1 are Non-cacheable for all levels of instruction and unified cache.</p>
<p>If the value of SCTLR_EL1.M is 0, instruction accesses from stage 1 of the EL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control has no effect on the Cacheability of instruction access to Normal memory from EL0 and EL1.</p>
<p>If the value of SCTLR_EL1.M is 0, instruction accesses from stage 1 of the EL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
</td></tr></table>
              
  <p>When the value of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.DC bit is 1, then instruction access to Normal memory from EL0 and EL1 are Cacheable regardless of the value of the SCTLR_EL1.I bit.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

            <p>In a system where the PE resets into EL1, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="EOS_11">EOS, bit [11]
              <div style="font-size:smaller;"><br />When ARMv8.5-CSEH is implemented:
                </div></h4>
          
  <p>Exception Exit is Context Synchronizing. The defined values are:</p>

        <table class="valuetable"><tr><th>EOS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>An exception return from EL1 is not a context synchronizing event</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>An exception return from EL1 is a context synchronizing event</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>
<p>If SCTLR_EL1.EOS is set to <span class="binarynumber">0b0</span>:</p>
<ul>
<li>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
</li><li>Exception Catch debug events are synchronous debug events.
</li><li>DCPS* and DRPS instructions are context synchronization events.
</li></ul>
<p>The following are not affected by the value of SCTLR_EL1.EOS:</p>
<ul>
<li>The indirect write of the PSTATE and PC values from <a href="AArch64-spsr_el1.html">SPSR_EL1</a> and <a href="AArch64-elr_el1.html">ELR_EL1</a> on exception return is synchronized. 
</li><li>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
</li><li>Exit from Debug state.
</li></ul>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_11"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
        <h4 id="EnRCTX_10">EnRCTX, bit [10]
              <div style="font-size:smaller;"><br />When ARMv8.0-PredInv is implemented:
                </div></h4>
          
  <p>Enable EL0 Access to the AArch32 CFPRCTX, DVPRCTX and CPPRCTX instructions, and the AArch64 CFP RCTX, DVP RCT and CPP RCTX instructions. The defined values are:</p>

        <table class="valuetable"><tr><th>EnRCTX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL0 access to these instructions is disabled, and these instructions are trapped to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 access to these instructions is enabled.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_10"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="UMA_9">UMA, bit [9]
              </h4>
          
  <p>User Mask Access. Traps EL0 execution of MSR and MRS instructions that access the PSTATE.{D, A, I, F} masks to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from AArch64 state only, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>

        <table class="valuetable"><tr><th>UMA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Any attempt at EL0 using AArch64 to execute an <span class="instruction">MRS</span>, <span class="instruction">MSR(register)</span>, or <span class="instruction">MSR(immediate)</span> instruction that accesses the <a href="AArch64-daif.html">DAIF</a> is trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SED_8">SED, bit [8]
              </h4>
          
  <p>SETEND instruction disable. Disables SETEND instructions at EL0 using AArch32.</p>

        <table class="valuetable"><tr><th>SED</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>SETEND instruction execution is enabled at EL0 using AArch32.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>SETEND instructions are <span class="arm-defined-word">UNDEFINED</span> at EL0 using AArch32 and any attempt at EL0 to access a SETEND instruction generates an exception to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, reported using EC syndrome value <span class="hexnumber">0x00</span>.</p>
</td></tr></table>
              
  <p>If the implementation does not support mixed-endian operation at any Exception level, this bit is <span class="arm-defined-word">RES1</span>.</p>
<p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES1</span>.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="ITD_7">ITD, bit [7]
              </h4>
          
  <p>IT Disable. Disables some uses of IT instructions at EL0 using AArch32.</p>

        <table class="valuetable"><tr><th>ITD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>All IT instruction functionality is enabled at EL0 using AArch32.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Any attempt at EL0 using AArch32 to execute any of the following is <span class="arm-defined-word">UNDEFINED</span> and generates an exception, reported using EC syndrome value <span class="hexnumber">0x00</span>, to EL1 or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1:</p>
<ul>
<li>
<p>All encodings of the IT instruction with hw1[3:0]!=1000.</p>

</li><li>
<p>All encodings of the subsequent instruction with the following values for hw1:</p>
<ul>
<li>
<p><span class="binarynumber">0b11xxxxxxxxxxxxxx</span>: All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</p>

</li><li>
<p><span class="binarynumber">0b1011xxxxxxxxxxxx</span>: All instructions in 'Miscellaneous 16-bit instructions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section F3.2.5.</p>

</li><li>
<p><span class="binarynumber">0b10100xxxxxxxxxxx</span>: ADD Rd, PC, #imm</p>

</li><li>
<p><span class="binarynumber">0b01001xxxxxxxxxxx</span>: LDR Rd, [PC, #imm]</p>

</li><li>
<p><span class="binarynumber">0b0100x1xxx1111xxx</span>: ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</p>

</li><li>
<p><span class="binarynumber">0b010001xx1xxxx111</span>: ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers unpredictable cases with BLX Rn.</p>

</li></ul>

</li></ul>
<p>These instructions are always <span class="arm-defined-word">UNDEFINED</span>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the IT instruction is treated as:</p>
<ul>
<li>
<p>A 16-bit instruction, that can only be followed by another 16-bit instruction.</p>

</li><li>
<p>The first half of a 32-bit instruction.</p>

</li></ul>
<p>This means that, for the situations that are <span class="arm-defined-word">UNDEFINED</span>, either the second 16-bit instruction or the 32-bit instruction is <span class="arm-defined-word">UNDEFINED</span>.</p>
<p>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</p>
</td></tr></table>
              
  <p>If an instruction in an active IT block that would be disabled by this field sets this field to 1 then behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>. For more information see <span class="xref">'Changes to an ITD control by an instruction in an IT block' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section E1.2.4</span></p>
<p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES1</span>.</p>
<p>ITD is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAZ/WI.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="nAA_6">nAA, bit [6]
              <div style="font-size:smaller;"><br />When ARMv8.4-LSE is implemented:
                </div></h4>
          
  <p>Non-aligned access. This bit controls generation of Alignment faults at EL1 and EL0 under certain conditions.</p>

        <table class="valuetable"><tr><th>nAA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes for accesses.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control bit does not cause LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, or STLURH to generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes.</p>
</td></tr></table>
              
  <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="CP15BEN_5">CP15BEN, bit [5]
              </h4>
          
  <p>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<span class="binarynumber">0b1111</span>) encoding space from EL0:</p>

        <table class="valuetable"><tr><th>CP15BEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL0 using AArch32: EL0 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is <span class="arm-defined-word">UNDEFINED</span> and generates an exception to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1. The exception is reported using EC syndrome value <span class="hexnumber">0x00</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 using AArch32: EL0 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is enabled.</p>
</td></tr></table>
              
  <p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>CP15BEN is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAO/WI.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SA0_4">SA0, bit [4]
              </h4>
          
  <p>SP Alignment check enable for EL0. When set to 1, if a load or store instruction executed at EL0 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

        <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SA_3">SA, bit [3]
              </h4>
          
  <p>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL1 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

        <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="C_2">C, bit [2]
              </h4>
          
  <p>Cacheability control, for data accesses.</p>

        <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>All data access to Normal memory from EL0 and EL1, and all Normal memory accesses to the EL1&amp;0 stage 1 translation tables, are Non-cacheable for all levels of data and unified cache.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control has no effect on the Cacheability of:</p>
<ul>
<li>Data access to Normal memory from EL0 and EL1.
</li><li>Normal memory accesses to the EL1&amp;0 stage 1 translation tables.
</li></ul>
</td></tr></table>
              
  <p>When the value of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.DC bit is 1, the PE ignores SCLTR.C. This means that Non-secure EL0 and Non-secure EL1 data accesses to Normal memory are Cacheable.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

            <p>In a system where the PE resets into EL1, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="A_1">A, bit [1]
              </h4>
          
  <p>Alignment check enable. This is the enable bit for Alignment fault checking at EL1 and EL0.</p>

        <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Alignment fault checking disabled when executing at EL1 or EL0.</p>
<p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Alignment fault checking enabled when executing at EL1 or EL0.</p>
<p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
</td></tr></table>
              
  <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on execution at EL0.</p>

            <p>In a system where the PE resets into EL1, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="M_0">M, bit [0]
              </h4>
          
  <p>MMU enable for EL1 and EL0 stage 1 address translation. Possible values of this bit are:</p>

        <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EL1 and EL0 stage 1 address translation disabled.</p>
<p>See the SCTLR_EL1.I field for the behavior of instruction accesses to Normal memory.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 and EL0 stage 1 address translation enabled.</p>
</td></tr></table>
              
  <p>If the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{DC, TGE} is not {0, 0} then in Non-secure state the PE behaves as if the value of the SCTLR_EL1.M field is 0 for all purposes other than returning the value of a direct read of the field.</p>
<p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.</p>

            <p>In a system where the PE resets into EL1, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the SCTLR_EL1</h2>
        <p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, without explicit synchronization, access from EL3 using the mnemonic SCTLR_EL1 or SCTLR_EL12 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</p>
      <p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, SCTLR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        return NVMem[0x110];
    else
        return SCTLR_EL1;
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        return SCTLR_EL2;
    else
        return SCTLR_EL1;
elsif PSTATE.EL == EL3 then
    return SCTLR_EL1;
              </p><h4 class="assembler">MSR SCTLR_EL1, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        NVMem[0x110] = X[t];
    else
        SCTLR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        SCTLR_EL2 = X[t];
    else
        SCTLR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    SCTLR_EL1 = X[t];
              </p><h4 class="assembler">MRS &lt;Xt&gt;, SCTLR_EL12</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '101' then
        return NVMem[0x110];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' then
        return SCTLR_EL1;
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' then
        return SCTLR_EL1;
    else
        UNDEFINED;
              </p><h4 class="assembler">MSR SCTLR_EL12, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '101' then
        NVMem[0x110] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' then
        SCTLR_EL1 = X[t];
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' then
        SCTLR_EL1 = X[t];
    else
        UNDEFINED;
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
