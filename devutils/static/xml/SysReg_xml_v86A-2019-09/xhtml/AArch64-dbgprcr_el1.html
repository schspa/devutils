<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>DBGPRCR_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">DBGPRCR_EL1, Debug Power Control Register</h1><p>The DBGPRCR_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Controls behavior of the PE on powerdown request.</p>
      <h2>Configuration</h2><p>AArch64 System register DBGPRCR_EL1 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-dbgprcr.html">DBGPRCR[31:0]
            </a>.
          </p>
        <p>Bit [0] of this register is mapped to <a href="ext-edprcr.html">EDPRCR</a>.CORENPDRQ, bit [0] of the external view of this register.</p>

      
        <p>The other bits in these registers are not mapped to each other.</p>
      <p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>DBGPRCR_EL1 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The DBGPRCR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="31"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#CORENPDRQ_0">CORENPDRQ</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="0_63">
                Bits [63:1]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="CORENPDRQ_0">CORENPDRQ, bit [0]
              <div style="font-size:smaller;"><br />When ARMv8.3-DoPD is implemented:
                </div></h4>
          
  <p>Core no powerdown request. Requests emulation of powerdown.</p>
<p>This request is typically passed to an external power controller. This means that whether a request causes power up is dependent on the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> nature of the system. The power controller must not allow the Core power domain to switch off while this bit is 1.</p>

        <table class="valuetable"><tr><th>CORENPDRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>If the system responds to a powerdown request, it powers down Core power domain.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>If the system responds to a powerdown request, it does not powerdown the Core power domain, but instead emulates a powerdown of that domain.</p>
</td></tr></table>
              
  <p>In an implementation that includes the recommended external debug interface, this bit drives the DBGNOPWRDWN signal.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is reset to its Cold reset value on exit from an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> software-visible retention state. For more information about retention states see <span class="xref">Core power domain power states</span>.</p>
<div class="note"><span class="note-header">Note</span><p>Writes to this bit are not prohibited by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface. This means that a debugger can request emulation of powerdown regardless of whether invasive debug is permitted.</p></div>

            <p>The following resets apply:</p><ul><li>
  <p>On a Cold reset, this field is set to 1 if the powerup request is implemented and the powerup request has been asserted, and is set to 0 otherwise.</p>
</li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="CORENPDRQ_0"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
          
  <p>Core no powerdown request. Requests emulation of powerdown.</p>
<p>This request is typically passed to an external power controller. This means that whether a request causes power up is dependent on the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> nature of the system. The power controller must not allow the Core power domain to switch off while this bit is 1.</p>

        <table class="valuetable"><tr><th>CORENPDRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>If the system responds to a powerdown request, it powers down Core power domain.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>If the system responds to a powerdown request, it does not powerdown the Core power domain, but instead emulates a powerdown of that domain.</p>
</td></tr></table>
              
  <p>In an implementation that includes the recommended external debug interface, this bit drives the DBGNOPWRDWN signal.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is reset to the value of <a href="ext-edprcr.html">EDPRCR</a>.COREPURQ on exit from an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> software-visible retention state. For more information about retention states see <span class="xref">Core power domain power states</span>.</p>
<div class="note"><span class="note-header">Note</span><p>Writes to this bit are not prohibited by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface. This means that a debugger can request emulation of powerdown regardless of whether invasive debug is permitted.</p></div>

            <p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to the value in <a href="ext-edprcr.html">EDPRCR</a>.COREPURQ.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the DBGPRCR_EL1</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, DBGPRCR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0001</td><td>0b0100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.DBGPRCR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDOSA&gt; != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return DBGPRCR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return DBGPRCR_EL1;
elsif PSTATE.EL == EL3 then
    return DBGPRCR_EL1;
              </p><h4 class="assembler">MSR DBGPRCR_EL1, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0001</td><td>0b0100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.DBGPRCR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDOSA&gt; != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        DBGPRCR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        DBGPRCR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    DBGPRCR_EL1 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
