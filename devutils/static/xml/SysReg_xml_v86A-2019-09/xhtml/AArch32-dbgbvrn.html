<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>DBGBVR&lt;n&gt;</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">DBGBVR&lt;n&gt;, Debug Breakpoint Value Registers, n =
      0 - 15</h1><p>The DBGBVR&lt;n&gt; characteristics are:</p><h2>Purpose</h2>
        <p>Holds a value for use in breakpoint matching, either the virtual address of an instruction or a context ID. Forms breakpoint n together with control register <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>. If EL2 is implemented and this breakpoint supports Context matching, DBGBVR&lt;n&gt; can be associated with a Breakpoint Extended Value Register <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a> for VMID matching.</p>
      <h2>Configuration</h2><p>AArch32 System register DBGBVR&lt;n&gt; bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1[31:0]
            </a>.
          </p><p>AArch32 System register DBGBVR&lt;n&gt; bits [31:0]
            
                are architecturally mapped to
              External register <a href="ext-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1[31:0]
            </a>.
          </p>
        <p>If breakpoint n is not implemented then accesses to this register are <span class="arm-defined-word">UNDEFINED</span>.</p>
      <p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
        <p>How this register is interpreted depends on the value of <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>.BT.</p>

      
        <ul>
<li>When <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>.BT is <span class="binarynumber">0b0x0x</span>, this register holds a virtual address.
</li><li>When <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>.BT is <span class="binarynumber">0bxx1x</span>, this register holds a Context ID.
</li></ul>

      
        <p>For other values of <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>.BT, this register is <span class="arm-defined-word">RES0</span>.</p>

      
        <p>Some breakpoints might not support Context ID comparison. For more information, see the description of the <a href="AArch32-dbgdidr.html">DBGDIDR</a>.CTX_CMPs field.</p>
      <h2>Field descriptions</h2><p>The DBGBVR&lt;n&gt; bit assignments are:</p><h3>When DBGBCR&lt;n&gt;.BT == 0b0x0x:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="30"><a href="#WhenDBGBCR&lt;n&gt;.BT0b0x0x_VA31:2_31">VA[31:2]</a></td><td class="lr" colspan="2"><a href="#WhenDBGBCR&lt;n&gt;.BT0b0x0x_0_1">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="WhenDBGBCR&lt;n&gt;.BT0b0x0x_VA31:2_31">VA[31:2], bits [31:2]
                  </h4>
          
  <p>Bits[31:2] of the address value for comparison.</p>

        <p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n&gt;.BT0b0x0x_0_1">
                Bits [1:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <div class="text_after_fields">
    
  

    </div><h3>When DBGBCR&lt;n&gt;.BT == 0b001x:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n&gt;.BT0b001x_ContextID_31">ContextID</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="WhenDBGBCR&lt;n&gt;.BT0b001x_ContextID_31">ContextID, bits [31:0]
                  </h4>
          
  <p>Context ID value for comparison.</p>
<p>The value is compared against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> when all of the following are true:</p>
<ul>
<li><span class="xref">ARMv8.1-VHE</span> is implemented.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1,1}.
</li><li>The PE is executing at EL0.
</li><li>EL2 is enabled in the current Security state, and is using AArch64.
</li></ul>
<p>Otherwise, the value is compared against <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p>

        <p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields">
    
  

    </div><h3>When DBGBCR&lt;n&gt;.BT == 0b101x and HaveEL(EL2):</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n&gt;.BT0b101xandHaveEL(EL2)_ContextID_31">ContextID</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="WhenDBGBCR&lt;n&gt;.BT0b101xandHaveEL(EL2)_ContextID_31">ContextID, bits [31:0]
                  </h4>
          
  <p>Context ID value for comparison against <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p>

        <p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields">
    
  

    </div><h3>When DBGBCR&lt;n&gt;.BT == 0bx11x, HaveEL(EL2) and ARMv8.1-VHE is implemented:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n&gt;.BT0bx11x,HaveEL(EL2)andARMv8.1-VHEisimplemented_ContextID_31">ContextID</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="WhenDBGBCR&lt;n&gt;.BT0bx11x,HaveEL(EL2)andARMv8.1-VHEisimplemented_ContextID_31">ContextID, bits [31:0]
                  </h4>
          
  <p>Context ID value for comparison against <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p>

        <p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the DBGBVR&lt;n&gt;</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA&gt; != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA&gt; != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR[UInt(CRm&lt;3:0&gt;)];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR[UInt(CRm&lt;3:0&gt;)];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR[UInt(CRm&lt;3:0&gt;)];
              </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA&gt; != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA&gt; != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR[UInt(CRm&lt;3:0&gt;)] = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR[UInt(CRm&lt;3:0&gt;)] = R[t];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR[UInt(CRm&lt;3:0&gt;)] = R[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
