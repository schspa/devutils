<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GICH_HCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">GICH_HCR, Hypervisor Control Register</h1><p>The GICH_HCR characteristics are:</p><h2>Purpose</h2>
        <p>Controls the virtual CPU interface.</p>
      <h2>Configuration</h2><p>RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.</p>
        <p>This register is available when the GIC implementation supports interrupt virtualization.</p>
      <h2>Attributes</h2>
            <p>GICH_HCR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The GICH_HCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="5"><a href="#EOICount_31">EOICount</a></td><td class="lr" colspan="19"><a href="#0_26">RES0</a></td><td class="lr" colspan="1"><a href="#VGrp1DIE_7">VGrp1DIE</a></td><td class="lr" colspan="1"><a href="#VGrp1EIE_6">VGrp1EIE</a></td><td class="lr" colspan="1"><a href="#VGrp0DIE_5">VGrp0DIE</a></td><td class="lr" colspan="1"><a href="#VGrp0EIE_4">VGrp0EIE</a></td><td class="lr" colspan="1"><a href="#NPIE_3">NPIE</a></td><td class="lr" colspan="1"><a href="#LRENPIE_2">LRENPIE</a></td><td class="lr" colspan="1"><a href="#UIE_1">UIE</a></td><td class="lr" colspan="1"><a href="#En_0">En</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="EOICount_31">EOICount, bits [31:27]
                  </h4>
          
  <p>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in <a href="ext-gich_aprn.html">GICH_APR&lt;n&gt;</a> do not cause an increment. If an EOI occurs when the value of this field is 31, then the field wraps to 0.</p>
<p>The maintenance interrupt is asserted whenever this field is nonzero and GICH_HCR.LRENPIE == 1.</p>

        <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_26">
                Bits [26:8]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="VGrp1DIE_7">VGrp1DIE, bit [7]
              </h4>
          
  <p>VM Group 1 Disabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p>

        <table class="valuetable"><tr><th>VGrp1DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 0.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="VGrp1EIE_6">VGrp1EIE, bit [6]
              </h4>
          
  <p>VM Group 1 Enabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p>

        <table class="valuetable"><tr><th>VGrp1EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 1.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="VGrp0DIE_5">VGrp0DIE, bit [5]
              </h4>
          
  <p>VM Group 0 Disabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p>

        <table class="valuetable"><tr><th>VGrp0DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 0.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="VGrp0EIE_4">VGrp0EIE, bit [4]
              </h4>
          
  <p>VM Group 0 Enabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p>

        <table class="valuetable"><tr><th>VGrp0EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 1.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="NPIE_3">NPIE, bit [3]
              </h4>
          
  <p>No Pending Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers:</p>

        <table class="valuetable"><tr><th>NPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled while the List registers contain no interrupts in the pending state.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="LRENPIE_2">LRENPIE, bit [2]
              </h4>
          
  <p>List Register Entry Not Present Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register for an EOI request:</p>

        <table class="valuetable"><tr><th>LRENPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Maintenance interrupt signaled while GICH_HCR.EOICount is not 0.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UIE_1">UIE, bit [1]
              </h4>
          
  <p>Underflow Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt when the List registers are either empty or hold only one valid entry.</p>

        <table class="valuetable"><tr><th>UIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Maintenance interrupt disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A maintenance interrupt is signaled if zero or one of the List register entries are marked as a valid interrupt.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="En_0">En, bit [0]
              </h4>
          
  <p>Enable.</p>
<p>Global enable bit for the virtual CPU interface.</p>

        <table class="valuetable"><tr><th>En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Virtual CPU interface operation is disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Virtual CPU interface operation is enabled.</p>
</td></tr></table>
              
  <p>When this field is 0:</p>
<ul>
<li>The virtual CPU interface does not signal any maintenance interrupts.
</li><li>The virtual CPU interface does not signal any virtual interrupts.
</li><li>A read of <a href="ext-gicv_iar.html">GICV_IAR</a> or <a href="ext-gicv_aiar.html">GICV_AIAR</a> returns a spurious interrupt ID.
</li></ul>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The VGrp1DIE, VGrp1EIE, VGrp0DIE, and VGrp0EIE fields permit the hypervisor to track the virtual CPU interfaces that are enabled. The hypervisor can then route interrupts that have multiple targets correctly and efficiently, without having to read the virtual CPU interface status.</p>
<p>See <span class="xref">Maintenance interrupts</span> and <a href="ext-gich_misr.html">GICH_MISR</a> for more information.</p>

    </div><h2>Accessing the GICH_HCR</h2>
        <p>This register is used only when System register access is not enabled. When System register access is enabled:</p>

      
        <ul>
<li>For AArch32 implementations, <a href="AArch32-ich_hcr.html">ICH_HCR</a> provides equivalent functionality.
</li><li>For AArch64 implementations, <a href="AArch64-ich_hcr_el2.html">ICH_HCR_EL2</a> provides equivalent functionality.
</li></ul>

      
        <p>GICH_HCR.En must be set to 1 for any virtual or maintenance interrupt to be asserted.</p>
      <h4>GICH_HCR can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>GIC Virtual interface control</td><td><span class="hexnumber">0x0000</span></td><td>GICH_HCR</td></tr></table><p>This interface is accessible as follows:</p><ul><li>When GICD_CTLR.DS == 0b0
            accesses to this register are <span class="access_level">RW</span>.
          </li><li>When IsAccessSecure()
            accesses to this register are <span class="access_level">RW</span>.
          </li><li>When !IsAccessSecure()
            accesses to this register are <span class="access_level">RW</span>.
          </li></ul><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
