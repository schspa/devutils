<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>TRFCR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">TRFCR_EL2, Trace Filter Control Register (EL2)</h1><p>The TRFCR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Provides EL2 controls for Trace.</p>
      <h2>Configuration</h2><p>AArch64 System register TRFCR_EL2 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-htrfcr.html">HTRFCR[31:0]
            </a>.
          </p><p>This register is present only
    when ARMv8.4-Trace is implemented.
      
    Otherwise, direct accesses to TRFCR_EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p><p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>TRFCR_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The TRFCR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="25"><a href="#0_63">RES0</a></td><td class="lr" colspan="2"><a href="#TS_6">TS</a></td><td class="lr" colspan="1"><a href="#0_4">RES0</a></td><td class="lr" colspan="1"><a href="#CX_3">CX</a></td><td class="lr" colspan="1"><a href="#0_2">RES0</a></td><td class="lr" colspan="1"><a href="#E2TRE_1">E2TRE</a></td><td class="lr" colspan="1"><a href="#E0HTRE_0">E0HTRE</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="0_63">
                Bits [63:7]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TS_6">TS, bits [6:5]
                  </h4>
          
  <p>Timestamp Control. Controls which timebase is used for trace timestamps.</p>

        <table class="valuetable"><tr><th>TS</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Timestamp controlled by <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a>.TS or <a href="AArch32-trfcr.html">TRFCR</a>.TS.</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Virtual timestamp. The traced timestamp is the physical counter value, minus the value of <a href="AArch64-cntvoff_el2.html">CNTVOFF_EL2</a>.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Guest Physical timestamp. The traced timestamp is the physical counter value, minus the value of <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a>.</p>
</td><td>When ARMv8.6-ECV is implemented</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Physical timestamp. The traced timestamp is the physical counter value.</p>
</td></tr></table>
              
  <p>All other values are reserved.</p>
<p>This field is ignored if SelfHostedTraceEnabled() == FALSE.</p>
<p>When EL2 is implemented and enabled in the current Security state, the physical counter uses a fixed physical offset of zero if either of the following are true:</p>
<ul>
<li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.ECV is 0.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.ECVEn is 0.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}.
</li></ul>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_4">
                Bit [4]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="CX_3">CX, bit [3]
              </h4>
          
  <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> and VMID trace enable.</p>

        <table class="valuetable"><tr><th>CX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> and VMID trace prohibited.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> and VMID trace allowed.</p>
</td></tr></table>
              
  <p>This field is ignored if SelfHostedTraceEnabled() == FALSE.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_2">
                Bit [2]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="E2TRE_1">E2TRE, bit [1]
              </h4>
          
  <p>EL2 Trace Enable.</p>

        <table class="valuetable"><tr><th>E2TRE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Trace is prohibited at EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Trace is allowed at EL2.</p>
</td></tr></table>
              
  <p>This field is ignored if SelfHostedTraceEnabled() == FALSE.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="E0HTRE_0">E0HTRE, bit [0]
              </h4>
          
  <p>EL0 Trace Enable.</p>

        <table class="valuetable"><tr><th>E0HTRE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Trace is prohibited at EL0 when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Trace is allowed at EL0 when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.</p>
</td></tr></table>
              
  <p>This field is ignored if any of the following are true:</p>
<ul>
<li>SelfHostedTraceEnabled() == FALSE.
</li><li>EL2 is disabled in the current security state.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 0.
</li></ul>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the TRFCR_EL2</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, TRFCR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return TRFCR_EL2;
elsif PSTATE.EL == EL3 then
    return TRFCR_EL2;
              </p><h4 class="assembler">MSR TRFCR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        TRFCR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    TRFCR_EL2 = X[t];
              </p><h4 class="assembler">MRS &lt;Xt&gt;, TRFCR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TTRF == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        return NVMem[0x880];
    else
        return TRFCR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        return TRFCR_EL2;
    else
        return TRFCR_EL1;
elsif PSTATE.EL == EL3 then
    return TRFCR_EL1;
              </p><h4 class="assembler">MSR TRFCR_EL1, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.TRFCR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TTRF == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        NVMem[0x880] = X[t];
    else
        TRFCR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TTRF == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        TRFCR_EL2 = X[t];
    else
        TRFCR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    TRFCR_EL1 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
