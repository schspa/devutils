<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>MDCR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">MDCR_EL2, Monitor Debug Configuration Register (EL2)</h1><p>The MDCR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Provides EL2 configuration options for self-hosted debug and the Performance Monitors Extension.</p>
      <h2>Configuration</h2><p>AArch64 System register MDCR_EL2 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-hdcr.html">HDCR[31:0]
            </a>.
          </p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>

      
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>
      <p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>MDCR_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The MDCR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="3"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#MTPME_28">MTPME</a></td><td class="lr" colspan="1"><a href="#TDCC_27">TDCC</a></td><td class="lr" colspan="1"><a href="#HLP_26">HLP</a></td><td class="lr" colspan="2"><a href="#0_25">RES0</a></td><td class="lr" colspan="1"><a href="#HCCD_23">HCCD</a></td><td class="lr" colspan="3"><a href="#0_22">RES0</a></td><td class="lr" colspan="1"><a href="#TTRF_19">TTRF</a></td><td class="lr" colspan="1"><a href="#0_18">RES0</a></td><td class="lr" colspan="1"><a href="#HPMD_17">HPMD</a></td><td class="lr" colspan="2"><a href="#0_16">RES0</a></td><td class="lr" colspan="1"><a href="#TPMS_14">TPMS</a></td><td class="lr" colspan="2"><a href="#E2PB_13">E2PB</a></td><td class="lr" colspan="1"><a href="#TDRA_11">TDRA</a></td><td class="lr" colspan="1"><a href="#TDOSA_10">TDOSA</a></td><td class="lr" colspan="1"><a href="#TDA_9">TDA</a></td><td class="lr" colspan="1"><a href="#TDE_8">TDE</a></td><td class="lr" colspan="1"><a href="#HPME_7">HPME</a></td><td class="lr" colspan="1"><a href="#TPM_6">TPM</a></td><td class="lr" colspan="1"><a href="#TPMCR_5">TPMCR</a></td><td class="lr" colspan="5"><a href="#HPMN_4">HPMN</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="0_63">
                Bits [63:29]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="MTPME_28">MTPME, bit [28]
              <div style="font-size:smaller;"><br />When ARMv8.6-MTPMU is implemented and !HaveEL(EL3):
                </div></h4>
          
  <p>Multi-threaded PMU Enable. Enables use of the <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT bits.</p>

        <table class="valuetable"><tr><th>MTPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>ARMv8.6-MTPMU is disabled. The Effective value of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT is zero.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT bits not affected by this bit.</p>
</td></tr></table>
              
  <p>If ARMv8.6-MTPMU is disabled for any other PE in the system that has the same level 1 Affinity as the PE, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the PE behaves as if this bit is 0.</p>

            <p>On a Cold reset, this field resets to <span class="binarynumber">1</span>.
</p><h4 id="0_28"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TDCC_27">TDCC, bit [27]
              <div style="font-size:smaller;"><br />When ARMv8.6-FGT is implemented:
                </div></h4>
          
  <p>Trap DCC. Traps use of the Debug Comms Channel at EL1 and EL0 to EL2.</p>

        <table class="valuetable"><tr><th>TDCC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any register accesses to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>If EL2 is implemented and enabled in the current Security state, accesses to the DCC registers at EL1 and EL0 generate a Trap exception to EL2, unless the access also generates a higher priority exception.</p>
<p>Traps on the DCC data transfer registers are ignored when the PE is in Debug state.</p>
</td></tr></table>
              
  <p>The DCC registers trapped by this control are:</p>
<p>AArch64: <a href="AArch64-osdtrrx_el1.html">OSDTRRX_EL1</a>, <a href="AArch64-osdtrtx_el1.html">OSDTRTX_EL1</a>, <a href="AArch64-mdccsr_el0.html">MDCCSR_EL0</a>, <a href="AArch64-mdccint_el1.html">MDCCINT_EL1</a>, and, when the PE is in Non-debug state, <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p>
<p>AArch32: <a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, and, when the PE is in Non-debug state, <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p>
<p>The traps are reported with EC syndrome value:</p>
<ul>
<li>
<p><span class="hexnumber">0x05</span> for trapped AArch32 <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1110</span>.</p>

</li><li>
<p><span class="hexnumber">0x06</span> for trapped AArch32 <span class="instruction">LDC</span> to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> and <span class="instruction">STC</span> from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.</p>

</li><li>
<p><span class="hexnumber">0x18</span> for trapped AArch64 <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses.</p>

</li></ul>
<p>When the PE is in Debug state, MDCR_EL2.TDCC does not trap any accesses to:</p>
<p>AArch64: <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p>
<p>AArch32: <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_27"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="HLP_26">HLP, bit [26]
              <div style="font-size:smaller;"><br />When ARMv8.5-PMU is implemented:
                </div></h4>
          
  <p>Hypervisor Long event counter enable. Determines when unsigned overflow is recorded by a counter overflow bit.</p>

        <table class="valuetable"><tr><th>HLP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[31:0].</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[63:0].</p>
</td></tr></table>
              
  <p>If MDCR_EL2.HPMN is less than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N or <a href="AArch32-pmcr.html">PMCR</a>.N, this bit affects the operation of event counters in the range [MDCR_EL2.HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)] or [MDCR_EL2.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)]. Otherwise this bit has no effect on the operation of the event counters.</p>
<div class="note"><span class="note-header">Note</span><p>The effect of MDCR_EL2.HPMN on the operation of this bit always applies if EL2 is implemented, at all Exception levels including EL2 and EL3, and regardless of whether EL2 is enabled in the current Security state.</p></div><p>For more information see the description of the MDCR_EL2.HPMN field.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_26"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="0_25">
                Bits [25:24]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="HCCD_23">HCCD, bit [23]
              <div style="font-size:smaller;"><br />When ARMv8.5-PMU is implemented:
                </div></h4>
          
  <p>Hypervisor Cycle Counter Disable. Prohibits <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> from counting at EL2.</p>

        <table class="valuetable"><tr><th>HCCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this bit.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is prohibited at EL2.</p>
</td></tr></table>
              
  <p>This bit does not affect the CPU_CYCLES event or any other event that counts cycles.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="0_22">
                Bits [22:20]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TTRF_19">TTRF, bit [19]
              <div style="font-size:smaller;"><br />When ARMv8.4-Trace is implemented:
                </div></h4>
          
  <p>Traps use of the Trace Filter Control registers at EL1 to EL2, as follows:</p>
<ul>
<li>
<p>Access to <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> is trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>

</li><li>
<p>Access to <a href="AArch32-trfcr.html">TRFCR</a> is trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x03</span>.</p>

</li></ul>

        <table class="valuetable"><tr><th>TTRF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Accesses to <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> and <a href="AArch32-trfcr.html">TRFCR</a> at EL1 are not affected by this control.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Accesses to <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> and <a href="AArch32-trfcr.html">TRFCR</a> at EL1 generate a trap exception to EL2 when EL2 is enabled in the current Security state.</p>
</td></tr></table><h4 id="0_19"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="0_18">
                Bit [18]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="HPMD_17">HPMD, bit [17]
              <div style="font-size:smaller;"><br />When ARMv8.1-PMU is implemented:
                </div></h4>
          
  <p>Guest Performance Monitors Disable. This control prohibits event counting at EL2.</p>

        <table class="valuetable"><tr><th>HPMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event counting allowed at EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Event counting prohibited at EL2.</p>
<p>If ARMv8.2-Debug is not implemented, event counting is prohibited unless enabled by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface ExternalSecureNoninvasiveDebugEnabled().</p>
</td></tr></table>
              
  <p>This control applies only to:</p>
<ul>
<li>The event counters in the range [0..(MDCR_EL2.HPMN-1)].
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is set to 1, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>The other event counters are unaffected, and when <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is set to 0, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is unaffected.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_17"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="0_16">
                Bits [16:15]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TPMS_14">TPMS, bit [14]
              <div style="font-size:smaller;"><br />When SPE is implemented:
                </div></h4>
          
  <p>Trap Performance Monitor Sampling. When EL2 is enabled in the current Security state, this field controls access to Statistical Profiling control registers from EL1.</p>

        <table class="valuetable"><tr><th>TPMS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Do not trap Statistical Profiling controls to EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Accesses to Statistical Profiling controls at EL1 generate a Trap exception to EL2 when EL2 is enabled in the current Security state.</p>
</td></tr></table>
              
  <p>The Statistical Profiling control registers trapped by this control are: <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>, <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a>, <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>, <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a>, <a href="AArch64-pmsidr_el1.html">PMSIDR_EL1</a>, <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a>, and <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a>.</p>

            <h4 id="0_14"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="E2PB_13">E2PB, bits [13:12]
                  <div style="font-size:smaller;"><br />When SPE is implemented:
                </div></h4>
          
  <p>EL2 Profiling Buffer. If EL2 is implemented and enabled in the Profiling Buffer owning Security state, this field controls the owning translation regime. If EL2 is implemented and enabled in the current Security state, this field controls access to Profiling Buffer control registers from EL1.</p>

        <table class="valuetable"><tr><th>E2PB</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>If EL2 is implemented and enabled in the Profiling Buffer owning Security state, the Profiling Buffer uses the EL2 or EL2&amp;0 stage 1 translation regime. Otherwise the Profiling Buffer uses the EL1&amp;0 stage 1 translation regime. If EL2 is implemented and enabled in the current Security state, accesses to Profiling Buffer control registers at EL1 generate a Trap exception to EL2.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Profiling Buffer uses the EL1&amp;0 stage 1 translation regime. If EL2 is implemented and enabled in the current Security state, accesses to Profiling Buffer control registers at EL1 generate a Trap exception to EL2.</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Profiling Buffer uses the EL1&amp;0 stage 1 translation regime. Accesses to Profiling Buffer control registers at EL1 are not trapped to EL2.</p>
</td></tr></table>
              
  <p>All other values are reserved.</p>
<p>The Profiling Buffer control registers trapped by this control are: <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>, <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a>, and <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TDRA_11">TDRA, bit [11]
              </h4>
          
  <p>Trap Debug ROM Address register access. Traps System register accesses to the Debug ROM registers to EL2 when EL2 is enabled in the current Security state as follows:</p>
<ul>
<li>If EL1 is using AArch64 state, accesses to <a href="AArch64-mdrar_el1.html">MDRAR_EL1</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.
</li><li>If EL0 or EL1 is using AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span> and MRRC or MCRR accesses are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x0C</span>:<ul>
<li><a href="AArch32-dbgdrar.html">DBGDRAR</a>, <a href="AArch32-dbgdsar.html">DBGDSAR</a>.
</li></ul>

</li></ul>

        <table class="valuetable"><tr><th>TDRA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 and EL1 System register accesses to the Debug ROM registers are trapped to EL2 when EL2 is enabled in the current Security state, unless it is trapped by <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>.UDCCdis or <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC.</p>
</td></tr></table>
              
  <p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p>
<ul>
<li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on debug register accesses through the optional memory-mapped external debug interfaces.</p></div><p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TDOSA_10">TDOSA, bit [10]
              <div style="font-size:smaller;"><br />When ARMv8.0-DoubleLock is implemented:
                </div></h4>
          
  <p>Trap debug OS-related register access. Traps EL1 System register accesses to the powerdown debug registers to EL2, from both Execution states as follows:</p>
<ul>
<li>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>:<ul>
<li><a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a>, and <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul>

</li><li>In AArch32 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span>:<ul>
<li><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgosdlr.html">DBGOSDLR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul>

</li></ul>

        <table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 System register accesses to the powerdown debug registers are trapped to EL2 when EL2 is enabled in the current Security state.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p>
<ul>
<li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul>
<p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TDOSA_10"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
          
  <p>Trap debug OS-related register access. Traps EL1 System register accesses to the powerdown debug registers to EL2, from both Execution states as follows:</p>
<ul>
<li>
<p>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>:</p>
<ul>
<li>
<p><a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, and <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.</p>

</li><li>
<p>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.</p>

</li></ul>

</li><li>
<p>In AArch32 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span>:</p>
<ul>
<li>
<p><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.</p>

</li><li>
<p>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.</p>

</li></ul>

</li></ul>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> are trapped and <a href="AArch32-dbgosdlr.html">DBGOSDLR</a> are trapped.</p>

        <table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL1 System register accesses to the powerdown debug registers are trapped to EL2 when EL2 is enabled in the current Security state.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p>
<ul>
<li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on debug register accesses through the optional memory-mapped external debug interfaces.</p></div><p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TDA_9">TDA, bit [9]
              </h4>
          
  <p>Trap Debug Access. Traps EL0 and EL1 System register accesses to debug System registers that are not trapped by MDCR_EL2.TDRA or MDCR_EL2.TDOSA, as follows:</p>
<ul>
<li>In AArch64 state, accesses to the following registers are trapped to EL2 reported using EC syndrome value <span class="hexnumber">0x18</span>:<ul>
<li><a href="AArch64-mdccsr_el0.html">MDCCSR_EL0</a>, <a href="AArch64-mdccint_el1.html">MDCCINT_EL1</a>, <a href="AArch64-osdtrrx_el1.html">OSDTRRX_EL1</a>, <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>, <a href="AArch64-osdtrtx_el1.html">OSDTRTX_EL1</a>, <a href="AArch64-oseccr_el1.html">OSECCR_EL1</a>, <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n&gt;_El1</a>, <a href="AArch64-dbgclaimset_el1.html">DBGCLAIMSET_EL1</a>, <a href="AArch64-dbgclaimclr_el1.html">DBGCLAIMCLR_EL1</a>, <a href="AArch64-dbgauthstatus_el1.html">DBGAUTHSTATUS_EL1</a>.
</li><li>When not in Debug state, <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.
</li></ul>

</li><li>In AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span>.<ul>
<li><a href="AArch32-dbgdidr.html">DBGDIDR</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, <a href="AArch32-dbgwfar.html">DBGWFAR</a>, <a href="AArch32-dbgvcr.html">DBGVCR</a>, <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n&gt;</a>, <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>, <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a>, <a href="AArch32-dbgwcrn.html">DBGWCR&lt;n&gt;</a>, <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;</a>, <a href="AArch32-dbgclaimset.html">DBGCLAIMSET</a>, <a href="AArch32-dbgclaimclr.html">DBGCLAIMCLR</a>, <a href="AArch32-dbgauthstatus.html">DBGAUTHSTATUS</a>, <a href="AArch32-dbgdevid.html">DBGDEVID</a>, <a href="AArch32-dbgdevid1.html">DBGDEVID1</a>, <a href="AArch32-dbgdevid2.html">DBGDEVID2</a>, <a href="AArch32-dbgoseccr.html">DBGOSECCR</a>.
</li><li>When not in Debug state, <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul>

</li><li>In AArch32 state, STC accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and LDC accesses to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x06</span>.
</li></ul>

        <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 or EL1 System register accesses to the debug registers are trapped from both Execution states to EL2 when EL2 is enabled in the current Security state, unless the access generates a higher priority exception.</p>
</td></tr></table>
              
  <p>Traps of AArch32 accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> are ignored in Debug state.</p>
<p>Traps of AArch64 accesses to <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a> are ignored in Debug state.</p>
<p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p>
<ul>
<li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1
</li></ul>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TDE_8">TDE, bit [8]
              </h4>
          
  <p>Trap Debug exceptions.</p>

        <table class="valuetable"><tr><th>TDE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control has no effect on the routing of debug exceptions, and has no effect on accesses to debug registers.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Debug exceptions generated at EL1 or EL0 are routed to EL2 when EL2 is enabled in the current Security state. The MDCR_EL2.{TDRA, TDOSA, TDA} fields are treated as being 1 for all purposes other than returning the result of a direct read of the register.</p>
</td></tr></table>
              
  <p>This field is treated as being 1 for all purposes other than a direct read when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="HPME_7">HPME, bit [7]
              <div style="font-size:smaller;"><br />When PMUv3 is implemented:
                </div></h4>
          
  <p>[MDCR_EL2.HPMN..(N-1)] event counters enable.</p>

        <table class="valuetable"><tr><th>HPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event counters in the range [MDCR_EL2.HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)] are disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Event counters in the range [MDCR_EL2.HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)] are enabled by <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.</p>
</td></tr></table>
              
  <p>If MDCR_EL2.HPMN is less than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N or <a href="AArch32-pmcr.html">PMCR</a>.N, the event counters in the range [MDCR_EL2.HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)] or [HDCR.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)], are enabled and disabled by this bit. Otherwise this bit has no effect on the operation of the event counters.</p>
<div class="note"><span class="note-header">Note</span><p>The effect of MDCR_EL2.HPMN on the operation of this bit applies regardless of whether EL2 is enabled in the current Security state.</p></div><p>For more information see the description of the HPMN field.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_7"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TPM_6">TPM, bit [6]
              <div style="font-size:smaller;"><br />When PMUv3 is implemented:
                </div></h4>
          
  <p>Trap Performance Monitors accesses. Traps EL0 and EL1 accesses to all Performance Monitor registers to EL2 when EL2 is enabled in the current Security state, from both Execution states, as follows:</p>
<ul>
<li>
<p>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>:</p>
<ul>
<li><a href="AArch64-pmcr_el0.html">PMCR_EL0</a>, <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>, <a href="AArch64-pmcntenclr_el0.html">PMCNTENCLR_EL0</a>, <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a>, <a href="AArch64-pmswinc_el0.html">PMSWINC_EL0</a>, <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>, <a href="AArch64-pmceid0_el0.html">PMCEID0_EL0</a>, <a href="AArch64-pmceid1_el0.html">PMCEID1_EL0</a>, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>, <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a>, <a href="AArch64-pmxevcntr_el0.html">PMXEVCNTR_EL0</a>, <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>, <a href="AArch64-pmintenset_el1.html">PMINTENSET_EL1</a>, <a href="AArch64-pmintenclr_el1.html">PMINTENCLR_EL1</a>, <a href="AArch64-pmovsset_el0.html">PMOVSSET_EL0</a>, <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>, <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>, <a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a>.
</li></ul>

</li><li>
<p>In AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2 and reported using EC syndrome value <span class="hexnumber">0x03</span>, MRRC or MCRR accesses are trapped to EL2 and reported using EC syndrome value <span class="hexnumber">0x04</span>:</p>
<ul>
<li><a href="AArch32-pmcr.html">PMCR</a>, <a href="AArch32-pmcntenset.html">PMCNTENSET</a>, <a href="AArch32-pmcntenclr.html">PMCNTENCLR</a>, <a href="AArch32-pmovsr.html">PMOVSR</a>, <a href="AArch32-pmswinc.html">PMSWINC</a>, <a href="AArch32-pmselr.html">PMSELR</a>, <a href="AArch32-pmceid0.html">PMCEID0</a>, <a href="AArch32-pmceid1.html">PMCEID1</a>, <a href="AArch32-pmccntr.html">PMCCNTR</a>, <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a>, <a href="AArch32-pmxevntr.html">PMXEVNTR</a>, <a href="AArch32-pmuserenr.html">PMUSERENR</a>, <a href="AArch32-pmintenset.html">PMINTENSET</a>, <a href="AArch32-pmintenclr.html">PMINTENCLR</a>, <a href="AArch32-pmovsset.html">PMOVSSET</a>, <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n&gt;</a>, <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n&gt;</a>, <a href="AArch32-pmccfiltr.html">PMCCFILTR</a>.
</li></ul>

</li><li>
<p>If ARMv8.4-PMU is implemented, in AArch64 state, <a href="AArch64-pmmir_el1.html">PMMIR_EL1</a> and in AArch32 state, <a href="AArch32-pmmir.html">PMMIR</a>.</p>

</li><li>
<p>If ARMv8.1-PMU is implemented, in AArch32 state, <a href="AArch32-pmceid2.html">PMCEID2</a>, and <a href="AArch32-pmceid3.html">PMCEID3</a>.</p>

</li></ul>

        <table class="valuetable"><tr><th>TPM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 and EL1 accesses to all Performance Monitor registers are trapped to EL2 when EL2 is enabled in the current Security state.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</p></div>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="TPMCR_5">TPMCR, bit [5]
              <div style="font-size:smaller;"><br />When PMUv3 is implemented:
                </div></h4>
          
  <p>Trap <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> or <a href="AArch32-pmcr.html">PMCR</a> accesses. Traps EL0 and EL1 accesses to EL2, when EL2 is enabled in the current Security state, as follows:</p>
<ul>
<li>
<p>In AArch64 state, accesses to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>

</li><li>
<p>In AArch32 state, accesses to <a href="AArch32-pmcr.html">PMCR</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x03</span>.</p>

</li></ul>

        <table class="valuetable"><tr><th>TPMCR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This control does not cause any instructions to be trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EL0 and EL1 accesses to the <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> or <a href="AArch32-pmcr.html">PMCR</a> are trapped to EL2 when EL2 is enabled in the current Security state, unless it is trapped by <a href="AArch32-pmuserenr.html">PMUSERENR</a>.EN or <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.EN.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</p></div>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_5"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="HPMN_4">HPMN, bits [4:0]
                  <div style="font-size:smaller;"><br />When PMUv3 is implemented:
                </div></h4>
          
  <p>Defines the number of event counters that are accessible from EL3, EL2, EL1, and from EL0 if permitted.</p>
<p>If HPMN is less than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, HPMN divides the Performance Monitors into two ranges: [0..(HPMN-1)] and [HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)].</p>
<p>For an event counter in the range [0..(HPMN-1)]:</p>
<ul>
<li>The counter is accessible from EL3, EL2, and EL1, and from EL0 if permitted by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> or <a href="AArch32-pmuserenr.html">PMUSERENR</a>.
</li><li>If <span class="xref">ARMv8.5-PMU</span> is implemented, <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.LP or <a href="AArch32-pmcr.html">PMCR</a>.LP determines whether the counter overflow flag is set on unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[31:0] or <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[63:0].
</li><li>The counter is enabled by <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.E or <a href="AArch32-pmcr.html">PMCR</a>.E and bit &lt;n&gt; of <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>If HPMN is equal to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, this applies to all event counters.</p></div><p>If HPMN is less than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, for an event counter in the range [HPMN..(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1)]:</p>
<ul>
<li>The counter is accessible from EL2 and EL3.
</li><li>If <span class="xref">ARMv8.4-SecEL2</span> is disabled or is not implemented, the counter is also accessible from Secure EL1, and from Secure EL0 if permitted by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.
</li><li>If <span class="xref">ARMv8.5-PMU</span> is implemented, MDCR_EL2.HLP or <a href="AArch32-hdcr.html">HDCR</a>.HLP determines whether the counter overflow flag is set on unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[31:0] or <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[63:0].
</li><li>The counter is enabled by MDCR_EL2.HPME or <a href="AArch32-hdcr.html">HDCR</a>.HPME and bit &lt;n&gt; of <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.
</li></ul>
<p>If this field is set to 0, or to a value larger than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, then the following <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behaviors apply:</p>
<ul>
<li>The value returned by a direct read of MDCR_EL2.HPMN is <span class="arm-defined-word">UNKNOWN</span>.
</li><li>Either:<ul>
<li>An <span class="arm-defined-word">UNKNOWN</span> number of counters are reserved for EL2 and EL3 use. That is, the PE behaves as if MDCR_EL2.HPMN is set to an <span class="arm-defined-word">UNKNOWN</span> non-zero value less than or equal to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N.
</li><li>All counters are reserved for EL2 and EL3 use, meaning no counters are accessible from EL1 and EL0.
</li></ul>

</li></ul>

        <p>On a Warm reset, this field resets to the value in <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N.</p><h4 id="0_4"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the MDCR_EL2</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, MDCR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return MDCR_EL2;
elsif PSTATE.EL == EL3 then
    return MDCR_EL2;
              </p><h4 class="assembler">MSR MDCR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        MDCR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    MDCR_EL2 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
