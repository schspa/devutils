<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GICV_STATUSR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">GICV_STATUSR, Virtual Machine Error Reporting Status Register</h1><p>The GICV_STATUSR characteristics are:</p><h2>Purpose</h2>
        <p>Provides software with a mechanism to detect:</p>

      
        <ul>
<li>Accesses to reserved locations.
</li><li>Writes to read-only locations.
</li><li>Reads of write-only locations.
</li></ul>
      <h2>Configuration</h2><p></p>
        <p>In systems where this register is implemented, Arm expects that when a virtual machine is scheduled, the hypervisor ensures that this register is cleared to 0. The hypervisor might check for illegal accesses when the virtual machine is unscheduled.</p>
      <h2>Attributes</h2>
            <p>GICV_STATUSR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The GICV_STATUSR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="28"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#WROD_3">WROD</a></td><td class="lr" colspan="1"><a href="#RWOD_2">RWOD</a></td><td class="lr" colspan="1"><a href="#WRD_1">WRD</a></td><td class="lr" colspan="1"><a href="#RRD_0">RRD</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_31">
                Bits [31:4]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="WROD_3">WROD, bit [3]
              </h4>
          
  <p>Write to an RO location.</p>

        <table class="valuetable"><tr><th>WROD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Normal operation.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A write to an RO location has been detected.</p>
</td></tr></table>
              
  <p>When a violation is detected, software must write 1 to this register to reset it.</p>

            <h4 id="RWOD_2">RWOD, bit [2]
              </h4>
          
  <p>Read of a WO location.</p>

        <table class="valuetable"><tr><th>RWOD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Normal operation.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A read of a WO location has been detected.</p>
</td></tr></table>
              
  <p>When a violation is detected, software must write 1 to this register to reset it.</p>

            <h4 id="WRD_1">WRD, bit [1]
              </h4>
          
  <p>Write to a reserved location.</p>

        <table class="valuetable"><tr><th>WRD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Normal operation.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A write to a reserved location has been detected.</p>
</td></tr></table>
              
  <p>When a violation is detected, software must write 1 to this register to reset it.</p>

            <h4 id="RRD_0">RRD, bit [0]
              </h4>
          
  <p>Read of a reserved location.</p>

        <table class="valuetable"><tr><th>RRD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Normal operation.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A read of a reserved location has been detected.</p>
</td></tr></table>
              
  <p>When a violation is detected, software must write 1 to this register to reset it.</p>

            <div class="text_after_fields">
    
  

    </div><h2>Accessing the GICV_STATUSR</h2>
        <p>This is an optional register. If the register is implemented, <a href="ext-gicc_statusr.html">GICC_STATUSR</a> must also be implemented. If the register is not implemented, the location is RAZ/WI.</p>

      
        <p>This register is used only when System register access is not enabled. If System register access is enabled, this register is not updated. Equivalent function might be provided by appropriate traps and exceptions.</p>
      <h4>GICV_STATUSR can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>GIC Virtual CPU interface</td><td><span class="hexnumber">0x002C</span></td><td>GICV_STATUSR</td></tr></table><p>This interface is accessible as follows:</p><ul><li>When GICD_CTLR.DS == 0b0
            accesses to this register are <span class="access_level">RW</span>.
          </li><li>When IsAccessSecure()
            accesses to this register are <span class="access_level">RW</span>.
          </li><li>When !IsAccessSecure()
            accesses to this register are <span class="access_level">RW</span>.
          </li></ul><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
