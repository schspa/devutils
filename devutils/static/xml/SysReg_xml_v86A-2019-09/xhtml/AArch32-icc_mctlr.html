<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ICC_MCTLR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">ICC_MCTLR, Interrupt Controller Monitor Control Register</h1><p>The ICC_MCTLR characteristics are:</p><h2>Purpose</h2>
        <p>Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.</p>
      <h2>Configuration</h2><p>AArch32 System register ICC_MCTLR bits [31:0]
            
            can be mapped to
            AArch64 System register <a href="AArch64-icc_ctlr_el3.html">ICC_CTLR_EL3[31:0]
            </a>, but this is not architecturally mandated.
          </p><p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>ICC_MCTLR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The ICC_MCTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="12"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#ExtRange_19">ExtRange</a></td><td class="lr" colspan="1"><a href="#RSS_18">RSS</a></td><td class="lr" colspan="1"><a href="#nDS_17">nDS</a></td><td class="lr" colspan="1"><a href="#0_16">RES0</a></td><td class="lr" colspan="1"><a href="#A3V_15">A3V</a></td><td class="lr" colspan="1"><a href="#SEIS_14">SEIS</a></td><td class="lr" colspan="3"><a href="#IDbits_13">IDbits</a></td><td class="lr" colspan="3"><a href="#PRIbits_10">PRIbits</a></td><td class="lr" colspan="1"><a href="#0_7">RES0</a></td><td class="lr" colspan="1"><a href="#PMHE_6">PMHE</a></td><td class="lr" colspan="1"><a href="#RM_5">RM</a></td><td class="lr" colspan="1"><a href="#EOImode_EL1NS_4">EOImode_EL1NS</a></td><td class="lr" colspan="1"><a href="#EOImode_EL1S_3">EOImode_EL1S</a></td><td class="lr" colspan="1"><a href="#EOImode_EL3_2">EOImode_EL3</a></td><td class="lr" colspan="1"><a href="#CBPR_EL1NS_1">CBPR_EL1NS</a></td><td class="lr" colspan="1"><a href="#CBPR_EL1S_0">CBPR_EL1S</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_31">
                Bits [31:20]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="ExtRange_19">ExtRange, bit [19]
              </h4>
          
  <p>Extended INTID range (read-only).</p>

        <table class="valuetable"><tr><th>ExtRange</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>CPU interface does not support INTIDs in the range 1024..8191.</p>
<p>Behavior is <span class="arm-defined-word">UNPREDICTABLE</span> if the IRI delivers an interrupt in the range 1024 to 8191 to the CPU interface.</p>
<div class="note"><span class="note-header">Note</span><p>Arm strongly recommends that the IRI is not configured to deliver interrupts in this range to a PE that does not support them.</p></div>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>CPU interface supports INTIDs in the range 1024..8191</p>
<p>All INTIDs in the range 1024..8191 are treated as requiring deactivation.</p>
</td></tr></table><h4 id="RSS_18">RSS, bit [18]
              </h4>
          
  <p>Range Selector Support. Possible values are:</p>

        <table class="valuetable"><tr><th>RSS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Targeted SGIs with affinity level 0 values of 0 - 15 are supported.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Targeted SGIs with affinity level 0 values of 0 - 255 are supported.</p>
</td></tr></table>
              
  <p>This bit is read-only.</p>

            <h4 id="nDS_17">nDS, bit [17]
              </h4>
          
  <p>Disable Security not supported. Read-only and writes are ignored. Possible values are:</p>

        <table class="valuetable"><tr><th>nDS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The CPU interface logic supports disabling of security.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The CPU interface logic does not support disabling of security, and requires that security is not disabled.</p>
</td></tr></table><h4 id="0_16">
                Bit [16]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="A3V_15">A3V, bit [15]
              </h4>
          
  <p>Affinity 3 Valid. Read-only and writes are ignored. Possible values are:</p>

        <table class="valuetable"><tr><th>A3V</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The CPU interface logic does not support non-zero values of the Aff3 field in SGI generation System registers.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The CPU interface logic supports non-zero values of the Aff3 field in SGI generation System registers.</p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.AV3 is an alias of ICC_MCTLR.A3V</p>

            <h4 id="SEIS_14">SEIS, bit [14]
              </h4>
          
  <p>SEI Support. Read-only and writes are ignored. Indicates whether the CPU interface supports generation of SEIs:</p>

        <table class="valuetable"><tr><th>SEIS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The CPU interface logic does not support generation of SEIs.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The CPU interface logic supports generation of SEIs.</p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.SEIS is an alias of ICC_MCTLR.SEIS</p>

            <h4 id="IDbits_13">IDbits, bits [13:11]
                  </h4>
          
  <p>Identifier bits. Read-only and writes are ignored. The number of physical interrupt identifier bits supported:</p>

        <table class="valuetable"><tr><th>IDbits</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
  <p>16 bits.</p>
</td></tr><tr><td class="bitfield">0b001</td><td>
  <p>24 bits.</p>
</td></tr></table>
              
  <p>All other values are reserved.</p>
<p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.IDbits is an alias of ICC_MCTLR.IDbits</p>

            <h4 id="PRIbits_10">PRIbits, bits [10:8]
                  </h4>
          
  <p>Priority bits. Read-only and writes are ignored. The number of priority bits implemented, minus one.</p>
<p>An implementation that supports two Security states must implement at least 32 levels of physical priority (5 priority bits).</p>
<p>An implementation that supports only a single Security state must implement at least 16 levels of physical priority (4 priority bits).</p>
<div class="note"><span class="note-header">Note</span><p>This field always returns the number of priority bits implemented, regardless of the value of <span class="xref">SCR</span>.NS or the value of <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS.</p></div><p>The division between group priority and subpriority is defined in the binary point registers <a href="AArch32-icc_bpr0.html">ICC_BPR0</a> and <a href="AArch32-icc_bpr1.html">ICC_BPR1</a>.</p>
<p>This field determines the minimum value of ICC_BPR0.</p>

        <h4 id="0_7">
                Bit [7]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="PMHE_6">PMHE, bit [6]
              </h4>
          
  <p>Priority Mask Hint Enable.</p>

        <table class="valuetable"><tr><th>PMHE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Disables use of the priority mask register as a hint for interrupt distribution.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Enables use of the priority mask register as a hint for interrupt distribution.</p>
</td></tr></table>
              
  <p>Software must write <a href="AArch32-icc_pmr.html">ICC_PMR</a> to <span class="hexnumber">0xFF</span> before clearing this field to 0.</p>
<p>An implementation might choose to make this field RAO/WI.</p>
<p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.PMHE is an alias of ICC_MCTLR.PMHE.</p>

            <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="RM_5">RM, bit [5]
              </h4>
          
  <p>SBZ.</p>
<p>The equivalent bit in AArch64 is the Routing Modifier bit. This feature is not supported when EL3 is using AArch32.</p>

        <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EOImode_EL1NS_4">EOImode_EL1NS, bit [4]
              </h4>
          
  <p>EOI mode for interrupts handled at Non-secure EL1 and EL2. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>

        <table class="valuetable"><tr><th>EOImode_EL1NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(NS).EOImode is an alias of ICC_MCTLR.EOImode_EL1NS.</p>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EOImode_EL1S_3">EOImode_EL1S, bit [3]
              </h4>
          
  <p>EOI mode for interrupts handled at Secure EL1. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>

        <table class="valuetable"><tr><th>EOImode_EL1S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(S).EOImode is an alias of ICC_MCTLR.EOImode_EL1S.</p>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EOImode_EL3_2">EOImode_EL3, bit [2]
              </h4>
          
  <p>EOI mode for interrupts handled at EL3. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>

        <table class="valuetable"><tr><th>EOImode_EL3</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
</td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CBPR_EL1NS_1">CBPR_EL1NS, bit [1]
              </h4>
          
  <p>Common Binary Point Register, EL1 Non-secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Non-secure interrupts at EL1 and EL2:</p>

        <table class="valuetable"><tr><th>CBPR_EL1NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts only.</p>
<p><a href="AArch32-icc_bpr1.html">ICC_BPR1</a> determines the preemption group for Non-secure Group 1 interrupts.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts and Non-secure Group 1 interrupts. Non-secure accesses to <a href="ext-gicc_bpr.html">GICC_BPR</a> and <a href="AArch32-icc_bpr1.html">ICC_BPR1</a> access the state of <a href="AArch32-icc_bpr0.html">ICC_BPR0</a></p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(NS).CBPR is an alias of ICC_MCTLR.CBPR_EL1NS.</p>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CBPR_EL1S_0">CBPR_EL1S, bit [0]
              </h4>
          
  <p>Common Binary Point Register, EL1 Secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Secure interrupts in Secure non-Monitor modes:</p>

        <table class="valuetable"><tr><th>CBPR_EL1S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts only.</p>
<p><a href="AArch32-icc_bpr1.html">ICC_BPR1</a> determines the preemption group for Secure Group 1 interrupts.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts and Secure Group 1 interrupts. Secure EL1 accesses, or EL3 accesses when not in Monitor mode, to <a href="AArch32-icc_bpr1.html">ICC_BPR1</a> access the state of <a href="AArch32-icc_bpr0.html">ICC_BPR0</a>.</p>
</td></tr></table>
              
  <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(S).CBPR is an alias of ICC_MCTLR.CBPR_EL1S.</p>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the ICC_MCTLR</h2>
        <p>This register is only accessible when executing in Monitor mode.</p>
      <p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b110</td><td>0b1100</td><td>0b1100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T12 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T12 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    if ICC_MSRE.SRE == '0' then
        UNDEFINED;
    else
        return ICC_MCTLR;
              </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b110</td><td>0b1100</td><td>0b1100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T12 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T12 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    if ICC_MSRE.SRE == '0' then
        UNDEFINED;
    else
        ICC_MCTLR = R[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
