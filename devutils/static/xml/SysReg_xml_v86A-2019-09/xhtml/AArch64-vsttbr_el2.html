<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>VSTTBR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">VSTTBR_EL2, Virtualization Secure Translation Table Base Register</h1><p>The VSTTBR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>The base register for stage 2 of the Secure EL1&amp;0 translation regime. Holds the base address of the translation table for the initial lookup for stage 2 of an address translation in the Secure EL1&amp;0 translation regime, and other information for this translation stage.</p>
      <h2>Configuration</h2><p>This register is present only
    when ARMv8.4-SecEL2 is implemented.
      
    Otherwise, direct accesses to VSTTBR_EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p>
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>
      <p>
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>VSTTBR_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The VSTTBR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#0_63">RES0</a></td><td class="lr" colspan="16"><a href="#BADDR_47">BADDR</a></td></tr><tr class="firstrow"><td class="lr" colspan="31"><a href="#BADDR_47">BADDR</a></td><td class="lr" colspan="1"><a href="#CnP_0">CnP</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  <p>Any of the bits in VSTTBR_EL2 are permitted to be cached in a TLB.</p>

    </div><h4 id="0_63">
                Bits [63:48]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="BADDR_47">BADDR, bits [47:1]
                  </h4>
          
  <p>Translation table base address, A[47:x] or A[51:x].</p>
<div class="note"><span class="note-header">Note</span><ul><li>Translation table base addresses of 52 bits, A[51:x], are supported only in an implementation that includes <span class="xref">ARMv8.2-LPA</span> and is using the 64KB translation granule.</li><li>A translation table must be aligned to the size of the table, except that when using a translation table base address larger than 48 bits the minimum alignment of a table containing fewer than eight entries is 64 bytes.</li></ul></div><p>If the value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is <span class="binarynumber">0b110</span>, then:</p>
<ul>
<li>Register bits[47:z] hold bits[47:z] of the stage 1 translation table base address, where z is determined as follows:<ul>
<li>If x &gt;= 6 then z=x.
</li><li>Otherwise, z=6.
</li></ul>

</li><li>Register bits[5:2] hold bits[51:48] of the stage 1 translation table base address.
</li><li>When z&gt;x register bits[(z-1):x] are <span class="arm-defined-word">RES0</span>, and bits[(z-1):x] of the translation table base address are zero.
</li><li>When x&gt;6  register bits[(x-1):6] are <span class="arm-defined-word">RES0</span>.
</li><li>Register bit[1] is <span class="arm-defined-word">RES0</span>.
</li><li>Bits[5:2] of the stage 1 translation table base address are zero.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>When the value of <a href="AArch64-id_aa64mmfr0_el1.html">ID_AA64MMFR0_EL1</a>.PARange indicates that the implementation does not support a 52 bit PA size, if a translation table lookup uses this register with the 64KB translation granule when the value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is <span class="binarynumber">0b110</span> and the value of register bits[5:2] is nonzero, an Address size fault is generated.</p></div><p>If the Effective value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is not <span class="binarynumber">0b110</span> then:</p>
<ul>
<li>Register bits[47:x] hold bits[47:x] of the stage 1 translation table base address.
</li><li>Register bits[(x-1):1] are <span class="arm-defined-word">RES0</span>.
</li><li>If the implementation supports 52-bit PAs and IPAs then bits[51:48] of the translation table base addresses used in this stage of translation are <span class="binarynumber">0b0000</span>.
</li></ul>
<p>If any VSTTBR_EL2[47:1] bit that is defined as <span class="arm-defined-word">RES0</span> has the value 1 when a translation table walk is performed using VSTTBR_EL2, then the translation table base address might be misaligned, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p>
<ul>
<li>Bits[x-1:0] of the translation table base address are treated as if all the bits are zero. The value read back from the corresponding register bits is either the value written to the register or zero.
</li><li>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
</li></ul>
<p>The AArch64 Virtual Memory System Architecture chapter describes how x is calculated based on the value of <a href="AArch64-vstcr_el2.html">VSTCR_EL2</a>.T0SZ, the stage of translation, and the translation granule size.</p>

        <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CnP_0">CnP, bit [0]
              </h4>
          
  <p>Common not Private, for stage 2 of the Secure EL1&amp;0 translation regime. In an implementation that includes ARMv8.2-TTCNP, indicates whether each entry that is pointed to by VSTTBR_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of VSTTBR_EL2.CnP is 1.</p>

        <table class="valuetable"><tr><th>CnP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The translation table entries pointed to by VSTTBR_EL2 are permitted to differ from the entries for VSTTBR_EL2 for other PEs in the Inner Shareable domain. This is not affected by the value of the current VMID.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The translation table entries pointed to by VSTTBR_EL2 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of VSTTBR_EL2.CnP is 1 and the VMID is the same as the current VMID.</p>
</td></tr></table>
              
  <div class="note"><span class="note-header">Note</span><p>If the value of VSTTBR_EL2.CnP bit is 1 on multiple PEs in the same Inner Shareable domain and those VSTTBR_EL2s do not point to the same translation table entries when using the current VMID, then the results of translations using VSTTBR_EL2 are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, see <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behaviors due to caching of control or data values on page K1-6254.</p></div><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p>

            <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the VSTTBR_EL2</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, VSTTBR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0110</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; SCR_EL3.NS == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        return NVMem[0x030];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; SCR_EL3.NS == '1' then
        UNDEFINED;
    else
        return VSTTBR_EL2;
elsif PSTATE.EL == EL3 then
    if SCR_EL3.EEL2 == '0' then
        UNDEFINED;
    else
        return VSTTBR_EL2;
              </p><h4 class="assembler">MSR VSTTBR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0110</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; SCR_EL3.NS == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        NVMem[0x030] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; SCR_EL3.NS == '1' then
        UNDEFINED;
    else
        VSTTBR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    if SCR_EL3.EEL2 == '0' then
        UNDEFINED;
    else
        VSTTBR_EL2 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
