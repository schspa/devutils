<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PMCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">PMCR, Performance Monitors Control Register</h1><p>The PMCR characteristics are:</p><h2>Purpose</h2>
        <p>Provides details of the Performance Monitors implementation, including the number of counters implemented, and configures and controls the counters.</p>
      <h2>Configuration</h2><p>AArch32 System register PMCR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-pmcr_el0.html">PMCR_EL0[31:0]
            </a>.
          </p><p>AArch32 System register PMCR bits [7:0]
            
                are architecturally mapped to
              External register <a href="ext-pmcr_el0.html">PMCR_EL0[7:0]
            </a>.
          </p><p>This register is present only
    when PMUv3 is implemented.
      
    Otherwise, direct accesses to PMCR are <span class="arm-defined-word">UNDEFINED</span>.</p><p>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>PMCR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The PMCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#IMP_31">IMP</a></td><td class="lr" colspan="8"><a href="#IDCODE_23">IDCODE</a></td><td class="lr" colspan="5"><a href="#N_15">N</a></td><td class="lr" colspan="3"><a href="#0_10">RES0</a></td><td class="lr" colspan="1"><a href="#LP_7">LP</a></td><td class="lr" colspan="1"><a href="#LC_6">LC</a></td><td class="lr" colspan="1"><a href="#DP_5">DP</a></td><td class="lr" colspan="1"><a href="#X_4">X</a></td><td class="lr" colspan="1"><a href="#D_3">D</a></td><td class="lr" colspan="1"><a href="#C_2">C</a></td><td class="lr" colspan="1"><a href="#P_1">P</a></td><td class="lr" colspan="1"><a href="#E_0">E</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="IMP_31">IMP, bits [31:24]
                  </h4>
          
  <p>Implementer code. This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p>
<p>If this field is zero, then PMCR.IDCODE is <span class="arm-defined-word">RES0</span> and software must use <a href="AArch32-midr.html">MIDR</a> to identify the PE.</p>
<p>Otherwise this field and PMCR.IDCODE identify the PMU implementation to software. The implementer codes are allocated by Arm. A non-zero value has the same interpretation as <a href="AArch32-midr.html">MIDR</a>.Implementer.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="IDCODE_23">IDCODE, bits [23:16]
                  <div style="font-size:smaller;"><br />When PMCR.IMP != 0x00:
                </div></h4>
          
  <p>Identification code. This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p>
<p>Each implementer must maintain a list of identification codes that are specific to the implementer. A specific implementation is identified by the combination of the implementer code and the identification code.</p>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="0_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="N_15">N, bits [15:11]
                  </h4>
          
  <p>Indicates the number of event counters implemented. This value is in the range of <span class="binarynumber">0b00000</span>-<span class="binarynumber">0b111111</span>. If the value is <span class="binarynumber">0b00000</span> then only <a href="AArch32-pmccntr.html">PMCCNTR</a> is implemented. If the value is <span class="binarynumber">0b111111</span> <a href="AArch32-pmccntr.html">PMCCNTR</a> and 31 event counters are implemented.</p>
<p>In an implementation that includes EL2:</p>
<ul>
<li>
<p>If EL2 is using AArch32, reads of this field from Non-secure EL1 and Non-secure EL0 return the value of <a href="AArch32-hdcr.html">HDCR</a>.HPMN.</p>

</li><li>
<p>If EL2 is using AArch64 and enabled in the current Security state, reads of this field from EL1 and EL0 return the value of <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>

</li></ul>

        <p>Access to this field is <span class="access_level">RO</span>.</p><h4 id="0_10">
                Bits [10:8]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="LP_7">LP, bit [7]
              <div style="font-size:smaller;"><br />When ARMv8.5-PMU is implemented:
                </div></h4>
          
  <p>Long event counter enable. Determines when unsigned overflow is recorded by a counter overflow bit.</p>

        <table class="valuetable"><tr><th>LP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n&gt;</a>[31:0].</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n&gt;</a>[63:0].</p>
</td></tr></table>
              
  <p>If the highest implemented Exception level is using AArch32, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is RW or RAZ/WI.</p>
<p>If EL2 is implemented and <a href="AArch32-hdcr.html">HDCR</a>.HPMN or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN is less than PMCR.N, this bit does not affect the operation of event counters in the range [<a href="AArch32-hdcr.html">HDCR</a>.HPMN..(PMCR.N-1)] or [<a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN..(PMCR.N-1)].</p>
<p><a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n&gt;</a>[63:32] cannot be accessed directly in AArch32 state.</p>
<div class="note"><span class="note-header">Note</span><p>The effect of <a href="AArch32-hdcr.html">HDCR</a>.HPMN or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN on the operation of this bit always applies if EL2 is implemented, at all Exception levels including EL2 and EL3, and regardless of whether EL2 is enabled in the current Security state. For more information, see the description of <a href="AArch32-hdcr.html">HDCR</a>.HPMN or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p></div>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_7"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="LC_6">LC, bit [6]
              </h4>
          
  <p>Long cycle counter enable. Determines when unsigned overflow is recorded by the cycle counter overflow bit.</p>

        <table class="valuetable"><tr><th>LC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmccntr.html">PMCCNTR</a>[31:0].</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmccntr.html">PMCCNTR</a>[63:0].</p>
</td></tr></table>
              
  <p>Arm deprecates use of <a href="AArch32-pmcr.html">PMCR</a>.LC = 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DP_5">DP, bit [5]
              <div style="font-size:smaller;"><br />When HaveEL(EL3) or (ARMv8.1-PMU is implemented and HaveEL(EL2)):
                </div></h4>
          
  <p>Disable cycle counter when event counting is prohibited.</p>

        <table class="valuetable"><tr><th>DP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Cycle counting by <a href="AArch32-pmccntr.html">PMCCNTR</a> is not affected by this bit.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>When event counting for counters in the range [0..(<a href="AArch32-hdcr.html">HDCR</a>.HPMN-1)] or [0..(<a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN-1)] is prohibited, cycle counting by <a href="AArch32-pmccntr.html">PMCCNTR</a> is disabled.</p>
</td></tr></table>
              
  <p>For more information about the interaction between the Performance Monitors and EL3, see <span class="xref">'Effect of EL3 and EL2' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span></p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_5"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
        <h4 id="X_4">X, bit [4]
              <div style="font-size:smaller;"><br />When the implementation includes an PMU event export bus:
                </div></h4>
          
  <p>Enable export of events in an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus.</p>

        <table class="valuetable"><tr><th>X</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Do not export events.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Export events where not prohibited.</p>
</td></tr></table>
              
  <p>This field enables the exporting of events over an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus to another device, for example to an <span class="arm-defined-word">OPTIONAL</span> PE trace unit.</p>
<p>No events are exported when counting is prohibited.</p>
<p>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_4"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="D_3">D, bit [3]
              </h4>
          
  <p>Clock divider. The possible values of this bit are:</p>

        <table class="valuetable"><tr><th>D</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>When enabled, <a href="AArch32-pmccntr.html">PMCCNTR</a> counts every clock cycle.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>When enabled, <a href="AArch32-pmccntr.html">PMCCNTR</a> counts once every 64 clock cycles.</p>
</td></tr></table>
              
  <p>If PMCR.LC == 1, this bit is ignored and the cycle counter counts every clock cycle.</p>
<p>Arm deprecates use of PMCR.D = 1.</p>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="C_2">C, bit [2]
              </h4>
          
  <p>Cycle counter reset. The effects of writing to this bit are:</p>

        <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>No action.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Reset <a href="AArch32-pmccntr.html">PMCCNTR</a> to zero.</p>
</td></tr></table>
              
  <p>This bit is always RAZ.</p>
<div class="note"><span class="note-header">Note</span><p>Resetting <a href="AArch32-pmccntr.html">PMCCNTR</a> does not change the cycle counter overflow bit.</p><p>The value of PMCR_EL0.LC is ignored, and bits [63:0] of all affected event counters are reset.</p></div>

            <p>Access to this field is <span class="access_level">WO</span>.</p><h4 id="P_1">P, bit [1]
              </h4>
          
  <p>Event counter reset. The effects of writing to this bit are:</p>

        <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>No action.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Reset all event counters accessible in the current Exception level, not including <a href="AArch32-pmccntr.html">PMCCNTR</a>, to zero.</p>
</td></tr></table>
              
  <p>This bit is always RAZ.</p>
<p>In EL0 and EL1:</p>
<ul>
<li>If EL2 is implemented and enabled in the current Security state, and <a href="AArch32-hdcr.html">HDCR</a>.HPMN or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN is less than PMCR_EL0.N, a write of 1 to this bit does not reset event counters in the range [<a href="AArch32-hdcr.html">HDCR</a>.HPMN..(PMCR.N-1)] or [<a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN..(PMCR.N-1)].
</li><li>If EL2 is not implemented, EL2 is disabled in the current Security state, or <a href="AArch32-hdcr.html">HDCR</a>.HPMN or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN is equal to PMCR_EL0.N, a write of 1 to this bit resets all the event counters.
</li></ul>
<p>In EL2 and EL3, a write of 1 to this bit resets all the event counters.</p>
<div class="note"><span class="note-header">Note</span><p>Resetting the event counters does not change the event counter overflow bits.</p><p>If <span class="xref">ARMv8.5-PMU</span> is implemented, the values of <a href="AArch32-hdcr.html">HDCR</a>.HLP and PMCR.LP are ignored and bits [63:0] of all affected event counters are reset.</p></div>

            <p>Access to this field is <span class="access_level">WO</span>.</p><h4 id="E_0">E, bit [0]
              </h4>
          
  <p>Enable.</p>

        <table class="valuetable"><tr><th>E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>All event counters in the range [0..(PMN-1)] and <a href="AArch32-pmccntr.html">PMCCNTR</a>, are disabled.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>All event counters in the range [0..(PMN-1)] and <a href="AArch32-pmccntr.html">PMCCNTR</a>, are enabled by <a href="AArch32-pmcntenset.html">PMCNTENSET</a>.</p>
</td></tr></table>
              
  <p>If EL2 is implemented then:</p>
<ul>
<li>If EL2 is using AArch32, PMN is <a href="AArch32-hdcr.html">HDCR</a>.HPMN.
</li><li>If EL2 is using AArch64, PMN is <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.
</li><li>If PMN is less than PMCR.N, this bit does not affect the operation of event counters in the range [PMN..(PMCR.N-1)].
</li></ul>
<p>If EL2 is not implemented, PMN is PMCR.N.</p>
<div class="note"><span class="note-header">Note</span><p>The effect of <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN or <a href="AArch32-hdcr.html">HDCR</a>.HPMN on the operation of this bit always applies if EL2 is implemented, at all Exception levels including EL2 and EL3, regardless of whether EL2 is enabled in the current Security state. For more information, see the description of <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN or <a href="AArch32-hdcr.html">HDCR</a>.HPMN.</p></div>

            <p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the PMCR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1001</td><td>0b1100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if !ELUsingAArch32(EL1) &amp;&amp; PMUSERENR_EL0.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; PMUSERENR.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPMCR == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMCR;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPMCR == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMCR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMCR;
elsif PSTATE.EL == EL3 then
    return PMCR;
              </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1001</td><td>0b1100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if !ELUsingAArch32(EL1) &amp;&amp; PMUSERENR_EL0.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; PMUSERENR.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL1) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMCR_EL0 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPMCR == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        PMCR = R[t];
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPMCR == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        PMCR = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        PMCR = R[t];
elsif PSTATE.EL == EL3 then
    PMCR = R[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
