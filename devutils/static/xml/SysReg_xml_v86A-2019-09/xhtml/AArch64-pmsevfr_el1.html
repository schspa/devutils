<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PMSEVFR_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">PMSEVFR_EL1, Sampling Event Filter Register</h1><p>The PMSEVFR_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Controls sample filtering by events. The overall filter is the logical AND of these filters. For example, if E[3] and E[5] are both set to 1, only samples that have both event 3 (Level 1 unified or data cache refill) and event 5 set (TLB walk) are recorded</p>
      <h2>Configuration</h2><p>This register is present only
    when SPE is implemented.
      
    Otherwise, direct accesses to PMSEVFR_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><p>
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
            <p>PMSEVFR_EL1 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The PMSEVFR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[63</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[62</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[61</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[60</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[59</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[58</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[57</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[56</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[55</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[54</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[53</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[52</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[51</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[50</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[49</a></td><td class="lr" colspan="1"><a href="#E&lt;z&gt;_63">E[48</a></td><td class="lr" colspan="16"><a href="#0_47">RAZ/WI</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[31</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[30</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[29</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[28</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[27</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[26</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[25</a></td><td class="lr" colspan="1"><a href="#E&lt;y&gt;_31">E[24</a></td><td class="lr" colspan="5"><a href="#0_23">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E18_18">E[18]</a></td><td class="lr" colspan="1"><a href="#E17_17">E[17]</a></td><td class="lr" colspan="1"><a href="#0_16">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E&lt;x&gt;_15">E[15</a></td><td class="lr" colspan="1"><a href="#E&lt;x&gt;_15">E[14</a></td><td class="lr" colspan="1"><a href="#E&lt;x&gt;_15">E[13</a></td><td class="lr" colspan="1"><a href="#E&lt;x&gt;_15">E[12</a></td><td class="lr" colspan="1"><a href="#E11_11">E[11]</a></td><td class="lr" colspan="3"><a href="#0_10">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E7_7">E[7]</a></td><td class="lr" colspan="1"><a href="#0_6">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E5_5">E[5]</a></td><td class="lr" colspan="1"><a href="#0_4">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E3_3">E[3]</a></td><td class="lr" colspan="1"><a href="#0_2">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E1_1">E[1]</a></td><td class="lr" colspan="1"><a href="#0_0">RAZ/WI</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="E&lt;z&gt;_63">E[&lt;z&gt;], bit [z], for z = 48 to 63</h4>
          
  <p>E[&lt;z&gt;] is the event filter for event &lt;z&gt;. If event &lt;z&gt; is not implemented, or filtering on event &lt;z&gt; is not supported, the corresponding bit is RAZ/WI.</p>

        <table class="valuetable"><tr><th>E[&lt;z&gt;]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event &lt;z&gt; is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have event &lt;z&gt; == 0.</p>
</td></tr></table>
              
  <p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p>
<p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_47">
                Bits [47:32]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E&lt;y&gt;_31">E[&lt;y&gt;], bit [y], for y = 24 to 31</h4>
          
  <p>E[&lt;y&gt;] is the event filter for event &lt;y&gt;. If event &lt;y&gt; is not implemented, or filtering on event &lt;y&gt; is not supported, the corresponding bit is RAZ/WI.</p>

        <table class="valuetable"><tr><th>E[&lt;y&gt;]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event &lt;y&gt; is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have event &lt;y&gt; == 0.</p>
</td></tr></table>
              
  <p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p>
<p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_23">
                Bits [23:19]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E18_18">E[18], bit [18]
              <div style="font-size:smaller;"><br />When ARMv8.3-SPE is implemented and SVE is implemented:
                </div></h4>
          
  <p>Empty predicate.</p>

        <table class="valuetable"><tr><th>E[18]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Empty predicate event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Empty predicate event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_18"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E17_17">E[17], bit [17]
              <div style="font-size:smaller;"><br />When ARMv8.3-SPE is implemented and SVE is implemented:
                </div></h4>
          
  <p>Partial predicate.</p>

        <table class="valuetable"><tr><th>E[17]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Partial predicate event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Partial predicate event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_17"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="0_16">
                Bit [16]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E&lt;x&gt;_15">E[&lt;x&gt;], bit [x], for x = 12 to 15</h4>
          
  <p>E[&lt;x&gt;] is the event filter for event &lt;x&gt;. If event &lt;x&gt; is not implemented, or filtering on event &lt;x&gt; is not supported, the corresponding bit is RAZ/WI.</p>

        <table class="valuetable"><tr><th>E[&lt;x&gt;]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Event &lt;x&gt; is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have event &lt;x&gt; == 0.</p>
</td></tr></table>
              
  <p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p>
<p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="E11_11">E[11], bit [11]
              <div style="font-size:smaller;"><br />When ARMv8.3-SPE is implemented:
                </div></h4>
          
  <p>Alignment.</p>

        <table class="valuetable"><tr><th>E[11]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Alignment event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Alignment event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_11"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="0_10">
                Bits [10:8]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E7_7">E[7], bit [7]
              </h4>
          
  <p>Mispredicted.</p>

        <table class="valuetable"><tr><th>E[7]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Mispredicted event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Mispredicted event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bit [6]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E5_5">E[5], bit [5]
              </h4>
          
  <p>TLB walk.</p>

        <table class="valuetable"><tr><th>E[5]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>TLB walk event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the TLB walk event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_4">
                Bit [4]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E3_3">E[3], bit [3]
              </h4>
          
  <p>Level 1 data or unified cache refill.</p>

        <table class="valuetable"><tr><th>E[3]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Level 1 data or unified cache refill event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Level 1 data or unified cache refill event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_2">
                Bit [2]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <h4 id="E1_1">E[1], bit [1]
              <div style="font-size:smaller;"><br />When the PE supports sampling of speculative instructions:
                </div></h4>
          
  <p>Architecturally retired.</p>
<p>When the PE supports sampling of speculative instructions:</p>

        <table class="valuetable"><tr><th>E[1]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Architecturally retired event is ignored.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Do not record samples that have the Architecturally retired event == 0.</p>
</td></tr></table>
              
  <p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p>
<p>If the PE does not support the sampling of speculative instructions, or always discards the sample record for speculative instructions, this bit reads as an <span class="arm-defined-word">UNKNOWN</span> value and the PE ignores its value.</p>

            <p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UNKNOWN_1"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">UNKNOWN</span>.</p>
        <h4 id="0_0">
                Bit [0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p>
        <div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the PMSEVFR_EL1</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, PMSEVFR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMSEVFR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '1x1' then
        return NVMem[0x830];
    else
        return PMSEVFR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return PMSEVFR_EL1;
elsif PSTATE.EL == EL3 then
    return PMSEVFR_EL1;
              </p><h4 class="assembler">MSR PMSEVFR_EL1, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMSEVFR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '1x1' then
        NVMem[0x830] = X[t];
    else
        PMSEVFR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMSEVFR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    PMSEVFR_EL1 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">27/09/2019 18:48; 6134483bd14dc8c12a99c984cbfe3431cc1c9707</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
