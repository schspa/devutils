<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register execution_state="AArch32" is_register="True" is_internal="True" is_banked="True" is_optional="False" is_stub_entry="False">
      <reg_short_name>TTBR0</reg_short_name>
      <reg_long_name>Translation Table Base Register 0</reg_long_name>
        <reg_condition otherwise="UNKNOWN">when AArch32 is supported at any Exception level</reg_condition>
      

          <reg_reset_value></reg_reset_value>
      <reg_mappings>
          <reg_mapping>
              
            <mapped_name filename="AArch64-ttbr0_el1.xml">TTBR0_EL1</mapped_name>
            <mapped_type>Architectural</mapped_type>
              <mapped_execution_state>AArch64</mapped_execution_state>
              <mapped_from_startbit>63</mapped_from_startbit>
              <mapped_from_endbit>0</mapped_from_endbit>

              <mapped_to_startbit>63</mapped_to_startbit>
              <mapped_to_endbit>0</mapped_to_endbit>

          </reg_mapping>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the lower VA range in the PL1&amp;0 translation regime, and other information for this translation regime.</para>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
            <reg_group>Virtual memory control registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para><register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE determines which TTBR0 format is used:</para>

      </configuration_text>
      <configuration_text>
        <list type="unordered">
<listitem><content><register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE == <binarynumber>0b0</binarynumber>: 32-bit format is used. TTBR0[63:32] are ignored.</content>
</listitem><listitem><content><register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE == <binarynumber>0b1</binarynumber>: 64-bit format is used.</content>
</listitem></list>

      </configuration_text>
      <configuration_text>
        <para>When EL3 is using AArch32, write access to TTBR0(S) is disabled when the CP15SDISABLE signal is asserted HIGH.</para>

      </configuration_text>
      <configuration_text>
        <para>Used in conjunction with the <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>. When the 64-bit TTBR0 format is used, cacheability and shareability information is held in the <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>, not in TTBR0.</para>
      </configuration_text>

      </reg_configuration>
      <reg_attributes>
          
    
      <attributes_text>
        <para>TTBR0 is a 64-bit register that can also be accessed as a 32-bit value. If it is accessed as a 32-bit register, accesses read and write bits [31:0] and do not modify bits [63:32].</para>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="64">
      <fields_condition>When TTBCR.EAE == 0</fields_condition>
      <fields_instance>AArch32-TTBCR.EAE == 0</fields_instance>
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_63_32"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>32</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TTB0_31_7"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>TTB0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>7</field_lsb>
          <field_description order="before">
          
  <para>Translation table base address, bits[31:x], where x is 14-(TTBCR.N). Register bits [x-1:7] are <arm-defined-word>RES0</arm-defined-word>, with the additional requirement that if these bits are not all zero, this is a misaligned translation table base address, with effects that are <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>, and must be one of the following:</para>
<list type="unordered">
<listitem><content>Register bits [x-1:7] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.</content>
</listitem><listitem><content>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.</content>
</listitem></list>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="IRGN_6_6"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IRGN[0]</field_name>
          <field_msb>6</field_msb>
          <field_lsb>6</field_lsb>
          <field_description order="before">
          
  <para>This field is bit[0] of IRGN[1:0].</para>
<para>Inner region bits. Bits [0,6] of this register together indicate the Inner Cacheability attributes for the memory associated with the translation table walks. The possible values of IRGN[1:0] are:</para>

          </field_description>
            <field_values>
                <field_value_name>IRGN</field_value_name>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Normal memory, Inner Non-cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Normal memory, Inner Write-Back Write-Allocate Cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Normal memory, Inner Write-Through Cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>Normal memory, Inner Write-Back no Write-Allocate Cacheable.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>The encoding of the IRGN bits is counter-intuitive, with register bit[6] being IRGN[0] and register bit[0] being IRGN[1]. This encoding is chosen to give a consistent encoding of memory region types and to ensure that software written for ARMv7 without the Multiprocessing Extensions can run unmodified on an implementation that includes the functionality introduced by the ARMv7 Multiprocessing Extensions.</para></note><para>The IRGN field is split as follows:</para>
<list type="unordered">
<listitem><content>IRGN[0] is TTBR0[6].</content>
</listitem><listitem><content>IRGN[1] is TTBR0[0].</content>
</listitem></list>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="NOS_5_5"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>NOS</field_name>
          <field_msb>5</field_msb>
          <field_lsb>5</field_lsb>
          <field_description order="before">
          
  <para>Not Outer Shareable. When the value of TTBR0.S is 1, indicates whether the memory associated with a translation table walk is Inner Shareable or Outer Shareable:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Memory is Outer Shareable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Memory is Inner Shareable.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is ignored when the value of TTBR0.S is 0.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="RGN_4_3"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>RGN</field_name>
          <field_msb>4</field_msb>
          <field_lsb>3</field_lsb>
          <field_description order="before">
          
  <para>Region bits. Indicates the Outer cacheability attributes for the memory associated with the translation table walks:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Normal memory, Outer Non-cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Normal memory, Outer Write-Back Write-Allocate Cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Normal memory, Outer Write-Through Cacheable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>Normal memory, Outer Write-Back no Write-Allocate Cacheable.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="IMP_2_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IMP</field_name>
          <field_msb>2</field_msb>
          <field_lsb>2</field_lsb>
          <field_description order="before">
          
  <para>The effect of this bit is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>. If the translation table implementation does not include any <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> features this bit is <arm-defined-word>RES0</arm-defined-word>.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="S_1_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>S</field_name>
          <field_msb>1</field_msb>
          <field_lsb>1</field_lsb>
          <field_description order="before">
          
  <para>Shareable. Indicates whether the memory associated with the translation table walks is Non-shareable:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Memory is Non-shareable.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Memory is shareable. The TTBR0.NOS field indicates whether the memory is Inner Shareable or Outer Shareable.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="IRGN_0_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IRGN[1]</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>This field is bit[1] of IRGN[1:0].</para>
<para>See IRGN[0] for the field description.</para>

          </field_description>
            <field_values>
               
                 <field_value_name>I</field_value_name>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <fields length="64">
      <fields_condition>When TTBCR.EAE == 1</fields_condition>
      <fields_instance>AArch32-TTBCR.EAE==1</fields_instance>
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_63_56"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>56</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ASID_55_48"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>ASID</field_name>
          <field_msb>55</field_msb>
          <field_lsb>48</field_lsb>
          <field_description order="before">
          
  <para>An ASID for the translation table base address. The <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.A1 field selects either TTBR0.ASID or TTBR1.ASID.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="BADDR_47_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>BADDR</field_name>
          <field_msb>47</field_msb>
          <field_lsb>1</field_lsb>
          <field_description order="before">
          
  <para>Translation table base address, bits[47:x], Bits [x-1:1] are <arm-defined-word>RES0</arm-defined-word>, with the additional requirement that if bits[x-1:3] are not all zero, this is a misaligned translation table base address, with effects that are <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>, and must be one of the following:</para>
<list type="unordered">
<listitem><content>Register bits [x-1:3] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.</content>
</listitem><listitem><content>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.</content>
</listitem></list>
<para>x is determined from the value of <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.T0SZ as follows:</para>
<list type="unordered">
<listitem><content>If <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.T0SZ is 0 or 1, x = 5 - <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.T0SZ.</content>
</listitem><listitem><content>If <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.T0SZ is greater than 1, x = 14 - <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.T0SZ.</content>
</listitem></list>
<para>If bits[47:40] of the translation table base address are not zero, an Address size fault is generated.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="CnP_0_0_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>CnP</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>Common not Private. When <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE ==1, this bit indicates whether each entry that is pointed to by TTBR0 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR0.CnP is 1.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>The translation table entries pointed to by this instance of TTBR0, for the current ASID, are permitted to differ from corresponding entries for this instance of TTBR0 for other PEs in the Inner Shareable domain. This is not affected by:</para>
<list type="unordered">
<listitem><content>The value of TTBR0.CnP on those other PEs.</content>
</listitem><listitem><content>The value of <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE on those other PEs.</content>
</listitem><listitem><content>The value of the current ASID or, for the Non-secure instance of TTBR0, the value of the current VMID.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The translation table entries pointed to by this instance of TTBR0 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of TTBR0.CnP is 1 for this instance of TTBR0 and all of the following apply:</para>
<list type="unordered">
<listitem><content>The translation table entries are pointed to by this instance of TTBR0.</content>
</listitem><listitem><content>The value of the applicable <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE field is 1.</content>
</listitem><listitem><content>The ASID is the same as the current ASID.</content>
</listitem><listitem><content>For the Non-secure instance of TTBR0, the VMID is the same as the current VMID.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When a TLB combines entries from stage 1 translation and stage 2 translation into a single entry, that entry can only be shared between different PEs if the value of the CnP bit is 1 for both stage 1 and stage 2.</para>
<note><para>If the value of the TTBR0.CnP bit is 1 on multiple PEs in the same Inner Shareable domain and those TTBR0s do not point to the same translation table entries when the other conditions specified for the case when the value of CnP is 1 apply, then the results of translations are <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>, see <xref browsertext="'CONSTRAINED UNPREDICTABLE behaviors due to caching of control or data values' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile" filename="appx_architectural_constraints_on_unpredictable__.fm" linkend="CEGICEHJ"></xref>.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When ARMv8.2-TTCNP is implemented</fields_condition>
      </field>
        <field
           id="0_0_0_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <reg_fieldset length="64">
        <fields_condition>When TTBCR.EAE == 0</fields_condition>
      
        <fieldat id="0_63_32" msb="63" lsb="32"/>
        <fieldat id="TTB0_31_7" msb="31" lsb="7"/>
        <fieldat id="IRGN_6_6" msb="6" lsb="6"/>
        <fieldat id="NOS_5_5" msb="5" lsb="5"/>
        <fieldat id="RGN_4_3" msb="4" lsb="3"/>
        <fieldat id="IMP_2_2" msb="2" lsb="2"/>
        <fieldat id="S_1_1" msb="1" lsb="1"/>
        <fieldat id="IRGN_0_0" msb="0" lsb="0"/>
    </reg_fieldset>
  <reg_fieldset length="64">
        <fields_condition>When TTBCR.EAE == 1</fields_condition>
      
        <fieldat id="0_63_56" msb="63" lsb="56"/>
        <fieldat id="ASID_55_48" msb="55" lsb="48"/>
        <fieldat id="BADDR_47_1" msb="47" lsb="1"/>
        <fieldat id="CnP_0_0_1" msb="0" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
      


<access_mechanisms>
  


      <access_mechanism accessor="MRC TTBR0">
        <encoding>
          
          <access_instruction>MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="opc1" v="0b000"/>
            
            <enc n="CRn" v="0b0010"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="opc2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MRC" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return TTBR0_NS&lt;31:0&gt;;
    else
        return TTBR0&lt;31:0&gt;;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return TTBR0_NS&lt;31:0&gt;;
    else
        return TTBR0&lt;31:0&gt;;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        return TTBR0_S&lt;31:0&gt;;
    else
        return TTBR0_NS&lt;31:0&gt;;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MCR TTBR0">
        <encoding>
          
          <access_instruction>MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="opc1" v="0b000"/>
            
            <enc n="CRn" v="0b0010"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="opc2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MCR" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = ZeroExtend(R[t]);
    else
        TTBR0 = ZeroExtend(R[t]);
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = ZeroExtend(R[t]);
    else
        TTBR0 = ZeroExtend(R[t]);
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' &amp;&amp; CP15SDISABLE == HIGH then
        UNDEFINED;
    else
        if SCR.NS == '0' then
            TTBR0_S = ZeroExtend(R[t]);
        else
            TTBR0_NS = ZeroExtend(R[t]);
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MRRC TTBR0">
        <encoding>
          
          <access_instruction>MRRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;Rt2&gt;, &lt;CRm&gt;</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="CRm" v="0b0010"/>
            
            <enc n="opc1" v="0b0000"/>
        </encoding>
          <access_permission>
            <ps name="MRRC" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return TTBR0_NS;
    else
        return TTBR0;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return TTBR0_NS;
    else
        return TTBR0;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        return TTBR0_S;
    else
        return TTBR0_NS;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MCRR TTBR0">
        <encoding>
          
          <access_instruction>MCRR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;Rt2&gt;, &lt;CRm&gt;</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="CRm" v="0b0010"/>
            
            <enc n="opc1" v="0b0000"/>
        </encoding>
          <access_permission>
            <ps name="MCRR" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = R[t2]:R[t];
    else
        TTBR0 = R[t2]:R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = R[t2]:R[t];
    else
        TTBR0 = R[t2]:R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' &amp;&amp; CP15SDISABLE == HIGH then
        UNDEFINED;
    else
        if SCR.NS == '0' then
            TTBR0_S = R[t2]:R[t];
        else
            TTBR0_NS = R[t2]:R[t];
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</timestamp>
</register_page>