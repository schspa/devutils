<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SPSR_fiq</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">SPSR_fiq, Saved Program Status Register (FIQ mode)</h1><p>The SPSR_fiq characteristics are:</p><h2>Purpose</h2>
        <p>Holds the saved process state when an exception is taken to FIQ mode.</p>
      <h2>Configuration</h2><p>AArch32 System register SPSR_fiq bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-spsr_fiq.html">SPSR_fiq[31:0]
            </a>.
          </p><p>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to SPSR_fiq are <span class="arm-defined-word">UNKNOWN</span>.</p><h2>Attributes</h2>
            <p>SPSR_fiq is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The SPSR_fiq bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#N_31">N</a></td><td class="lr" colspan="1"><a href="#Z_30">Z</a></td><td class="lr" colspan="1"><a href="#C_29">C</a></td><td class="lr" colspan="1"><a href="#V_28">V</a></td><td class="lr" colspan="1"><a href="#Q_27">Q</a></td><td class="lr" colspan="2"><a href="#IT1:0_26">IT[1:0]</a></td><td class="lr" colspan="1"><a href="#J_24">J</a></td><td class="lr" colspan="1"><a href="#SSBS_23">SSBS</a></td><td class="lr" colspan="1"><a href="#PAN_22">PAN</a></td><td class="lr" colspan="1"><a href="#DIT_21">DIT</a></td><td class="lr" colspan="1"><a href="#IL_20">IL</a></td><td class="lr" colspan="4"><a href="#GE_19">GE</a></td><td class="lr" colspan="6"><a href="#IT7:2_15">IT[7:2]</a></td><td class="lr" colspan="1"><a href="#E_9">E</a></td><td class="lr" colspan="1"><a href="#A_8">A</a></td><td class="lr" colspan="1"><a href="#I_7">I</a></td><td class="lr" colspan="1"><a href="#F_6">F</a></td><td class="lr" colspan="1"><a href="#T_5">T</a></td><td class="lr" colspan="5"><a href="#M4:0_4">M[4:0]</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="N_31">N, bit [31]
              </h4>
          
  <p>Negative Condition flag. Set to the value of PSTATE.N on taking an exception to FIQ mode, and copied to PSTATE.N on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Z_30">Z, bit [30]
              </h4>
          
  <p>Zero Condition flag. Set to the value of PSTATE.Z on taking an exception to FIQ mode, and copied to PSTATE.Z on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="C_29">C, bit [29]
              </h4>
          
  <p>Carry Condition flag. Set to the value of PSTATE.C on taking an exception to FIQ mode, and copied to PSTATE.C on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="V_28">V, bit [28]
              </h4>
          
  <p>Overflow Condition flag. Set to the value of PSTATE.V on taking an exception to FIQ mode, and copied to PSTATE.V on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Q_27">Q, bit [27]
              </h4>
          
  <p>Overflow or saturation flag. Set to the value of PSTATE.Q on taking an exception to FIQ mode, and copied to PSTATE.Q on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IT1:0_26">IT[1:0], bits [26:25]
                  </h4>
          
  <p>If-Then. Set to the value of PSTATE.IT[1:0] on taking an exception to FIQ mode, and copied to PSTATE.IT[1:0] on executing an exception return operation in FIQ mode.</p>

          
            
  <p>On executing an exception return operation in FIQ mode SPSR_fiq.IT must contain a value that is valid for the instruction being returned to.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="J_24">J, bit [24]
              </h4>
          
  <p><span class="arm-defined-word">RES0</span>.</p>
<p>In previous versions of the architecture, the {J, T} bits determined the AArch32 Instruction set state.</p>
<p>Armv8 does not support either Jazelle state or T32EE state, and the T bit determines the Instruction set state.</p>

          
            
  

          <h4 id="SSBS_23">SSBS, bit [23]
              <div style="font-size:smaller;"><br />When ARMv8.0-SSBS is implemented:
                </div></h4>
          
  <p>Speculative Store Bypass. Set to the value of PSTATE.SSBS on taking an exception to FIQ mode, and copied to PSTATE.SSBS on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="PAN_22">PAN, bit [22]
              <div style="font-size:smaller;"><br />When ARMv8.1-PAN is implemented:
                </div></h4>
          
  <p>Privileged Access Never. Set to the value of PSTATE.PAN on taking an exception to FIQ mode, and copied to PSTATE.PAN on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_22"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="DIT_21">DIT, bit [21]
              <div style="font-size:smaller;"><br />When ARMv8.4-DIT is implemented:
                </div></h4>
          
  <p>Data Independent Timing. Set to the value of PSTATE.DIT on taking an exception to FIQ mode, and copied to PSTATE.DIT on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_21"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IL_20">IL, bit [20]
              </h4>
          
  <p>Illegal Execution state. Set to the value of PSTATE.IL on taking an exception to FIQ mode, and copied to PSTATE.IL on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="GE_19">GE, bits [19:16]
                  </h4>
          
  <p>Greater than or Equal flags. Set to the value of PSTATE.GE on taking an exception to FIQ mode, and copied to PSTATE.GE on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IT7:2_15">IT[7:2], bits [15:10]
                  </h4>
          
  <p>If-Then. Set to the value of PSTATE.IT[7:2] on taking an exception to FIQ mode, and copied to PSTATE.IT[7:2] on executing an exception return operation in FIQ mode.</p>

          
            
  <p>SPSR_fiq.IT must contain a value that is valid for the instruction being returned to.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="E_9">E, bit [9]
              </h4>
          
  <p>Endianness. Set to the value of PSTATE.E on taking an exception to FIQ mode, and copied to PSTATE.E on executing an exception return operation in FIQ mode.</p>

          
            
  <p>If the implementation does not support big-endian operation, SPSR_fiq.E is <span class="arm-defined-word">RES0</span>. If the implementation does not support little-endian operation, SPSR_fiq.E is <span class="arm-defined-word">RES1</span>. On executing an exception return operation in FIQ mode, if the implementation does not support big-endian operation at the Exception level being returned to, SPSR_fiq.E is <span class="arm-defined-word">RES0</span>, and if the implementation does not support little-endian operation at the Exception level being returned to, SPSR_fiq.E is <span class="arm-defined-word">RES1</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="A_8">A, bit [8]
              </h4>
          
  <p>SError interrupt mask. Set to the value of PSTATE.A on taking an exception to FIQ mode, and copied to PSTATE.A on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="I_7">I, bit [7]
              </h4>
          
  <p>IRQ interrupt mask. Set to the value of PSTATE.I on taking an exception to FIQ mode, and copied to PSTATE.I on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="F_6">F, bit [6]
              </h4>
          
  <p>FIQ interrupt mask. Set to the value of PSTATE.F on taking an exception to FIQ mode, and copied to PSTATE.F on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="T_5">T, bit [5]
              </h4>
          
  <p>T32 Instruction set state. Set to the value of PSTATE.T on taking an exception to FIQ mode, and copied to PSTATE.T on executing an exception return operation in FIQ mode.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="M4:0_4">M[4:0], bits [4:0]
                  </h4>
          
  <p>Mode. Set to the value of PSTATE.M[4:0] on taking an exception to FIQ mode, and copied to PSTATE.M[4:0] on executing an exception return operation in FIQ mode.</p>

          <table class="valuetable"><tr><th>M[4:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b10000</td><td>
  <p>User.</p>
</td></tr><tr><td class="bitfield">0b10001</td><td>
  <p>FIQ.</p>
</td></tr><tr><td class="bitfield">0b10010</td><td>
  <p>IRQ.</p>
</td></tr><tr><td class="bitfield">0b10011</td><td>
  <p>Supervisor.</p>
</td></tr><tr><td class="bitfield">0b10111</td><td>
  <p>Abort.</p>
</td></tr><tr><td class="bitfield">0b11011</td><td>
  <p>Undefined.</p>
</td></tr><tr><td class="bitfield">0b11111</td><td>
  <p>System.</p>
</td></tr></table>
            
  <p>Other values are reserved. If SPSR_fiq.M[4:0] has a Reserved value, or a value for an unimplemented Exception level, executing an exception return operation in FIQ mode is an illegal return event, as described in <span class="xref">'Illegal return events from AArch32 state' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the SPSR_fiq</h2>
        <p>SPSR_fiq is accessible in all modes other than User mode and FIQ mode.</p>
      <p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS{&lt;c&gt;}{&lt;q&gt;} &lt;Rd&gt;, SPSR_fiq</h4><table class="access_instructions"><tr><th>R</th><th>M</th><th>M1</th></tr><tr><td>0b1</td><td>0b0</td><td>0b1110</td></tr></table><h4 class="assembler">MSR{&lt;c&gt;}{&lt;q&gt;} SPSR_fiq, &lt;Rn&gt;</h4><table class="access_instructions"><tr><th>R</th><th>M</th><th>M1</th></tr><tr><td>0b1</td><td>0b0</td><td>0b1110</td></tr></table></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
