<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SPSR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">SPSR, Saved Program Status Register</h1><p>The SPSR characteristics are:</p><h2>Purpose</h2>
        <p>Holds the saved process state for the current mode.</p>
      <h2>Configuration</h2><p>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to SPSR are <span class="arm-defined-word">UNKNOWN</span>.</p><h2>Attributes</h2>
            <p>SPSR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The SPSR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#N_31">N</a></td><td class="lr" colspan="1"><a href="#Z_30">Z</a></td><td class="lr" colspan="1"><a href="#C_29">C</a></td><td class="lr" colspan="1"><a href="#V_28">V</a></td><td class="lr" colspan="1"><a href="#Q_27">Q</a></td><td class="lr" colspan="2"><a href="#IT1:0_26">IT[1:0]</a></td><td class="lr" colspan="1"><a href="#J_24">J</a></td><td class="lr" colspan="1"><a href="#SSBS_23">SSBS</a></td><td class="lr" colspan="1"><a href="#PAN_22">PAN</a></td><td class="lr" colspan="1"><a href="#DIT_21">DIT</a></td><td class="lr" colspan="1"><a href="#IL_20">IL</a></td><td class="lr" colspan="4"><a href="#GE_19">GE</a></td><td class="lr" colspan="6"><a href="#IT7:2_15">IT[7:2]</a></td><td class="lr" colspan="1"><a href="#E_9">E</a></td><td class="lr" colspan="1"><a href="#A_8">A</a></td><td class="lr" colspan="1"><a href="#I_7">I</a></td><td class="lr" colspan="1"><a href="#F_6">F</a></td><td class="lr" colspan="1"><a href="#T_5">T</a></td><td class="lr" colspan="1"><a href="#M4_4">M[4]</a></td><td class="lr" colspan="4"><a href="#M3:0_3">M[3:0]</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="N_31">N, bit [31]
              </h4>
          
  <p>Set to the value of PSTATE.N on taking an exception to the current mode, and copied to PSTATE.N on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="Z_30">Z, bit [30]
              </h4>
          
  <p>Set to the value of PSTATE.Z on taking an exception to the current mode, and copied to PSTATE.Z on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="C_29">C, bit [29]
              </h4>
          
  <p>Set to the value of PSTATE.C on taking an exception to the current mode, and copied to PSTATE.C on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="V_28">V, bit [28]
              </h4>
          
  <p>Set to the value of PSTATE.V on taking an exception to the current mode, and copied to PSTATE.V on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="Q_27">Q, bit [27]
              </h4>
          
  <p>Set to the value of PSTATE.Q on taking an exception to the current mode, and copied to PSTATE.Q on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="IT1:0_26">IT[1:0], bits [26:25]
                  </h4>
          
  <p>IT block state bits for the T32 IT (If-Then) instruction. See IT[7:2] for explanation of this field.</p>

          
            
  

          <h4 id="J_24">J, bit [24]
              </h4>
          
  <p><span class="arm-defined-word">RES0</span>.</p>
<p>In previous versions of the architecture, the {J, T} bits determined the AArch32 Instruction set state. Armv8 does not support either Jazelle state or T32EE state, and the T bit determines the Instruction set state.</p>

          
            
  

          <h4 id="SSBS_23">SSBS, bit [23]
              <div style="font-size:smaller;"><br />When ARMv8.0-SSBS is implemented:
                </div></h4>
          
  <p>Speculative Store Bypass Safe. This bit is set to the value of PSTATE.SSBS on taking an exception to the current mode, and copied to PSTATE.SSBS on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="0_23"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="PAN_22">PAN, bit [22]
              <div style="font-size:smaller;"><br />When ARMv8.1-PAN is implemented:
                </div></h4>
          
  <p>Privileged Access Never. This bit is set  to the value of PSTATE.PAN on taking an exception to the current mode, and copied to PSTATE.PAN on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="0_22"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="DIT_21">DIT, bit [21]
              <div style="font-size:smaller;"><br />When ARMv8.4-DIT is implemented:
                </div></h4>
          
  <p>Data Independent Timing. This bit is set to the value of PSTATE.DIT on taking an exception to the current mode, and copied to PSTATE.DIT on executing an exception return operation in the current mode.</p>

          
            
  

          <h4 id="0_21"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IL_20">IL, bit [20]
              </h4>
          
  <p>Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.</p>

          
            
  

          <h4 id="GE_19">GE, bits [19:16]
                  </h4>
          
  <p>Greater than or Equal flags, for parallel addition and subtraction.</p>

          
            
  

          <h4 id="IT7:2_15">IT[7:2], bits [15:10]
                  </h4>
          
  <p>IT block state bits for the T32 IT (If-Then) instruction. This field must be interpreted in two parts.</p>
<ul>
<li>IT[7:5] holds the base condition for the IT block. The base condition is the top 3 bits of the condition code specified by the first condition field of the IT instruction.
</li><li>IT[4:0] encodes the size of the IT block, which is the number of instructions that are to be conditionally executed, by the position of the least significant 1 in this field. It also encodes the value of the least significant bit of the condition code for each instruction in the block.
</li></ul>
<p>The IT field is <span class="binarynumber">0b00000000</span> when no IT block is active.</p>

          
            
  

          <h4 id="E_9">E, bit [9]
              </h4>
          
  <p>Endianness state bit. Controls the load and store endianness for data accesses:</p>

          <table class="valuetable"><tr><th>E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Little-endian operation</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Big-endian operation.</p>
</td></tr></table>
            
  <p>Instruction fetches ignore this bit.</p>
<p>If an implementation does not provide Big-endian support, this bit is <span class="arm-defined-word">RES0</span>. If it does not provide Little-endian support, this bit is <span class="arm-defined-word">RES1</span>.</p>
<p>If an implementation provides Big-endian support but only at EL0, this bit is <span class="arm-defined-word">RES0</span> for an exception return to any Exception level other than EL0.</p>
<p>Likewise, if it provides Little-endian support only at EL0, this bit is <span class="arm-defined-word">RES1</span> for an exception return to any Exception level other than EL0.</p>

          
  <p>When the reset value of the SCTLR.EE bit is defined by a configuration input signal, that value also applies to the CPSR.E bit on reset, and therefore applies to software execution from reset.</p>
<h4 id="A_8">A, bit [8]
              </h4>
          
  <p>SError interrupt mask bit.</p>

          <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Exception not masked.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Exception masked.</p>
</td></tr></table>
            
  

          <h4 id="I_7">I, bit [7]
              </h4>
          
  <p>IRQ mask bit.</p>

          <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Exception not masked.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Exception masked.</p>
</td></tr></table>
            
  

          <h4 id="F_6">F, bit [6]
              </h4>
          
  <p>FIQ mask bit.</p>

          <table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Exception not masked.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Exception masked.</p>
</td></tr></table>
            
  

          <h4 id="T_5">T, bit [5]
              </h4>
          
  <p>T32 Instruction set state bit. Determines the AArch32 instruction set state that the exception was taken from.</p>

          <table class="valuetable"><tr><th>T</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Taken from A32 state.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Taken from T32 state.</p>
</td></tr></table>
            
  

          <h4 id="M4_4">M[4], bit [4]
              </h4>
          
  <p>Execution state that the exception was taken from.</p>

          <table class="valuetable"><tr><th>M[4]</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td>
  <p>Exception taken from AArch32.</p>
</td></tr></table>
            
  

          <h4 id="M3:0_3">M[3:0], bits [3:0]
                  </h4>
          
  <p>AArch32 mode that an exception was taken from.</p>

          <table class="valuetable"><tr><th>M[3:0]</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0000</td><td>
  <p>User.</p>
</td></tr><tr><td class="bitfield">0b0001</td><td>
  <p>FIQ.</p>
</td></tr><tr><td class="bitfield">0b0010</td><td>
  <p>IRQ.</p>
</td></tr><tr><td class="bitfield">0b0011</td><td>
  <p>Supervisor.</p>
</td></tr><tr><td class="bitfield">0b0110</td><td>
  <p>Monitor (only valid in Secure state, if EL3 is implemented and can use AArch32).</p>
</td><td>When EL3 is implemented and EL3 is capable of using AArch32</td></tr><tr><td class="bitfield">0b0111</td><td>
  <p>Abort.</p>
</td></tr><tr><td class="bitfield">0b1010</td><td>
  <p>Hyp.</p>
</td></tr><tr><td class="bitfield">0b1011</td><td>
  <p>Undefined.</p>
</td></tr><tr><td class="bitfield">0b1111</td><td>
  <p>System.</p>
</td></tr></table>
            
  <p>Other values are reserved.</p>

          <div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the SPSR</h2>
        <p>SPSR can be read using the MRS instruction and written using the MSR (register) or MSR (immediate) instructions.</p>
      </div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
