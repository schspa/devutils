<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ICH_LR&lt;n&gt;_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">ICH_LR&lt;n&gt;_EL2, Interrupt Controller List Registers, n =
      0 - 15</h1><p>The ICH_LR&lt;n&gt;_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Provides interrupt context information for the virtual CPU interface.</p>
      <h2>Configuration</h2><p>AArch64 System register ICH_LR&lt;n&gt;_EL2 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-ich_lrn.html">ICH_LR&lt;n&gt;[31:0]
            </a>.
          </p><p>AArch64 System register ICH_LR&lt;n&gt;_EL2 bits [63:32]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-ich_lrcn.html">ICH_LRC&lt;n&gt;[31:0]
            </a>.
          </p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>

      
        <p>If list register n is not implemented, then accesses to this register are <span class="arm-defined-word">UNDEFINED</span>.</p>

      
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>
      <h2>Attributes</h2>
            <p>ICH_LR&lt;n&gt;_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The ICH_LR&lt;n&gt;_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="2"><a href="#State_63">State</a></td><td class="lr" colspan="1"><a href="#HW_61">HW</a></td><td class="lr" colspan="1"><a href="#Group_60">Group</a></td><td class="lr" colspan="4"><a href="#0_59">RES0</a></td><td class="lr" colspan="8"><a href="#Priority_55">Priority</a></td><td class="lr" colspan="3"><a href="#0_47">RES0</a></td><td class="lr" colspan="13"><a href="#pINTID_44">pINTID</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#vINTID_31">vINTID</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  

    </div><h4 id="State_63">State, bits [63:62]
                  </h4>
          
  <p>The state of the interrupt:</p>

          <table class="valuetable"><tr><th>State</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Invalid (Inactive).</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Pending.</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Active.</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Pending and active.</p>
</td></tr></table>
            
  <p>The GIC updates these state bits as virtual interrupts proceed through the interrupt life cycle. Entries in the invalid state are ignored, except for the purpose of generating virtual maintenance interrupts.</p>
<p>For hardware interrupts, the pending and active state is held in the physical Distributor rather than the virtual CPU interface. A hypervisor must only use the pending and active state for software originated interrupts, which are typically associated with virtual devices, or SGIs.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="HW_61">HW, bit [61]
              </h4>
          
  <p>Indicates whether this virtual interrupt maps directly to a hardware interrupt, meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the pINTID field indicates.</p>

          <table class="valuetable"><tr><th>HW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The interrupt is triggered entirely by software. No notification is sent to the Distributor when the virtual interrupt is deactivated.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The interrupt maps directly to a hardware interrupt.  A deactivate interrupt request is sent to the Distributor when the virtual interrupt is deactivated, using the pINTID field from this register to indicate the physical interrupt ID.</p>
<p>If <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VEOIM is 0, this request corresponds to a write to <a href="AArch64-icc_eoir0_el1.html">ICC_EOIR0_EL1</a> or <a href="AArch64-icc_eoir1_el1.html">ICC_EOIR1_EL1</a>. Otherwise, it corresponds to a write to <a href="AArch64-icc_dir_el1.html">ICC_DIR_EL1</a>.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Group_60">Group, bit [60]
              </h4>
          
  <p>Indicates the group for this virtual interrupt.</p>

          <table class="valuetable"><tr><th>Group</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>This is a Group 0 virtual interrupt. <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VFIQEn determines whether it is signaled as a virtual IRQ or as a virtual FIQ, and <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG0 enables signaling of this interrupt to the virtual machine.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This is a Group 1 virtual interrupt, signaled as a virtual IRQ.  <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VENG1 enables the signalling of this interrupt to the virtual machine.</p>
<p>If <a href="AArch64-ich_vmcr_el2.html">ICH_VMCR_EL2</a>.VCBPR is 0, then <a href="AArch64-icc_bpr1_el1.html">ICC_BPR1_EL1</a> determines if a pending Group 1 interrupt has sufficient priority to preempt current execution. Otherwise, <a href="AArch64-ich_lrn_el2.html">ICH_LR&lt;n&gt;_EL2</a> determines preemption.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_59">
                Bits [59:56]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="Priority_55">Priority, bits [55:48]
                  </h4>
          
  <p>The priority of this interrupt.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> how many bits of priority are implemented, though at least five bits must be implemented. Unimplemented bits are <span class="arm-defined-word">RES0</span> and start from bit[48] up to bit[50]. The number of implemented bits can be discovered from <a href="AArch64-ich_vtr_el2.html">ICH_VTR_EL2</a>.PRIbits.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_47">
                Bits [47:45]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="pINTID_44">pINTID, bits [44:32]
                  </h4>
          
  <p>Physical INTID, for hardware interrupts.</p>
<p>When ICH_LR&lt;n&gt;_EL2.HW is 0 (there is no corresponding physical interrupt), this field has the following meaning:</p>
<ul>
<li>Bits[44:42] : <span class="arm-defined-word">RES0</span>.
</li><li>Bit[41] : EOI. If this bit is 1, then when the interrupt identified by vINTID is deactivated, a maintenance interrupt is asserted.
</li><li>Bits[40:32] : <span class="arm-defined-word">RES0</span>.
</li></ul>
<p>When ICH_LR&lt;n&gt;_EL2.HW is 1 (there is a corresponding physical interrupt):</p>
<ul>
<li>This field indicates the physical INTID. This field is only required to implement enough bits to hold a valid value for the implemented INTID size. Any unused higher order bits are <span class="arm-defined-word">RES0</span>.
</li><li>When <a href="AArch64-icc_ctlr_el1.html">ICC_CTLR_EL1</a>.ExtRange is 0, then bits[44:42] of this field are <span class="arm-defined-word">RES0</span>.
</li><li>If the value of pINTID is not a vald INTID, behavior is <span class="arm-defined-word">UNPREDICTABLE</span>. If the value of pINTID indicates a PPI, this field applies to the PPI associated with this same physical PE ID as the virtual CPU interface requesting the deactivation.
</li></ul>
<p>A hardware physical identifier is only required in List Registers for interrupts that require deactivation. This means only 13 bits of Physical INTID are required, regardless of the number specified by <a href="AArch64-icc_ctlr_el1.html">ICC_CTLR_EL1</a>.IDbits.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="vINTID_31">vINTID, bits [31:0]
                  </h4>
          
  <p>Virtual INTID of the interrupt.</p>
<p>If the value of vINTID is 1020-1023 and ICH_LR&lt;n&gt;_EL2.State!=<span class="binarynumber">0b00</span> (Inactive), behavior is <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
<p>Behavior is <span class="arm-defined-word">UNPREDICTABLE</span> if two or more List Registers specify the same vINTID when:</p>
<ul>
<li>ICH_LR&lt;n&gt;_EL2.State == <span class="binarynumber">0b01</span>.
</li><li>ICH_LR&lt;n&gt;_EL2.State == <span class="binarynumber">0b10</span>.
</li><li>ICH_LR&lt;n&gt;_EL2.State == <span class="binarynumber">0b11</span>.
</li></ul>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> how many bits are implemented, though at least 16 bits must be implemented. Unimplemented bits are <span class="arm-defined-word">RES0</span>. The number of implemented bits can be discovered from <a href="AArch64-ich_vtr_el2.html">ICH_VTR_EL2</a>.IDbits.</p>
<p>When <a href="AArch64-icc_sre_el1.html">ICC_SRE_EL1</a>.SRE == 0, specifying a vINTID in the LPI range is <span class="arm-defined-word">UNPREDICTABLE</span></p>
<div class="note"><span class="note-header">Note</span><p>When a VM is using memory-mapped access to the GIC, software must ensure that the correct source PE ID is provided in bits[12:10].</p></div>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the ICH_LR&lt;n&gt;_EL2</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, ICH_LR&lt;n&gt;_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1100</td><td>0b110:n[3]</td><td>n[2:0]</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        return NVMem[0x400+8*UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if ICC_SRE_EL2.SRE == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        return ICH_LR_EL2[UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)];
elsif PSTATE.EL == EL3 then
    if ICC_SRE_EL3.SRE == '0' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return ICH_LR_EL2[UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)];
              </p><h4 class="assembler">MSR ICH_LR&lt;n&gt;_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1100</td><td>0b110:n[3]</td><td>n[2:0]</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        NVMem[0x400+8*UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if ICC_SRE_EL2.SRE == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        ICH_LR_EL2[UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)] = X[t];
elsif PSTATE.EL == EL3 then
    if ICC_SRE_EL3.SRE == '0' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        ICH_LR_EL2[UInt(CRm&lt;0&gt;:op2&lt;2:0&gt;)] = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
