<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>AMCFGR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">AMCFGR, Activity Monitors Configuration Register</h1><p>The AMCFGR characteristics are:</p><h2>Purpose</h2>
        <p>Global configuration register for the activity monitors.</p>

      
        <p>Provides information on supported features, the number of counter groups implemented, the total number of activity monitor event counters implemented, and the size of the counters. AMCFGR is applicable to both the architected and the auxiliary counter groups.</p>
      <h2>Configuration</h2><p>AArch32 System register AMCFGR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-amcfgr_el0.html">AMCFGR_EL0[31:0]
            </a>.
          </p><p>AArch32 System register AMCFGR bits [31:0]
            
                are architecturally mapped to
              External register <a href="ext-amcfgr.html">AMCFGR[31:0]
            </a>.
          </p><p>This register is present only
    when AMUv1 is implemented.
      
    Otherwise, direct accesses to AMCFGR are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
            <p>AMCFGR is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The AMCFGR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="4"><a href="#NCG_31">NCG</a></td><td class="lr" colspan="3"><a href="#0_27">RES0</a></td><td class="lr" colspan="1"><a href="#HDBG_24">HDBG</a></td><td class="lr" colspan="10"><a href="#0_23">RAZ</a></td><td class="lr" colspan="6"><a href="#SIZE_13">SIZE</a></td><td class="lr" colspan="8"><a href="#N_7">N</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="NCG_31">NCG, bits [31:28]
                  </h4>
          
  <p>Defines the number of counter groups.</p>
<p>The number of implemented counter groups is defined as [AMCFGR.NCG + 1].</p>
<p>If the number of implemented auxiliary activity monitor event counters is zero, this field has a value of <span class="binarynumber">0b0000</span>. Otherwise, this field has a value of <span class="binarynumber">0b0001</span>.</p>

          
            
  

          <h4 id="0_27">
                Bits [27:25]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="HDBG_24">HDBG, bit [24]
              </h4>
          
  <p>Halt-on-debug supported.</p>
<p>From Armv8, this feature must be supported, and so this bit is <span class="binarynumber">0b1</span>.</p>

          <table class="valuetable"><tr><th>HDBG</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p><a href="AArch32-amcr.html">AMCR</a>.HDBG is <span class="arm-defined-word">RES0</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p><a href="AArch32-amcr.html">AMCR</a>.HDBG is read/write.</p>
</td></tr></table>
            
  

          <h4 id="0_23">
                Bits [23:14]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RAZ</span>.</p>
          <h4 id="SIZE_13">SIZE, bits [13:8]
                  </h4>
          
  <p>Defines the size of activity monitor event counters.</p>
<p>The size of the activity monitor event counters implemented by the Activity Monitors Extension is defined as [AMCFGR.SIZE + 1].</p>
<p>From Armv8, the counters are 64-bit, and so this field is <span class="binarynumber">0b111111</span>.</p>
<div class="note"><span class="note-header">Note</span><p>Software also uses this field to determine the spacing of counters in the memory-map. From Armv8, the counters are at doubleword-aligned addresses.</p></div>

          
            
  

          <h4 id="N_7">N, bits [7:0]
                  </h4>
          
  <p>Defines the number of activity monitor event counters.</p>
<p>The total number of counters implemented in all groups by the Activity Monitors Extension is defined as [AMCFGR.N + 1].</p>

          
            
  

          <div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the AMCFGR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1101</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if !ELUsingAArch32(EL1) &amp;&amp; AMUSERENR_EL0.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; HSTR_EL2.T13 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T13 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return AMCFGR;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T13 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T13 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return AMCFGR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return AMCFGR;
elsif PSTATE.EL == EL3 then
    return AMCFGR;
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
