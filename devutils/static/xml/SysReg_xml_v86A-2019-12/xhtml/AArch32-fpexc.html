<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>FPEXC</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">FPEXC, Floating-Point Exception Control register</h1><p>The FPEXC characteristics are:</p><h2>Purpose</h2>
        <p>Provides a global enable for the implemented Advanced SIMD and floating-point functionality, and reports floating-point status information.</p>
      <h2>Configuration</h2><p>AArch32 System register FPEXC bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-fpexc32_el2.html">FPEXC32_EL2[31:0]
            </a>.
          </p><p>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to FPEXC are <span class="arm-defined-word">UNKNOWN</span>.</p>
        <p>Implemented only if the implementation includes the Advanced SIMD and floating-point functionality.</p>
      <h2>Attributes</h2>
            <p>FPEXC is a 32-bit register.</p>
          <h2>Field descriptions</h2><p>The FPEXC bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#EX_31">EX</a></td><td class="lr" colspan="1"><a href="#EN_30">EN</a></td><td class="lr" colspan="1"><a href="#DEX_29">DEX</a></td><td class="lr" colspan="1"><a href="#FP2V_28">FP2V</a></td><td class="lr" colspan="1"><a href="#VV_27">VV</a></td><td class="lr" colspan="1"><a href="#TFV_26">TFV</a></td><td class="lr" colspan="15"><a href="#0_25">RES0</a></td><td class="lr" colspan="3"><a href="#VECITR_10">VECITR</a></td><td class="lr" colspan="1"><a href="#IDF_7">IDF</a></td><td class="lr" colspan="2"><a href="#0_6">RES0</a></td><td class="lr" colspan="1"><a href="#IXF_4">IXF</a></td><td class="lr" colspan="1"><a href="#UFF_3">UFF</a></td><td class="lr" colspan="1"><a href="#OFF_2">OFF</a></td><td class="lr" colspan="1"><a href="#DZF_1">DZF</a></td><td class="lr" colspan="1"><a href="#IOF_0">IOF</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="EX_31">EX, bit [31]
              </h4>
          
  <p>Exception bit. From Armv8, this bit is RAZ/WI.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EN_30">EN, bit [30]
              </h4>
          
  <p>Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following:</p>
<ul>
<li>VMSR accesses to the <a href="AArch32-fpexc.html">FPEXC</a> or <a href="AArch32-fpsid.html">FPSID</a>.
</li><li>VMRS accesses from the <a href="AArch32-fpexc.html">FPEXC</a>, <a href="AArch32-fpsid.html">FPSID</a>, <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a>, or <a href="AArch32-mvfr2.html">MVFR2</a>.
</li></ul>

          <table class="valuetable"><tr><th>EN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Accesses to the <a href="AArch32-fpscr.html">FPSCR</a>, and any of the SIMD and floating-point registers Q0-Q15, including their views as D0-D31 registers or S0-S31 registers, are <span class="arm-defined-word">UNDEFINED</span> at all Exception levels.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>This control permits access to the Advanced SIMD and floating-point functionality at all Exception levels.</p>
</td></tr></table>
            
  <p>Execution of floating-point and Advanced SIMD instructions in AArch32 state can be disabled or trapped by the following controls:</p>
<ul>
<li><a href="AArch32-cpacr.html">CPACR</a>.cp10, or, if executing at EL0, <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN.
</li><li>FPEXC.EN.
</li><li>If executing in Non-secure state:<ul>
<li><a href="AArch32-hcptr.html">HCPTR</a>.TCP10, or if EL2 is using AArch64, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP.
</li><li><a href="AArch32-nsacr.html">NSACR</a>.cp10, or if EL3 is using AArch64, <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP.
</li></ul>

</li><li>For Advanced SIMD instructions only:<ul>
<li>CPACR.ASEDIS.
</li><li>If executing in Non-secure state, <a href="AArch32-hcptr.html">HCPTR</a>.TASE and <a href="AArch32-nsacr.html">NSACR</a>.NSTRCDIS.
</li></ul>

</li></ul>
<p>See the descriptions of the controls for more information.</p>
<div class="note"><span class="note-header">Note</span><p>When executing at EL0 using AArch32:</p><ul><li>If EL1 is using AArch64 then behavior is as if the value of FPEXC.EN is 1.</li><li>If EL2 is using AArch64 and enabled in the current Security state, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{RW, TGE} is {1, 1}, then the behavior is as if the value of FPEXC.EN is 1.</li><li>If EL2 is using AArch64 and enabled in the current Security state, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{RW, TGE} is {0, 1}, then it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the behavior is:<ul><li>As if the value of FPEXC.EN is 1.</li><li>Determined by the value of FPEXC.EN, as described in this field description. However, Arm deprecates using the value of FPEXC.EN to determine behavior.</li></ul></li></ul></div>

          <p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="DEX_29">DEX, bit [29]
              </h4>
          
  <p>Defined synchronous exception on floating-point execution.</p>
<p>This field identifies whether a synchronous exception generated by the attempted execution of an instruction was generated by an unallocated encoding. The instruction must be in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr() returning TRUE. This field also indicates whether the FPEXC.TFV field is valid.</p>
<p>The meaning of this bit is:</p>

          <table class="valuetable"><tr><th>DEX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The exception was generated by the attempted execution of an unallocated instruction in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr(). If FPEXC.TFV is RW then it is invalid and <span class="arm-defined-word">UNKNOWN</span>. If FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} are RW then they are invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The exception was generated during the execution of an unallocated encoding. FPEXC.TFV is valid and indicates the cause of the exception.</p>
</td></tr></table>
            
  <p>On an exception that sets this bit to 1 the exception-handling routine must clear this bit to 0.</p>
<p>On an implementation that both does not support trapping of floating-point exceptions and implements the <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} fields as RAZ, this bit is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="FP2V_28">FP2V, bit [28]
              </h4>
          
  <p>FPINST2 instruction valid bit. From Armv8, this bit is <span class="arm-defined-word">RES0</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="VV_27">VV, bit [27]
              </h4>
          
  <p>VECITR valid bit. From Armv8, this bit is <span class="arm-defined-word">RES0</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TFV_26">TFV, bit [26]
              </h4>
          
  <p>Trapped Fault Valid bit. Valid only when the value of FPEXC.DEX is 1. When valid, it indicates the cause of the exception and therefore whether the FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} bits are valid.</p>

          <table class="valuetable"><tr><th>TFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The exception was caused by the execution of a floating-point VABS, VADD, VDIV, VFMA, VFMS, VFNMA, VFNMS, VMLA, VMLS, VMOV, VMUL, VNEG, VNMLA, VNMLS, VNMUL, VSQRT, or VSUB instruction when one or both of <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} was non-zero. If the FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} bits are RW then they are invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} indicate the presence of trapped floating-point exceptions that had occurred at the time of the exception. Bits are set for all trapped exceptions that had occurred at the time of the exception.</p>
</td></tr></table>
            
  <p>This bit returns a status value and ignores writes.</p>
<p>When the value of FPEXC.DEX is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
<p>On an implementation that supports the trapping of floating-point exceptions and implements <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} as RAZ, this bit is RAO/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_25">
                Bits [25:11]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="VECITR_10">VECITR, bits [10:8]
                  </h4>
          
  <p>Vector iteration count. From Armv8, this field is <span class="arm-defined-word">RES1</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IDF_7">IDF, bit [7]
              </h4>
          
  <p>Input Denormal trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Input Denormal exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IDE was 1:</p>

          <table class="valuetable"><tr><th>IDF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Input Denormal exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Input Denormal exception has occurred.</p>
</td></tr></table>
            
  <p>Input Denormal exceptions can occur only when <a href="AArch32-fpscr.html">FPSCR</a>.FZ is 1.</p>
<div class="note"><span class="note-header">Note</span><p>A half-precision floating-point value that is flushed to zero because the value of <a href="AArch32-fpscr.html">FPSCR</a>.FZ16 is 1 does not generate an Input Denormal exception.</p></div><p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bits [6:5]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IXF_4">IXF, bit [4]
              </h4>
          
  <p>Inexact trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Inexact exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IXE was 1:</p>

          <table class="valuetable"><tr><th>IXF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Inexact exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Inexact exception has occurred.</p>
</td></tr></table>
            
  <p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UFF_3">UFF, bit [3]
              </h4>
          
  <p>Underflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Underflow exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.UFE was 1:</p>

          <table class="valuetable"><tr><th>UFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Underflow exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Underflow exception has occurred.</p>
</td></tr></table>
            
  <p>Underflow trapped exceptions can occur:</p>
<ul>
<li>On half-precision data-processing instructions only when <a href="AArch32-fpscr.html">FPSCR</a>.FZ16 is 0.
</li><li>Otherwise only when <a href="AArch32-fpscr.html">FPSCR</a>.FZ is 0.
</li></ul>
<p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="OFF_2">OFF, bit [2]
              </h4>
          
  <p>Overflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Overflow exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.OFE was 1:</p>

          <table class="valuetable"><tr><th>OFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Overflow exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Overflow exception has occurred.</p>
</td></tr></table>
            
  <p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DZF_1">DZF, bit [1]
              </h4>
          
  <p>Divide by Zero trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether a Divide by Zero exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.DZE was 1:</p>

          <table class="valuetable"><tr><th>DZF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Divide by Zero exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Divide by Zero exception has occurred.</p>
</td></tr></table>
            
  <p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IOF_0">IOF, bit [0]
              </h4>
          
  <p>Invalid Operation trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Invalid Operation exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IOE was 1:</p>

          <table class="valuetable"><tr><th>IOF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Invalid Operation exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Invalid Operation exception has occurred.</p>
</td></tr></table>
            
  <p>This bit must be cleared to 0 by the exception-handling routine.</p>
<p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the FPEXC</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">VMRS{&lt;c&gt;}{&lt;q&gt;} &lt;Rt&gt;, &lt;spec_reg&gt;</h4><table class="access_instructions"><tr><th>reg</th></tr><tr><td>0b1000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if ELUsingAArch32(EL1) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || CPACR.cp10 == '00') then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then
        AArch32.TakeHypTrapException(0x08);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TID3 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x08);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TID3 == '1' then
        AArch32.TakeHypTrapException(0x08);
    else
        return FPEXC;
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '0' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then
        AArch32.TakeHypTrapException(0x00);
    else
        return FPEXC;
elsif PSTATE.EL == EL3 then
    if CPACR.cp10 == '00' then
        UNDEFINED;
    else
        return FPEXC;
              </p><h4 class="assembler">VMSR{&lt;c&gt;}{&lt;q&gt;} &lt;spec_reg&gt;, &lt;Rt&gt;</h4><table class="access_instructions"><tr><th>reg</th></tr><tr><td>0b1000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if ELUsingAArch32(EL1) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || CPACR.cp10 == '00') then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then
        AArch32.TakeHypTrapException(0x08);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TID3 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x08);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TID3 == '1' then
        AArch32.TakeHypTrapException(0x08);
    else
        FPEXC = R[t];
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '0' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ((ELUsingAArch32(EL3) &amp;&amp; SCR.NS == '1' &amp;&amp; NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then
        AArch32.TakeHypTrapException(0x00);
    else
        FPEXC = R[t];
elsif PSTATE.EL == EL3 then
    if CPACR.cp10 == '00' then
        UNDEFINED;
    else
        FPEXC = R[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
