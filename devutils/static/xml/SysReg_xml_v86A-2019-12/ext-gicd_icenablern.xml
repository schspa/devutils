<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register is_register="True" is_internal="False" is_banked="False" is_optional="False" is_stub_entry="False">
      <reg_short_name>GICD_ICENABLER&lt;n&gt;</reg_short_name>
      <reg_long_name>Interrupt Clear-Enable Registers</reg_long_name>
          <reg_array>
              <reg_array_start>0</reg_array_start>
              <reg_array_end>31</reg_array_end>
         </reg_array>
      
  <reg_address
      external_access="False"
    mem_map_access="True"
      power_domain="Unknown"
  >
    <reg_component>GIC Distributor</reg_component>
    <reg_offset><hexnumber>0x0180</hexnumber> + 4n</reg_offset>
    <reg_instance>GICD_ICENABLER&lt;n&gt;</reg_instance>
    <reg_access>
        
        <reg_access_state>
            <reg_access_level>When GICD_CTLR.DS == 0b0</reg_access_level>
            <reg_access_type>RW</reg_access_type>
        </reg_access_state>
        
        <reg_access_state>
            <reg_access_level>When IsAccessSecure()</reg_access_level>
            <reg_access_type>RW</reg_access_type>
        </reg_access_state>
        
        <reg_access_state>
            <reg_access_level>When !IsAccessSecure()</reg_access_level>
            <reg_access_type>RW</reg_access_type>
        </reg_access_state>
    </reg_access>
</reg_address>

          <reg_reset_value></reg_reset_value>
      <reg_mappings>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Disables forwarding of the corresponding interrupt to the CPU interfaces.</para>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
            <reg_group>GIC Distributor registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para>These registers are available in all GIC configurations. If <register_link state="ext" id="ext-gicd_ctlr.xml">GICD_CTLR</register_link>.DS==0, these registers are Common.</para>

      </configuration_text>
      <configuration_text>
        <para>The number of implemented <register_link state="ext" id="ext-gicd_icenablern.xml">GICD_ICENABLER&lt;n&gt;</register_link> registers is (<register_link state="ext" id="ext-gicd_typer.xml">GICD_TYPER</register_link>.ITLinesNumber+1). Registers are numbered from 0.</para>

      </configuration_text>
      <configuration_text>
        <para>GICD_ICENABLER0 is Banked for each connected PE with <register_link state="ext" id="ext-gicr_typer.xml">GICR_TYPER</register_link>.Processor_Number &lt; 8.</para>

      </configuration_text>
      <configuration_text>
        <para>Accessing GICD_ICENABLER0 from a PE with <register_link state="ext" id="ext-gicr_typer.xml">GICR_TYPER</register_link>.Processor_Number &gt; 7 is <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>:</para>

      </configuration_text>
      <configuration_text>
        <list type="unordered">
<listitem><content>Register is RAZ/WI.</content>
</listitem><listitem><content>An <arm-defined-word>UNKNOWN</arm-defined-word> banked copy of the register is accessed.</content>
</listitem></list>
      </configuration_text>

      </reg_configuration>
      <reg_attributes>
          <attributes_text>
            <para>GICD_ICENABLER&lt;n&gt; is a 32-bit register.</para>
          </attributes_text>
      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="32">
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="Clear_enable_bit&lt;x&gt;_31_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>Clear_enable_bit&lt;x&gt;</field_name>
          <field_msb>31</field_msb>
          <field_lsb>0</field_lsb>
          <field_array>
            <field_array_start>31</field_array_start>
            <field_array_end>0</field_array_end>
            <field_array_description>x</field_array_description>
          </field_array>
          <field_description order="before">
          
  <para>For SPIs and PPIs, controls the forwarding of interrupt number 32n + x to the CPU interfaces. Reads and writes have the following behavior:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>If read, indicates that forwarding of the corresponding interrupt is disabled.</para>
<para>If written, has no effect.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>If read, indicates that forwarding of the corresponding interrupt is enabled.</para>
<para>If written, disables forwarding of the corresponding interrupt.</para>
<para>After a write of 1 to this bit, a subsequent read of this bit returns 0.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>For SGIs, the behavior of this bit is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
    <text_after_fields>
    
  <para>For INTID m, when DIV and MOD are the integer division and modulo operations:</para>
<list type="unordered">
<listitem><content>The corresponding GICD_ICENABLER&lt;n&gt; number, n, is given by n = m DIV 32.</content>
</listitem><listitem><content>The offset of the required GICD_ICENABLER is (<hexnumber>0x180</hexnumber> + (4*n)).</content>
</listitem><listitem><content>The bit number of the required group modifier bit in this register is m MOD 32.</content>
</listitem></list>
<note><para>Writing a 1 to a GICD_ICENABLER&lt;n&gt; bit only disables the forwarding of the corresponding interrupt from the Distributor to any CPU interface. It does not prevent the interrupt from changing state, for example becoming pending or active and pending if it is already active.</para></note>

    </text_after_fields>
  </fields>
  <reg_fieldset length="32">
      
        <fieldat id="Clear_enable_bit&lt;x&gt;_31_0" msb="31" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
        <reg_variables>
              <reg_variable variable="n" max="31"/>
        </reg_variables>
      


<access_mechanisms>
  
    
      <access_permission_text>
        <para>For SGIs and PPIs:</para>

      </access_permission_text>
      <access_permission_text>
        <list type="unordered">
<listitem><content>When ARE is 1 for the Security state of an interrupt, the field for that interrupt is <arm-defined-word>RES0</arm-defined-word> and an implementation is permitted to make the field RAZ/WI in this case.</content>
</listitem><listitem><content>Equivalent functionality is provided by GICR_ICENABLER0.</content>
</listitem></list>

      </access_permission_text>
      <access_permission_text>
        <para>Bits corresponding to unimplemented interrupts are RAZ/WI.</para>

      </access_permission_text>
      <access_permission_text>
        <para>When <register_link state="ext" id="ext-gicd_ctlr.xml">GICD_CTLR</register_link>.DS==0, bits corresponding to Group 0 and Secure Group 1 interrupts are RAZ/WI to Non-secure accesses.</para>

      </access_permission_text>
      <access_permission_text>
        <para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether implemented SGIs are permanently enabled, or can be enabled and disabled by writes to <register_link state="ext" id="ext-gicd_isenablern.xml">GICD_ISENABLER&lt;n&gt;</register_link> and <register_link state="ext" id="ext-gicd_icenablern.xml">GICD_ICENABLER&lt;n&gt;</register_link> where n=0.</para>

      </access_permission_text>
      <access_permission_text>
        <para>Completion of a write to this register does not guarantee that the effects of the write are visible throughout the affinity hierarchy. To ensure an enable has been cleared, software must write to the register with bits set to 1 to clear the required enables. Software must then poll <register_link state="ext" id="ext-gicd_ctlr.xml">GICD_CTLR</register_link>.RWP until it has the value zero.</para>
      </access_permission_text>


</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</timestamp>
</register_page>