<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register is_register="True" is_internal="False" is_banked="False" is_optional="False" is_stub_entry="False">
      <reg_short_name>ERR&lt;n&gt;STATUS</reg_short_name>
      <reg_long_name>Error Record Primary Status Register</reg_long_name>
        <reg_condition otherwise="RES0">when error record &lt;n&gt; is implemented</reg_condition>
          <reg_array>
              <reg_array_start>0</reg_array_start>
              <reg_array_end>65534</reg_array_end>
         </reg_array>
      
  <reg_address
      external_access="False"
    mem_map_access="True"
      power_domain="None"
  >
    <reg_component>RAS</reg_component>
    <reg_offset><hexnumber>0x010</hexnumber> + 64n</reg_offset>
    <reg_instance>ERR&lt;n&gt;STATUS</reg_instance>
    <reg_access>
        
        <reg_access_state>
            <reg_access_type>RW</reg_access_type>
        </reg_access_state>
    </reg_access>
</reg_address>

          <reg_reset_value>

      </reg_reset_value>
      <reg_mappings>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Contains status information for the error record, including:</para>

      </purpose_text>
      <purpose_text>
        <list type="unordered">
<listitem><content>Whether any error has been detected (valid).</content>
</listitem><listitem><content>Whether any detected error was not corrected, and returned to a master.</content>
</listitem><listitem><content>Whether any detected error was not corrected and deferred.</content>
</listitem><listitem><content>Whether an error record has been discarded because additional errors have been detected before the first error was handled by software (overflow).</content>
</listitem><listitem><content>Whether any error has been reported.</content>
</listitem><listitem><content>Whether the other error record registers contain valid information.</content>
</listitem><listitem><content>Whether the error was reported because poison data was detected or because a corrupt value was detected by an error detection code.</content>
</listitem><listitem><content>A primary error code.</content>
</listitem><listitem><content>An <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> extended error code.</content>
</listitem></list>

      </purpose_text>
      <purpose_text>
        <para>Within this register:</para>

      </purpose_text>
      <purpose_text>
        <list type="unordered">
<listitem><content>The {AV, V, MV} bits are valid bits that define whether the error record registers are valid.</content>
</listitem><listitem><content>The {UE, OF, CE, DE, UET} bits encode the types of error or errors recorded.</content>
</listitem><listitem><content>The {CI, ER, PN, IERR, SERR} fields are syndrome fields.</content>
</listitem></list>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
          <reg_group>RAS registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para><register_link id="ext-errnfr.xml" state="ext">ERR&lt;q&gt;FR</register_link> describes the features implemented by the node that owns error record &lt;n&gt;. &lt;q&gt; is the index of the first error record owned by the same node as error record &lt;n&gt;. If the node owns a single record, then q = n.</para>

      </configuration_text>
      <configuration_text>
        <para>For <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> fields in ERR&lt;n&gt;STATUS, writing zero must always be supported to return the error record to an initial quiescent state.</para>

      </configuration_text>
      <configuration_text>
        <para>In particular, if any <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> syndrome fields might generate a Fault Handling or Error Recovery Interrupt request, writing zero is sufficient to deactivate the Interrupt request.</para>

      </configuration_text>
      <configuration_text>
        <para>Fields that are read-only, non-zero, and ignore writes are compliant with this requirement.</para>

      </configuration_text>
      <configuration_text>
        <note><para>Arm recommends that any <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> syndrome fields that can generate a Fault Handling, Error Recovery, Critical, or <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>, interrupt request are disabled at Cold reset and are enabled by software writing an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> non-zero value to an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> field in ERR&lt;q&gt;CTRL.</para></note>
      </configuration_text>

      </reg_configuration>
      <reg_attributes>
          <attributes_text>
            <para>ERR&lt;n&gt;STATUS is a 64-bit register.</para>
          </attributes_text>
      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="64">
      <fields_condition>When RAS System Architecture v1.1 is implemented</fields_condition>
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_63_32"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>32</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="AV_31_31_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>AV</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
          
  <para>Address Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para><register_link state="ext" id="ext-errnaddr.xml">ERR&lt;n&gt;ADDR</register_link> not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para><register_link state="ext" id="ext-errnaddr.xml">ERR&lt;n&gt;ADDR</register_link> contains an address associated with the highest priority error recorded by this record.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
            <fields_condition>When the error record includes an address associated with an error</fields_condition>
      </field>
        <field
           id="0_31_31_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="V_30_30"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>V</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
          
  <para>Status Register Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;STATUS not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;STATUS valid. At least one error has been recorded.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="UE_29_29"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UE</field_name>
          <field_msb>29</field_msb>
          <field_lsb>29</field_lsb>
          <field_description order="before">
          
  <para>Uncorrected Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No errors have been detected, or all detected errors have been either corrected or deferred.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>At least one detected error was not corrected and not deferred.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="ER_28_28"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>ER</field_name>
          <field_msb>28</field_msb>
          <field_lsb>28</field_lsb>
          <field_description order="before">
          
  <para>Error Reported.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No in-band error (External Abort) reported.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An External Abort was signaled by the node to the master making the access or other transaction. This can be because any of the following are true:</para>
<list type="unordered">
<listitem><content>The applicable one of the <register_link id="ext-errnctlr.xml" state="ext">ERR&lt;q&gt;CTLR</register_link>.{WUE,RUE,UE} bits is implemented and was set to <binarynumber>0b1</binarynumber> when an Uncorrected error was detected.</content>
</listitem><listitem><content>The applicable one of the <register_link id="ext-errnctlr.xml" state="ext">ERR&lt;q&gt;CTLR</register_link>.{WUE,RUE,UE} bits is not implemented and the node always reports errors.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether this bit can be set to <binarynumber>0b1</binarynumber> by a Deferred error.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber> and this bit is never set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.{UE,DE} == {0,0} and this bit can be set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem></list>
<para>This bit is read/write-one-to-clear.</para>
<note><para>An External Abort signaled by the node might be masked and not generate any exception.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="OF_27_27"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>OF</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
          
  <para>Overflow.</para>
<para>Indicates that multiple errors have been detected. This bit is set to <binarynumber>0b1</binarynumber> when one of the following occurs:</para>
<list type="unordered">
<listitem><content>A Corrected error counter is implemented, an error is counted, and the counter overflows.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.V was previously set to <binarynumber>0b1</binarynumber>, a Corrected error counter is not implemented, and a Corrected error is recorded.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.V was previously set to <binarynumber>0b1</binarynumber>, and a type of error other than a Corrected error is recorded.</content>
</listitem></list>
<para>Otherwise, this bit is unchanged when an error is recorded.</para>
<para>If a Corrected error counter is implemented:</para>
<list type="unordered">
<listitem><content>A direct write that modifies the counter overflow flag indirectly might set this bit to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</content>
</listitem><listitem><content>A direct write to this bit that clears this bit to zero might indirectly set the counter overflow flag to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</content>
</listitem></list>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Since this bit was last cleared to zero, no error syndrome has been discarded and, if a Corrected error counter is implemented, it has not overflowed.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Since this bit was last cleared to zero, at least one error syndrome has been discarded or, if a Corrected error counter is implemented, it might have overflowed.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="MV_26_26_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>MV</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
          
  <para>Miscellaneous Registers Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;MISC&lt;m&gt; not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> contents of the ERR&lt;n&gt;MISC&lt;m&gt; registers contains additional information for an error recorded by this record.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is read/write-one-to-clear.</para>
<note><para>If the ERR&lt;n&gt;MISC&lt;m&gt; registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
            <fields_condition>When the error record includes an additional information for an error</fields_condition>
      </field>
        <field
           id="0_26_26_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="CE_25_24"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>CE</field_name>
          <field_msb>25</field_msb>
          <field_lsb>24</field_lsb>
          <field_description order="before">
          
  <para>Corrected Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>No errors were corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>At least one transient error was corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>At least one error was corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>At least one persistent error was corrected.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>The mechanism by which a node detects whether a correctable error is transient or persistent is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>. If no such mechanism is implemented, then the node sets this field to <binarynumber>0b10</binarynumber> when an error is corrected.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</para>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="DE_23_23"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>DE</field_name>
          <field_msb>23</field_msb>
          <field_lsb>23</field_lsb>
          <field_description order="before">
          
  <para>Deferred Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No errors were deferred.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>At least one error was not corrected and deferred.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>Support for deferring errors is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="PN_22_22"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>PN</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
          
  <para>Poison.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Uncorrected error or Deferred error recorded because a corrupt value was detected, for example, by an error detection code (EDC).</para>
<note><para>If a producer node detects a corrupt value and defers the error by producing a poison value, then this bit is set to <binarynumber>0b0</binarynumber> at the producer node.</para></note>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Uncorrected error or Deferred error recorded because a poison value was detected.</para>
<note><para>This might only be an indication of poison, because, in some EDC schemes, a poison value is encoded as an unlikely form of corrupt data, meaning it is possible to mistake a corrupt value as a poison value.</para></note>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether a node can distinguish a poison value from a corrupt value.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.{DE,UE} == {0,0}.</content>
</listitem></list>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="UET_21_20"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UET</field_name>
          <field_msb>21</field_msb>
          <field_lsb>20</field_lsb>
          <field_description order="before">
          
  <para>Uncorrected Error Type. Describes the state of the component after detecting or consuming an Uncorrected error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Uncorrected error, Uncontainable error (UC).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Uncorrected error, Unrecoverable error (UEU).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Uncorrected error, Latent or Restartable error (UEO).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>Uncorrected error, Signaled or Recoverable error (UER).</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</para>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>.</content>
</listitem></list>
<para>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</para>
<note><para>Software might use the information in the error record registers to determine what recovery is necessary.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="CI_19_19"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>CI</field_name>
          <field_msb>19</field_msb>
          <field_lsb>19</field_lsb>
          <field_description order="before">
          
  <para>Critical Error. Indicates whether a critical error condition has been recorded.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No critical error condition.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Critical error condition.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="0_18_16"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>18</field_msb>
          <field_lsb>16</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="IERR_15_8"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IERR</field_name>
          <field_msb>15</field_msb>
          <field_lsb>8</field_lsb>
          <field_description order="before">
          
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> error code. Used with any primary error code SERR value. Further <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> information can be placed in the MISC registers.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  <para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="SERR_7_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SERR</field_name>
          <field_msb>7</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>Architecturally-defined primary error code. The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0x00</field_value>
        <field_value_description>
  <para>No error.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x01</field_value>
        <field_value_description>
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> error.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x02</field_value>
        <field_value_description>
  <para>Data value from (non-associative) internal memory. For example, ECC from on-chip SRAM or buffer.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x03</field_value>
        <field_value_description>
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> pin. For example, <signal>nSEI</signal> pin.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x04</field_value>
        <field_value_description>
  <para>Assertion failure. For example, consistency failure.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x05</field_value>
        <field_value_description>
  <para>Error detected on internal data path. For example, parity on ALU result.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x06</field_value>
        <field_value_description>
  <para>Data value from associative memory. For example, ECC error on cache data.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x07</field_value>
        <field_value_description>
  <para>Address/control value from associative memory. For example, ECC error on cache tag.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x08</field_value>
        <field_value_description>
  <para>Data value from a TLB. For example, ECC error on TLB data.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x09</field_value>
        <field_value_description>
  <para>Address/control value from a TLB. For example, ECC error on TLB tag.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0A</field_value>
        <field_value_description>
  <para>Data value from producer. For example, parity error on write data bus.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0B</field_value>
        <field_value_description>
  <para>Address/control value from producer. For example, parity error on address bus.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0C</field_value>
        <field_value_description>
  <para>Data value from (non-associative) external memory. For example, ECC error in SDRAM.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0D</field_value>
        <field_value_description>
  <para>Illegal address (software fault). For example, access to unpopulated memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0E</field_value>
        <field_value_description>
  <para>Illegal access (software fault). For example, byte write to word register.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0F</field_value>
        <field_value_description>
  <para>Illegal state (software fault). For example, device not ready.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x10</field_value>
        <field_value_description>
  <para>Internal data register. For example, parity on a SIMD&amp;FP register. For a PE, all general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are data registers.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x11</field_value>
        <field_value_description>
  <para>Internal control register. For example, Parity on a System register. For a PE, all registers other than general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are control registers.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x12</field_value>
        <field_value_description>
  <para>Error response from slave. For example, error response from cache write-back.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x13</field_value>
        <field_value_description>
  <para>External timeout. For example, timeout on interaction with another node.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x14</field_value>
        <field_value_description>
  <para>Internal timeout. For example, timeout on interface within the node.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x15</field_value>
        <field_value_description>
  <para>Deferred error from slave not supported at master. For example, poisoned data received from a slave by a master that cannot defer the error further.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x16</field_value>
        <field_value_description>
  <para>Deferred error from master not supported at slave. For example, poisoned data received from a master by a slave that cannot defer the error further.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x17</field_value>
        <field_value_description>
  <para>Deferred error from slave passed through. For example, poisoned data received from a slave and returned to a master.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x18</field_value>
        <field_value_description>
  <para>Deferred error from master passed through. For example, poisoned data received from a master and deferred to a slave.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x19</field_value>
        <field_value_description>
  <para>Error recorded by PCIe error logs. Indicates that the node has recorded an error in a PCIe error log. This might be the PCIe device status register, AER, DVSEC, or other mechanisms defined by PCIe.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>All other values are reserved.</para>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <fields length="64">
      <fields_condition>When RAS System Architecture v1.0 is implemented</fields_condition>
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_63_32"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>32</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="AV_31_31_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>AV</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
          
  <para>Address Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para><register_link state="ext" id="ext-errnaddr.xml">ERR&lt;n&gt;ADDR</register_link> not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para><register_link state="ext" id="ext-errnaddr.xml">ERR&lt;n&gt;ADDR</register_link> contains an address associated with the highest priority error recorded by this record.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
            <fields_condition>When the error record includes an address associated with an error</fields_condition>
      </field>
        <field
           id="0_31_31_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="V_30_30"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>V</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
          
  <para>Status Register Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;STATUS not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;STATUS valid. At least one error has been recorded.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and is not being cleared to <binarynumber>0b0</binarynumber> in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="UE_29_29"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UE</field_name>
          <field_msb>29</field_msb>
          <field_lsb>29</field_lsb>
          <field_description order="before">
          
  <para>Uncorrected Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No errors have been detected, or all detected errors have been either corrected or deferred.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>At least one detected error was not corrected and not deferred.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>. This bit ignores writes if ERR&lt;n&gt;STATUS.OF == <binarynumber>0b1</binarynumber> and is not being cleared to <binarynumber>0b0</binarynumber> in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="ER_28_28"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>ER</field_name>
          <field_msb>28</field_msb>
          <field_lsb>28</field_lsb>
          <field_description order="before">
          
  <para>Error Reported.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No in-band error (External Abort) reported.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An External Abort was signaled by the node to the master making the access or other transaction. This can be because any of the following are true:</para>
<list type="unordered">
<listitem><content>The applicable one of the <register_link id="ext-errnctlr.xml" state="ext">ERR&lt;q&gt;CTLR</register_link>.{WUE,RUE,UE} bits is implemented and was set to <binarynumber>0b1</binarynumber> when an Uncorrected error was detected.</content>
</listitem><listitem><content>The applicable one of the <register_link id="ext-errnctlr.xml" state="ext">ERR&lt;q&gt;CTLR</register_link>.{WUE,RUE,UE} bits is not implemented and the node always reports errors.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether this bit can be set to <binarynumber>0b1</binarynumber> by a Deferred error.</para>
<para>If this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero, when any of:</para>
<list type="unordered">
<listitem><content>Clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>Clearing ERR&lt;n&gt;STATUS.UE to <binarynumber>0b0</binarynumber>, if this bit is never set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem><listitem><content>Clearing ERR&lt;n&gt;STATUS.{UE,DE} to {0,0}, if this bit can be set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem></list>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber> and this bit is never set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.{UE,DE} == {0,0} and this bit can be set to <binarynumber>0b1</binarynumber> by a Deferred error.</content>
</listitem></list>
<para>This bit ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>
<note><para>An External Abort signaled by the node might be masked and not generate any exception.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="OF_27_27"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>OF</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
          
  <para>Overflow.</para>
<para>Indicates that multiple errors have been detected. This bit is set to <binarynumber>0b1</binarynumber> when one of the following occurs:</para>
<list type="unordered">
<listitem><content>An Uncorrected error is detected and ERR&lt;n&gt;STATUS.UE == <binarynumber>0b1</binarynumber>.</content>
</listitem><listitem><content>A Deferred error is detected, ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber> and ERR&lt;n&gt;STATUS.DE == <binarynumber>0b1</binarynumber>.</content>
</listitem><listitem><content>A Corrected error is detected, no Corrected error counter is implemented, ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber>, and ERR&lt;n&gt;STATUS.CE != <binarynumber>0b00</binarynumber>. ERR&lt;n&gt;STATUS.CE might be updated for the new Corrected error.</content>
</listitem><listitem><content>A Corrected error counter is implemented, ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber>, and the counter overflows.</content>
</listitem></list>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether this bit is set to <binarynumber>0b1</binarynumber> when one of the following occurs:</para>
<list type="unordered">
<listitem><content>A Deferred error is detected and ERR&lt;n&gt;STATUS.UE == <binarynumber>0b1</binarynumber>.</content>
</listitem><listitem><content>A Corrected error is detected, no Corrected error counter is implemented, and either or both the ERR&lt;n&gt;STATUS.UE or ERR&lt;n&gt;STATUS.DE bits are set to <binarynumber>0b1</binarynumber>.</content>
</listitem><listitem><content>A Corrected error counter is implemented, either or both the ERR&lt;n&gt;STATUS.UE or ERR&lt;n&gt;STATUS.DE bits are set to <binarynumber>0b1</binarynumber>, and the counter overflows.</content>
</listitem></list>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether this bit is cleared to <binarynumber>0b0</binarynumber> when one of the following occurs:</para>
<list type="unordered">
<listitem><content>An Uncorrected error is detected and ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>A Deferred error is detected, ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber> and ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>A Corrected error is detected, ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber> and ERR&lt;n&gt;STATUS.CE == <binarynumber>0b00</binarynumber>.</content>
</listitem></list>
<para>The <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> clearing of this bit might also depend on the value of the other error status bits.</para>
<para>If a Corrected error counter is implemented:</para>
<list type="unordered">
<listitem><content>A direct write that modifies the counter overflow flag indirectly might set this bit to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</content>
</listitem><listitem><content>A direct write to this bit that clears this bit to <binarynumber>0b0</binarynumber> might indirectly set the counter overflow flag to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</content>
</listitem></list>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>If ERR&lt;n&gt;STATUS.UE == <binarynumber>0b1</binarynumber>, then no error syndrome for an Uncorrected error has been discarded.</para>
<para>If ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber> and ERR&lt;n&gt;STATUS.DE == <binarynumber>0b1</binarynumber>, then no error syndrome for a Deferred error has been discarded.</para>
<para>If ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber>, and a Corrected error counter is implemented, then the counter has not overflowed.</para>
<para>If ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.DE == <binarynumber>0b0</binarynumber>, ERR&lt;n&gt;STATUS.CE != <binarynumber>0b00</binarynumber>, and no Corrected error counter is implemented, then no error syndrome for a Corrected error has been discarded.</para>
<note><para>This bit might have been set to <binarynumber>0b1</binarynumber> when an error syndrome was discarded and later cleared to <binarynumber>0b0</binarynumber> when a higher priority syndrome was recorded.</para></note>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>At least one error syndrome has been discarded or, if a Corrected error counter is implemented, it might have overflowed.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="MV_26_26_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>MV</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
          
  <para>Miscellaneous Registers Valid.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>ERR&lt;n&gt;MISC&lt;m&gt; not valid.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> contents of the ERR&lt;n&gt;MISC&lt;m&gt; registers contains additional information for an error recorded by this record.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>
<note><para>If the ERR&lt;n&gt;MISC&lt;m&gt; registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_number>0</field_reset_number>
  
      </field_reset>
  
</field_resets>
            <fields_condition>When the error record includes an additional information for an error</fields_condition>
      </field>
        <field
           id="0_26_26_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="CE_25_24"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>CE</field_name>
          <field_msb>25</field_msb>
          <field_lsb>24</field_lsb>
          <field_description order="before">
          
  <para>Corrected Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>No errors were corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>At least one transient error was corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>At least one error was corrected.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>At least one persistent error was corrected.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>The mechanism by which a node detects whether a correctable error is transient or persistent is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>. If no such mechanism is implemented, then the node sets this field to <binarynumber>0b10</binarynumber> when an error is corrected.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</para>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>. This field ignores writes if ERR&lt;n&gt;STATUS.OF == <binarynumber>0b1</binarynumber> and is not being cleared to <binarynumber>0b0</binarynumber> in the same write.</para>
<para>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="DE_23_23"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>DE</field_name>
          <field_msb>23</field_msb>
          <field_lsb>23</field_lsb>
          <field_description order="before">
          
  <para>Deferred Error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>No errors were deferred.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>At least one error was not corrected and deferred.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>Support for deferring errors is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>
<para>When clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>, if this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero.</para>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>. This bit ignores writes if ERR&lt;n&gt;STATUS.OF == <binarynumber>0b1</binarynumber> and is not being cleared to <binarynumber>0b0</binarynumber> in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="PN_22_22"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>PN</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
          
  <para>Poison.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Uncorrected error or Deferred error recorded because a corrupt value was detected, for example, by an error detection code (EDC).</para>
<note><para>If a producer node detects a corrupt value and defers the error by producing a poison value, then this bit is set to <binarynumber>0b0</binarynumber> at the producer node.</para></note>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Uncorrected error or Deferred error recorded because a poison value was detected.</para>
<note><para>This might only be an indication of poison, because, in some EDC schemes, a poison value is encoded as an unlikely form of corrupt data, meaning it is possible to mistake a corrupt value as a poison value.</para></note>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether a node can distinguish a poison value from a corrupt value.</para>
<para>If this bit is nonzero, then software must write <binarynumber>0b1</binarynumber> to this bit to clear this bit to zero, when any of:</para>
<list type="unordered">
<listitem><content>Clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>Clearing both ERR&lt;n&gt;STATUS.{DE, UE} to <binarynumber>0b0</binarynumber>.</content>
</listitem></list>
<para>This bit is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.{DE,UE} == {0,0}.</content>
</listitem></list>
<para>This bit ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>
<para>This bit is read/write-one-to-clear.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="UET_21_20"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UET</field_name>
          <field_msb>21</field_msb>
          <field_lsb>20</field_lsb>
          <field_description order="before">
          
  <para>Uncorrected Error Type. Describes the state of the component after detecting or consuming an Uncorrected error.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Uncorrected error, Uncontainable error (UC).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Uncorrected error, Unrecoverable error (UEU).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Uncorrected error, Latent or Restartable error (UEO).</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b11</field_value>
        <field_value_description>
  <para>Uncorrected error, Signaled or Recoverable error (UER).</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If this field is nonzero, then software must write ones to this field to clear this field to zero, when any of:</para>
<list type="unordered">
<listitem><content>Clearing ERR&lt;n&gt;STATUS.V to <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>Clearing ERR&lt;n&gt;STATUS.UE to <binarynumber>0b0</binarynumber>.</content>
</listitem></list>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if any of the following are true:</para>
<list type="unordered">
<listitem><content>ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>.</content>
</listitem><listitem><content>ERR&lt;n&gt;STATUS.UE == <binarynumber>0b0</binarynumber>.</content>
</listitem></list>
<para>This field ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>
<para>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <arm-defined-word>UNKNOWN</arm-defined-word> value.</para>
<note><para>Software might use the information in the error record registers to determine what recovery is necessary.</para></note>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="0_19_16"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>19</field_msb>
          <field_lsb>16</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="IERR_15_8"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IERR</field_name>
          <field_msb>15</field_msb>
          <field_lsb>8</field_lsb>
          <field_description order="before">
          
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> error code. Used with any primary error code SERR value. Further <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> information can be placed in the MISC registers.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  <para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>. This field ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
        <field
           id="SERR_7_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SERR</field_name>
          <field_msb>7</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>Architecturally-defined primary error code. The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0x00</field_value>
        <field_value_description>
  <para>No error.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x01</field_value>
        <field_value_description>
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> error.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x02</field_value>
        <field_value_description>
  <para>Data value from (non-associative) internal memory. For example, ECC from on-chip SRAM or buffer.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x03</field_value>
        <field_value_description>
  <para><arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> pin. For example, <signal>nSEI</signal> pin.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x04</field_value>
        <field_value_description>
  <para>Assertion failure. For example, consistency failure.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x05</field_value>
        <field_value_description>
  <para>Error detected on internal data path. For example, parity on ALU result.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x06</field_value>
        <field_value_description>
  <para>Data value from associative memory. For example, ECC error on cache data.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x07</field_value>
        <field_value_description>
  <para>Address/control value from associative memory. For example, ECC error on cache tag.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x08</field_value>
        <field_value_description>
  <para>Data value from a TLB. For example, ECC error on TLB data.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x09</field_value>
        <field_value_description>
  <para>Address/control value from a TLB. For example, ECC error on TLB tag.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0A</field_value>
        <field_value_description>
  <para>Data value from producer. For example, parity error on write data bus.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0B</field_value>
        <field_value_description>
  <para>Address/control value from producer. For example, parity error on address bus.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0C</field_value>
        <field_value_description>
  <para>Data value from (non-associative) external memory. For example, ECC error in SDRAM.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0D</field_value>
        <field_value_description>
  <para>Illegal address (software fault). For example, access to unpopulated memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0E</field_value>
        <field_value_description>
  <para>Illegal access (software fault). For example, byte write to word register.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x0F</field_value>
        <field_value_description>
  <para>Illegal state (software fault). For example, device not ready.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x10</field_value>
        <field_value_description>
  <para>Internal data register. For example, parity on a SIMD&amp;FP register. For a PE, all general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are data registers.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x11</field_value>
        <field_value_description>
  <para>Internal control register. For example, Parity on a System register. For a PE, all registers other than general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are control registers.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x12</field_value>
        <field_value_description>
  <para>Error response from slave. For example, error response from cache write-back.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x13</field_value>
        <field_value_description>
  <para>External timeout. For example, timeout on interaction with another node.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x14</field_value>
        <field_value_description>
  <para>Internal timeout. For example, timeout on interface within the node.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x15</field_value>
        <field_value_description>
  <para>Deferred error from slave not supported at master. For example, poisoned data received from a slave by a master that cannot defer the error further.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x16</field_value>
        <field_value_description>
  <para>Deferred error from master not supported at slave. For example, poisoned data received from a master by a slave that cannot defer the error further.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x17</field_value>
        <field_value_description>
  <para>Deferred error from slave passed through. For example, poisoned data received from a slave and returned to a master.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x18</field_value>
        <field_value_description>
  <para>Deferred error from master passed through. For example, poisoned data received from a master and deferred to a slave.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0x19</field_value>
        <field_value_description>
  <para>Error recorded by PCIe error logs. Indicates that the node has recorded an error in a PCIe error log. This might be the PCIe device status register, AER, DVSEC, or other mechanisms defined by PCIe.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>All other values are reserved.</para>
<para>This field is not valid and reads <arm-defined-word>UNKNOWN</arm-defined-word> if ERR&lt;n&gt;STATUS.V == <binarynumber>0b0</binarynumber>. This field ignores writes if ERR&lt;n&gt;STATUS.{CE,DE,UE} != {<binarynumber>0b00</binarynumber>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</para>

          </field_description>
          <field_resets>
  
  
        
    
      <field_reset reset_type="Error recovery">
        
      <field_reset_standard_text>UC</field_reset_standard_text>
  
      </field_reset>
  
        
    
      <field_reset reset_type="Cold">
        
      <field_reset_standard_text>AU</field_reset_standard_text>
  
      </field_reset>
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <reg_fieldset length="64">
        <fields_condition>When RAS System Architecture v1.1 is implemented</fields_condition>
      
        <fieldat id="0_63_32" msb="63" lsb="32"/>
        <fieldat id="AV_31_31_1" msb="31" lsb="31"/>
        <fieldat id="V_30_30" msb="30" lsb="30"/>
        <fieldat id="UE_29_29" msb="29" lsb="29"/>
        <fieldat id="ER_28_28" msb="28" lsb="28"/>
        <fieldat id="OF_27_27" msb="27" lsb="27"/>
        <fieldat id="MV_26_26_1" msb="26" lsb="26"/>
        <fieldat id="CE_25_24" msb="25" lsb="24"/>
        <fieldat id="DE_23_23" msb="23" lsb="23"/>
        <fieldat id="PN_22_22" msb="22" lsb="22"/>
        <fieldat id="UET_21_20" msb="21" lsb="20"/>
        <fieldat id="CI_19_19" msb="19" lsb="19"/>
        <fieldat id="0_18_16" msb="18" lsb="16"/>
        <fieldat id="IERR_15_8" msb="15" lsb="8"/>
        <fieldat id="SERR_7_0" msb="7" lsb="0"/>
    </reg_fieldset>
  <reg_fieldset length="64">
        <fields_condition>When RAS System Architecture v1.0 is implemented</fields_condition>
      
        <fieldat id="0_63_32" msb="63" lsb="32"/>
        <fieldat id="AV_31_31_1" msb="31" lsb="31"/>
        <fieldat id="V_30_30" msb="30" lsb="30"/>
        <fieldat id="UE_29_29" msb="29" lsb="29"/>
        <fieldat id="ER_28_28" msb="28" lsb="28"/>
        <fieldat id="OF_27_27" msb="27" lsb="27"/>
        <fieldat id="MV_26_26_1" msb="26" lsb="26"/>
        <fieldat id="CE_25_24" msb="25" lsb="24"/>
        <fieldat id="DE_23_23" msb="23" lsb="23"/>
        <fieldat id="PN_22_22" msb="22" lsb="22"/>
        <fieldat id="UET_21_20" msb="21" lsb="20"/>
        <fieldat id="0_19_16" msb="19" lsb="16"/>
        <fieldat id="IERR_15_8" msb="15" lsb="8"/>
        <fieldat id="SERR_7_0" msb="7" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
        <reg_variables>
              <reg_variable variable="n" max="65534"/>
        </reg_variables>
      


<access_mechanisms>
  
    
      <access_permission_text>
        <para>The {AV, V, UE, ER, OF, MV, CE, DE, PN, UET, CI} fields are write-one-to-clear, meaning writes of zero are ignored, and a write of one or all-ones to the field clears the field to zero. The {IERR, SERR} fields are read/write fields, although the set of permitted values that can be written to the fields is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>

      </access_permission_text>
      <access_permission_text>
        <para>After reading ERR&lt;n&gt;STATUS, software must clear the valid bits in the register to allow new errors to be recorded. However, between reading the register and clearing the valid bits, a new error might have overwritten the register. To prevent this error being lost by software, the register prevents updates to fields that might have been updated by a new error.</para>

      </access_permission_text>
      <access_permission_text>
        <para>When RAS System Architecture v1.0 is implemented:</para>

      </access_permission_text>
      <access_permission_text>
        <list type="unordered">
<listitem><content>Writes to the {UE, DE, CE} fields are ignored if the OF bit is set and is not being cleared.</content>
</listitem><listitem><content>Writes to the V bit are ignored if any of the {UE, DE, CE} fields are nonzero and are not being cleared.</content>
</listitem><listitem><content>Writes to the {AV, MV} bits and {ER, PN, UET, IERR, SERR} syndrome fields are ignored if the highest priority error status field is nonzero and not being cleared. The error status fields in priority order from highest to lowest, are UE, DE, and CE.</content>
</listitem></list>

      </access_permission_text>
      <access_permission_text>
        <para>When RAS System Architecture v1.1 is implemented, a write to the register is ignored if all of:</para>

      </access_permission_text>
      <access_permission_text>
        <list type="unordered">
<listitem><content>Any of {V, UE, OF, CE, DE} fields are nonzero before the write.</content>
</listitem><listitem><content>The write does not clear the nonzero {V, UE, OF, CE, DE} fields to zero by writing ones to the applicable field or fields.</content>
</listitem></list>

      </access_permission_text>
      <access_permission_text>
        <para>To ensure correct and portable operation, when software is clearing the valid bits in the register to allow new errors to be recorded, software must:</para>

      </access_permission_text>
      <access_permission_text>
        <list type="unordered">
<listitem><content>Determine which fields must be cleared to zero by reading ERR&lt;n&gt;STATUS.</content>
</listitem><listitem><content>Write ones to all the write-one-to-clear fields that are nonzero.</content>
</listitem><listitem><content>Write zero to all the read/write fields.</content>
</listitem><listitem><content>Write zero to all the write-one-to-clear fields that are zero.</content>
</listitem></list>
      </access_permission_text>


</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</timestamp>
</register_page>