<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>PMBSR_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMBSR_EL1, Profiling Buffer Status/syndrome Register</h1><p>The PMBSR_EL1 characteristics are:</p><h2>Purpose</h2><p>Provides syndrome information to software when the buffer is disabled because the management interrupt has been raised.</p><h2>Configuration</h2><p>This register is present only
    when SPE is implemented.
      
    Otherwise, direct accesses to PMBSR_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>PMBSR_EL1 is a 64-bit register.</p><h2>Field descriptions</h2><p>The PMBSR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="6"><a href="#EC_31">EC</a></td><td class="lr" colspan="6"><a href="#0_25">RES0</a></td><td class="lr" colspan="1"><a href="#DL_19">DL</a></td><td class="lr" colspan="1"><a href="#EA_18">EA</a></td><td class="lr" colspan="1"><a href="#S_17">S</a></td><td class="lr" colspan="1"><a href="#COLL_16">COLL</a></td><td class="lr" colspan="16"><a href="#MSS_15">MSS</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EC_31">EC, bits [31:26]
                  </h4><p>Exception class</p><p>Top-level description of the cause of the buffer management event</p><table class="valuetable"><tr><th>EC</th><th>Meaning</th><th>MSS</th></tr><tr><td class="bitfield">0b000000</td><td><p>Other buffer management event. All buffer management events other than those described by other defined Exception class codes.</p></td><td><a href="
                #MSS_otherbuffermanagementevents">MSS encoding for other buffer management events</a></td></tr><tr><td class="bitfield">0b100100</td><td><p>Stage 1 Data Abort on write to Profiling Buffer.</p></td><td><a href="
                #MSS_stage1orstage2DataAbortsonwritetobuffer">MSS encoding for stage 1 or stage 2 Data Aborts on write to buffer</a></td></tr><tr><td class="bitfield">0b100101</td><td><p>Stage 2 Data Abort on write to Profiling Buffer.</p></td><td><a href="
                #MSS_stage1orstage2DataAbortsonwritetobuffer">MSS encoding for stage 1 or stage 2 Data Aborts on write to buffer</a></td></tr></table><p>All other values are reserved. Reserved values might be defined in a future version of the architecture.</p><p>Writing a reserved value to this field will make the value of this field <span class="arm-defined-word">UNKNOWN</span>. Values that are not supported act as reserved values when writing to this register.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_25">
                Bits [25:20]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="DL_19">DL, bit [19]
              </h4><p>Partial record lost.</p><p>Following a buffer management event other than an asynchronous External abort, indicates whether the last record written to the Profiling Buffer is complete.</p><table class="valuetable"><tr><th>DL</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>PMBPTR_EL1 points to the first byte after the last complete record written to the Profiling Buffer.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Part of a record was lost because of a buffer management event or synchronous External abort. PMBPTR_EL1 might not point to the first byte after the last complete record written to the buffer, and so restarting collection might result in a data record stream that software cannot parse. All records prior to the last record have been written to the buffer.</p></td></tr></table><p>When the buffer management event was because of an asynchronous external abort, this bit is set to 1 and software must not assume that any valid data has been written to the Profiling Buffer.</p><p>This bit is <span class="arm-defined-word">RES0</span> if the PE never sets this bit as a result of a buffer management event caused by an asynchronous External abort.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EA_18">EA, bit [18]
              </h4><p>External abort.</p><table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>An external abort has not been asserted.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An external abort has been asserted and detected by the Statistical Profiling Extension.</p></td></tr></table><p>This bit is <span class="arm-defined-word">RES0</span> if the PE never sets this bit as the result of an External abort.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="S_17">S, bit [17]
              </h4><p>Service</p><table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>PMBIRQ is not asserted.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>PMBIRQ is asserted. All profiling data has either been written to the buffer or discarded.</p></td></tr></table><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COLL_16">COLL, bit [16]
              </h4><p>Collision detected.</p><table class="valuetable"><tr><th>COLL</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No collision events detected.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one collision event was recorded.</p></td></tr></table><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="MSS_15">MSS, bits [15:0]
                  </h4><p>Management Event Specific Syndrome.</p><p>Contains syndrome specific to the management event.</p><p>The syndrome contents for each management event are described in the following sections.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="partial_fieldset"><h3 id="MSS_stage1orstage2DataAbortsonwritetobuffer">MSS encoding for stage 1 or stage 2 Data Aborts on write to buffer</h3><ul></ul><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="10"><a href="#0_15">RES0</a></td><td class="lr" colspan="6"><a href="#FSC_5">FSC</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_15">
                Bits [15:6]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FSC_5">FSC, bits [5:0]
                  </h4><p>Fault status code</p><table class="valuetable"><tr><th>FSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield"><ins>0b000000</ins><del>0b0000xx</del></td><td><p>Address <ins>size</ins><del>Size</del> <ins>fault,</ins><del>fault.</del> <ins>level</ins><del>Bits</del> <del>[1:</del>0<del>]</del> <ins>of</ins><del>encode</del> <ins>translation</ins><del>the</del> <ins>or translation table base register.</ins><del>level.</del></p></td></tr><tr><td class="bitfield"><ins>0b000001</ins><del>0b0001xx</del></td><td><p><ins>Address</ins><del>Translation</del> <ins>size</ins><del>fault.</del> <ins>fault,</ins><del>Bits</del> <ins>level</ins><del>[1:0]</del> <ins>1.</ins><del>encode the level.</del></p></td></tr><tr><td class="bitfield"><ins>0b000010</ins><del>0b0010xx</del></td><td><p><ins>Address</ins><del>Access</del> <ins>size</ins><del>Flag</del> <ins>fault,</ins><del>fault.</del> <ins>level</ins><del>Bits</del> <ins>2.</ins><del>[1:0] encode the level.</del></p></td></tr><tr><td class="bitfield"><ins>0b000011</ins><del>0b0011xx</del></td><td><p><ins>Address</ins><del>Permission</del> <ins>size</ins><del>fault.</del> <ins>fault,</ins><del>Bits</del> <ins>level</ins><del>[1:0]</del> <ins>3.</ins><del>encode the level.</del></p></td></tr><tr><td class="bitfield"><ins>0b000100</ins><del>0b010000</del></td><td><p><ins>Translation</ins><del>Synchronous</del> <ins>fault,</ins><del>External</del> <ins>level</ins><del>abort</del> <ins>0.</ins><del>on write.</del></p></td></tr><tr><td class="bitfield"><ins>0b000101</ins><del>0b0101xx</del></td><td><p><ins>Translation</ins><del>Synchronous</del> <ins>fault,</ins><del>External</del> <ins>level</ins><del>abort</del> <ins>1.</ins><del>on translation table walk or hardware update of translation table. Bits [1:0] encode the level.</del></p></td></tr><tr><td class="bitfield"><ins>0b000110</ins><del>0b010001</del></td><td><p><ins>Translation</ins><del>Asynchronous</del> <ins>fault,</ins><del>External</del> <ins>level</ins><del>abort</del> <ins>2.</ins><del>on write.</del></p></td></tr><tr><td class="bitfield"><ins>0b000111</ins></td><td><p><ins>Translation fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001001</ins></td><td><p><ins>Access flag fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001010</ins></td><td><p><ins>Access flag fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001011</ins></td><td><p><ins>Access flag fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001101</ins></td><td><p><ins>Permission fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001110</ins></td><td><p><ins>Permission fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001111</ins></td><td><p><ins>Permission fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010000</ins></td><td><p><ins>Synchronous External abort, not on translation table walk or hardware update of translation table.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010001</ins></td><td><p><ins>Asynchronous External abort.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010100</ins></td><td><p><ins>Synchronous External abort, on translation table walk or hardware update of translation table, level 0.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010101</ins></td><td><p><ins>Synchronous External abort, on translation table walk or hardware update of translation table, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010110</ins></td><td><p><ins>Synchronous External abort, on translation table walk or hardware update of translation table, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010111</ins></td><td><p><ins>Synchronous External abort, on translation table walk or hardware update of translation table, level 3.</ins></p></td></tr><tr><td class="bitfield">0b100001</td><td><p>Alignment fault.</p></td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB <ins>conflict</ins><del>Conflict</del> <ins>abort.</ins><del>fault.</del></p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When ARMv8.1-TTHM is implemented</td></tr></table><p><del>Writing a reserved value to this field will make the value of this field </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del>. Values that are not supported act as reserved values when writing to this register.</del></p><p>All other values are reserved.<del> Reserved values might be defined in a future version of the architecture.</del></p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether each of the Access Flag fault, asynchronous External abort and synchronous External abort, Alignment fault, and TLB Conflict abort values can be generated by the PE. For more information see <span class="xref">Faults and Watchpoints</span>.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div></div><div class="partial_fieldset"><h3 id="MSS_otherbuffermanagementevents">MSS encoding for other buffer management events</h3><ul></ul><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="10"><a href="#0_15">RES0</a></td><td class="lr" colspan="6"><a href="#BSC_5">BSC</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_15">
                Bits [15:6]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="BSC_5">BSC, bits [5:0]
                  </h4><p>Buffer status code</p><table class="valuetable"><tr><th>BSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000000</td><td><p>Buffer not filled</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Buffer filled</p></td></tr></table><p>All other values are reserved. Reserved values might be defined in a future version of the architecture.</p><p>Writing a reserved value to this field will make the value of this field <span class="arm-defined-word">UNKNOWN</span>. Values that are not supported act as reserved values when writing to this register.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div></div><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the PMBSR_EL1</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, PMBSR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1010</td><td>0b011</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMBSR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.E2PB == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '1x1' then
        return NVMem[0x820];
    else
        return PMBSR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return PMBSR_EL1;
elsif PSTATE.EL == EL3 then
    return PMBSR_EL1;
              </p><h4 class="assembler">MSR PMBSR_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1010</td><td>0b011</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMBSR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.E2PB == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '1x1' then
        NVMem[0x820] = X[t];
    else
        PMBSR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMBSR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    PMBSR_EL1 = X[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>