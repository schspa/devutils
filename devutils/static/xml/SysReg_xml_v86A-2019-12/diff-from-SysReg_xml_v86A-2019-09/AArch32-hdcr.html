<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>HDCR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">HDCR, Hyp Debug Control Register</h1><p>The HDCR characteristics are:</p><h2>Purpose</h2><p>Controls the trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to functions provided by the debug and trace architectures and the Performance Monitors Extension.</p><h2>Configuration</h2><p>AArch32 System register HDCR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-mdcr_el2.html">MDCR_EL2[31:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to HDCR are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3, and other than for a direct read of the register, the PE behaves as if HDCR.HPMN == <a href="AArch32-pmcr.html">PMCR</a>.N.</p><p><del class="nocount">This register is in the Warm reset domain.
                Some or all RW fields of this register have defined reset values.
                
        On a Warm or Cold reset these apply
      
                only if the PE resets into EL2
                
                  with EL2 using AArch32,
                
                or into
                
                    EL3 with EL3 using AArch32.
                  
                Otherwise,
                
                  on a Warm or Cold reset
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>HDCR is a 32-bit register.</p><h2>Field descriptions</h2><p>The HDCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#MTPME_28">MTPME</a></td><td class="lr" colspan="1"><a href="#TDCC_27">TDCC</a></td><td class="lr" colspan="1"><a href="#HLP_26">HLP</a></td><td class="lr" colspan="2"><a href="#0_25">RES0</a></td><td class="lr" colspan="1"><a href="#HCCD_23">HCCD</a></td><td class="lr" colspan="3"><a href="#0_22">RES0</a></td><td class="lr" colspan="1"><a href="#TTRF_19">TTRF</a></td><td class="lr" colspan="1"><a href="#0_18">RES0</a></td><td class="lr" colspan="1"><a href="#HPMD_17">HPMD</a></td><td class="lr" colspan="5"><a href="#0_16">RES0</a></td><td class="lr" colspan="1"><a href="#TDRA_11">TDRA</a></td><td class="lr" colspan="1"><a href="#TDOSA_10">TDOSA</a></td><td class="lr" colspan="1"><a href="#TDA_9">TDA</a></td><td class="lr" colspan="1"><a href="#TDE_8">TDE</a></td><td class="lr" colspan="1"><a href="#HPME_7">HPME</a></td><td class="lr" colspan="1"><a href="#TPM_6">TPM</a></td><td class="lr" colspan="1"><a href="#TPMCR_5">TPMCR</a></td><td class="lr" colspan="5"><a href="#HPMN_4">HPMN</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_31">
                Bits [31:29]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="MTPME_28">MTPME, bit [28]
              <div style="font-size:smaller;"><br/>When ARMv8.6-MTPMU is implemented and <del>!HaveEL(</del>EL3<ins> is not implemented:</ins><del>):</del>
                </div></h4><p>Multi-threaded PMU Enable. Enables use of the <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a>.MT bits.</p><table class="valuetable"><tr><th>MTPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>ARMv8.6-MTPMU is disabled. The Effective value of <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a>.MT is zero.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a>.MT bits not affected by this bit.</p></td></tr></table><p>If ARMv8.6-MTPMU is disabled for any other PE in the system that has the same level 1 Affinity as the PE, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the PE behaves as if this bit is 0.</p><p>On a Cold reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">1</span>.
</p><h4 id="0_28"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TDCC_27">TDCC, bit [27]
              <div style="font-size:smaller;"><br/>When ARMv8.6-FGT is implemented:
                </div></h4><p>Trap DCC. Traps use of the Debug Comms Channel at EL1 and EL0 to EL2.</p><table class="valuetable"><tr><th>TDCC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any register accesses to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, accesses to the DCC registers at EL1 and EL0 generate a Hyp Trap exception, unless the access also generates a higher priority exception.</p><p>Traps on the DCC data transfer registers are ignored when the PE is in Debug state.</p></td></tr></table><p>The DCC registers trapped by this control are:</p><ul><li><a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, and, when the PE is in Non-debug state, <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul><p>The traps are reported with EC syndrome value:</p><ul><li><p><span class="hexnumber">0x05</span> for trapped <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1110</span>.</p></li><li><p><span class="hexnumber">0x06</span> for trapped <span class="instruction">LDC</span> to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> and <span class="instruction">STC</span> from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.</p></li></ul><p>When the PE is in Debug state, HDCR.TDCC does not trap any accesses to:</p><ul><li><a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_27"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="HLP_26">HLP, bit [26]
              <div style="font-size:smaller;"><br/>When ARMv8.5-PMU is implemented:
                </div></h4><p>Hypervisor Long event counter enable. Determines when unsigned overflow is recorded by a counter overflow bit.</p><table class="valuetable"><tr><th>HLP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[31:0].</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Event counter overflow on increment that causes unsigned overflow of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[63:0].</p></td></tr></table><p>If the highest implemented Exception level is using AArch32, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is read/write or RAZ/WI.</p><p>If HDCR.HPMN is less than PMCR.N, this bit affects the operation of event counters in the range [HDCR.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)]. Otherwise this bit has no effect on the operation of the event counters.</p><div class="note"><span class="note-header">Note</span><p>The effect of HDCR.HPMN on the operation of this bit always applies if EL2 is implemented, at all Exception levels including EL2 and EL3, and regardless of whether EL2 is enabled in the current Security state.</p></div><p>For more information see the description of the HDCR.HPMN field.</p><div class="note"><span class="note-header">Note</span><p><a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[63:32] cannot be accessed directly in AArch32 state.</p></div><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_26"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_25">
                Bits [25:24]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="HCCD_23">HCCD, bit [23]
              <div style="font-size:smaller;"><br/>When ARMv8.5-PMU is implemented:
                </div></h4><p>Hypervisor Cycle Counter Disable. Prohibits <a href="AArch32-pmccntr.html">PMCCNTR</a> from counting at EL2.</p><table class="valuetable"><tr><th>HCCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Cycle counting by <a href="AArch32-pmccntr.html">PMCCNTR</a> is not affected by this bit.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Cycle counting by <a href="AArch32-pmccntr.html">PMCCNTR</a> is prohibited at EL2.</p></td></tr></table><p>This bit does not affect the CPU_CYCLES event or any other event that counts cycles.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_23"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_22">
                Bits [22:20]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TTRF_19">TTRF, bit [19]
              <div style="font-size:smaller;"><br/>When ARMv8.4-Trace is implemented:
                </div></h4><p>Traps use of the Trace Filter Control registers at EL1 to EL2.</p><table class="valuetable"><tr><th>TTRF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses to <a href="AArch32-trfcr.html">TRFCR</a> at EL1 are not affected by this control bit.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to <a href="AArch32-trfcr.html">TRFCR</a> at EL1 generate a Hyp Trap exception.</p></td></tr></table><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_19"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_18">
                Bit [18]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="HPMD_17">HPMD, bit [17]
              <div style="font-size:smaller;"><br/>When ARMv8.1-PMU is implemented:
                </div></h4><p>Guest Performance Monitors Disable. This control prohibits event counting at EL2.</p><table class="valuetable"><tr><th>HPMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event counting allowed in Hyp mode.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Event counting prohibited in Hyp mode.</p><p>If ARMv8.2-Debug is not implemented, event counting is prohibited unless enabled by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface ExternalSecureNoninvasiveDebugEnabled().</p></td></tr></table><p>This control applies only to:</p><ul><li>The event counters in the range [0..(HDCR.HPMN-1)].
</li><li>If <a href="AArch32-pmcr.html">PMCR</a>.DP is set to 1, <a href="AArch32-pmccntr.html">PMCCNTR</a>.
</li></ul><p>The other event counters are unaffected. When <a href="AArch32-pmcr.html">PMCR</a>.DP is set to 0, <a href="AArch32-pmccntr.html">PMCCNTR</a> is unaffected.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_17"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_16">
                Bits [16:12]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TDRA_11">TDRA, bit [11]
              </h4><p>Trap Debug ROM Address register access. Traps Non-secure EL0 and EL1 System register accesses to the Debug ROM registers to Hyp mode.</p><table class="valuetable"><tr><th>TDRA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL0 and EL1 System register accesses to the <a href="AArch32-dbgdrar.html">DBGDRAR</a> or <a href="AArch32-dbgdsar.html">DBGDSAR</a> are trapped to Hyp mode, unless it is trapped by <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>.UDCCdis.</p></td></tr></table><p>If <a href="AArch32-hcr.html">HCR</a>.TGE or HDCR.TDE is 1, behavior is as if this bit is 1 other than for the purpose of a direct read.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TDOSA_10">TDOSA, bit [10]
              <div style="font-size:smaller;"><br/>When ARMv8.0-DoubleLock is implemented:
                </div></h4><p>Trap debug OS-related register access. Traps Non-secure EL1 System register accesses to the powerdown debug registers to Hyp mode.</p><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 System register accesses to the powerdown debug registers are trapped to Hyp mode.</p></td></tr></table><p>The registers for which accesses are trapped are as follows:</p><ul><li><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgosdlr.html">DBGOSDLR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul><div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>If <a href="AArch32-hcr.html">HCR</a>.TGE or <a href="AArch32-hdcr.html">HDCR</a>.TDE is 1, behavior is as if this bit is 1 other than for the purpose of a direct read.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TDOSA_10"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Trap debug OS-related register access. Traps Non-secure EL1 System register accesses to the powerdown debug registers to Hyp mode.</p><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 System register accesses to the powerdown debug registers are trapped to Hyp mode.</p></td></tr></table><p>The registers for which accesses are trapped are as follows:</p><ul><li><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-dbgosdlr.html">DBGOSDLR</a> are trapped.</p><div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>If <a href="AArch32-hcr.html">HCR</a>.TGE or <a href="AArch32-hdcr.html">HDCR</a>.TDE is 1, behavior is as if this bit is 1 other than for the purpose of a direct read.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TDA_9">TDA, bit [9]
              </h4><p>Trap debug access. Traps Non-secure EL0 and EL1 System register accesses to those debug System registers in the (coproc==<span class="binarynumber">0b1110</span>) encoding space that are not trapped by either of the following:</p><ul><li><a href="AArch32-hdcr.html">HDCR</a>.TDRA.
</li><li><a href="AArch32-hdcr.html">HDCR</a>.TDOSA.
</li></ul><table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL0 or EL1 System register accesses to the debug registers, other than the registers trapped by HDCR.TDRA and HDCR.TDOSA, are trapped to Hyp mode, unless it is trapped by <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>.UDCCdis.</p></td></tr></table><p>Traps of AArch32 accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> are ignored in Debug state.</p><p>If <a href="AArch32-hcr.html">HCR</a>.TGE or HDCR.TDE is 1, behavior is as if this bit is 1 other than for the purpose of a direct read.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TDE_8">TDE, bit [8]
              </h4><p>Trap Debug exceptions. The possible values of this bit are:</p><table class="valuetable"><tr><th>TDE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control has no effect on the routing of debug exceptions, and has no effect on Non-secure accesses to debug registers.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Debug exceptions generated at EL1 or EL0 are routed to EL2 when enabled in the current Security state. The HDCR.{TDRA, TDOSA, TDA} fields are treated as being 1 for all purposes other than returning the result of a direct read of the register.</p></td></tr></table><p>When <a href="AArch32-hcr.html">HCR</a>.TGE == 1, the PE behaves as if the value of this field is 1 for all purposes other than returning the value of a direct read of the register.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="HPME_7">HPME, bit [7]
              <div style="font-size:smaller;"><br/>When PMUv3 is implemented:
                </div></h4><p>[HDCR.HPMN..(N-1)] event counters enable.</p><table class="valuetable"><tr><th>HPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event counters in the range [HDCR.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)] are disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Event counters in the range [HDCR.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)] are enabled by <a href="AArch32-pmcntenset.html">PMCNTENSET</a>.</p></td></tr></table><p>If HDCR.HPMN is less than <a href="AArch32-pmcr.html">PMCR</a>.N, the event counters in the range [HDCR.HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)], are enabled and disabled by this bit. Otherwise this bit has no effect on the operation of the event counters.</p><div class="note"><span class="note-header">Note</span><p>The effect of HDCR.HPMN on the operation of this bit applies regardless of whether EL2 is enabled in the current Security state.</p></div><p>For more information see the description of the HPMN field.</p><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_7"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TPM_6">TPM, bit [6]
              <div style="font-size:smaller;"><br/>When PMUv3 is implemented:
                </div></h4><p>Trap Performance Monitors accesses. Traps Non-secure EL0 and EL1 accesses to all Performance Monitors registers to Hyp mode.</p><table class="valuetable"><tr><th>TPM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL0 and EL1 accesses to all Performance Monitors registers are trapped to Hyp mode.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</p></div><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_6"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TPMCR_5">TPMCR, bit [5]
              <div style="font-size:smaller;"><br/>When PMUv3 is implemented:
                </div></h4><p>Trap <a href="AArch32-pmcr.html">PMCR</a> accesses. Traps Non-secure EL0 and EL1 accesses to the <a href="AArch32-pmcr.html">PMCR</a> to Hyp mode.</p><table class="valuetable"><tr><th>TPMCR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL0 and EL1 accesses to the <a href="AArch32-pmcr.html">PMCR</a> are trapped to Hyp mode, unless it is trapped by <a href="AArch32-pmuserenr.html">PMUSERENR</a>.EN.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</p></div><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_5"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="HPMN_4">HPMN, bits [4:0]
                  <div style="font-size:smaller;"><br/>When PMUv3 is implemented:
                </div></h4><p>Defines the number of event counters that are accessible from Non-secure EL1 modes, and from Non-secure EL0 modes if unprivileged access is enabled.</p><p>If HPMN is less than <a href="AArch32-pmcr.html">PMCR</a>.N, HPMN divides the event counters into two ranges, [0..(HPMN-1)] and [HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)].</p><p>For an event counter in the range [0..(HPMN-1)]:</p><ul><li>The counter is accessible from EL1 and EL2, and from EL0 if unprivileged access to the counters is enabled.
</li><li>If <span class="xref">ARMv8.5-PMU</span> is implemented, <a href="AArch32-pmcr.html">PMCR</a>.LP determines whether the counter overflows at <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[31:0] or <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[63:0].
</li><li><a href="AArch32-pmcr.html">PMCR</a>.E enables the operation of counters in this range.
</li></ul><div class="note"><span class="note-header">Note</span><p>If HPMN is equal to <a href="AArch32-pmcr.html">PMCR</a>.N, this applies to all event counters.</p></div><p>If HPMN is less than <a href="AArch32-pmcr.html">PMCR</a>.N, for an event counter in the range [HPMN..(<a href="AArch32-pmcr.html">PMCR</a>.N-1)]:</p><ul><li>The counter is accessible only from EL2 and from Secure state.
</li><li>If <span class="xref">ARMv8.5-PMU</span> is implemented, <a href="AArch32-hdcr.html">HDCR</a>.HLP determines whether the counter overflows at <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[31:0] or <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>[63:0].
</li><li>HDCR.HPME enables the operation of counters in this range.
</li></ul><p>If this field is set to 0, or to a value larger than <a href="AArch32-pmcr.html">PMCR</a>.N, then the following <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behaviors apply:</p><ul><li>The value returned by a direct read of HDCR.HPMN is <span class="arm-defined-word">UNKNOWN</span>.
</li><li>Either:<ul><li>An <span class="arm-defined-word">UNKNOWN</span> number of counters are reserved for EL2 use. That is, the PE behaves as if HDCR.HPMN is set to an <span class="arm-defined-word">UNKNOWN</span> non-zero value less than or equal to <a href="AArch32-pmcr.html">PMCR</a>.N.
</li><li>All counters are reserved for EL2 use, meaning no counters are accessible from Non-secure EL1 and Non-secure EL0.
</li></ul></li></ul><p>On a Warm reset, in a system where the PE resets into EL2 or EL3, this field resets to the value in <a href="AArch32-pmcr.html">PMCR</a>.N.</p><h4 id="0_4"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the HDCR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return HDCR;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        UNDEFINED;
    else
        return HDCR;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        HDCR = R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        UNDEFINED;
    else
        HDCR = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>