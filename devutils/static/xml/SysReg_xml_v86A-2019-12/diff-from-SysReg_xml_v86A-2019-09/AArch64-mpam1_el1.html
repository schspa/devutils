<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>MPAM1_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">MPAM1_EL1, MPAM1 Register (EL1)</h1><p>The MPAM1_EL1 characteristics are:</p><h2>Purpose</h2><p>Holds information to generate MPAM labels for memory requests when executing at EL1.</p><p>When EL2 is present and enabled, the MPAM virtualization option is present, <a href="AArch64-mpamhcr_el2.html">MPAMHCR_EL2</a>.GSTAPP_PLK == 1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 0, MPAM1_EL1 is used instead of <a href="AArch64-mpam0_el1.html">MPAM0_EL1</a> to generate MPAM labels for memory requests when executing at EL0.</p><p>MPAM1_EL1 is an alias for <a href="AArch64-mpam2_el2.html">MPAM2_EL2</a> when executing at EL2 with <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 1.</p><p>MPAM1_EL12 is an alias for MPAM1_EL1 when executing at EL2 or EL3 with <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 1.</p><p>If EL2 is is present and enabled, the MPAM virtualization option is present and <a href="AArch64-mpamhcr_el2.html">MPAMHCR_EL2</a>.EL1_VPMEN == 1, MPAM PARTIDs in MPAM1_EL1 are virtual and mapped into physical PARTIDs for the current Security state. This mapping of MPAM1_EL1 virtual PARTIDs to physical PARTIDs when EL1_VPMEN is 1 also applies when MPAM1_EL1 is used at EL0 due to <a href="AArch64-mpamhcr_el2.html">MPAMHCR_EL2</a>.GSTAPP_PLK.</p><h2>Configuration</h2><p>AArch64 System register MPAM1_EL1 bit [63]
            
                is architecturally mapped to
              AArch64 System register <a href="AArch64-mpam3_el3.html">MPAM3_EL3[63]
            </a> when <del>HaveEL(</del>EL3<ins> is implemented.</ins><del>).</del>
          </p><p>AArch64 System register MPAM1_EL1 bit [63]
            
                is architecturally mapped to
              AArch64 System register <a href="AArch64-mpam2_el2.html">MPAM2_EL2[63]
            </a> when <del>!HaveEL(</del>EL3<del>)</del> <ins>is not implemented </ins>and <del>HaveEL(</del>EL2<ins> is implemented.</ins><del>).</del>
          </p><p>This register is present only
    when MPAM is implemented.
      
    Otherwise, direct accesses to MPAM1_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>MPAM1_EL1 is a 64-bit register.</p><h2>Field descriptions</h2><p>The MPAM1_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#MPAMEN_63">MPAMEN</a></td><td class="lr" colspan="2"><a href="#0_62">RES0</a></td><td class="lr" colspan="1"><a href="#FORCED_NS_60">FORCED_NS</a></td><td class="lr" colspan="12"><a href="#0_59">RES0</a></td><td class="lr" colspan="8"><a href="#PMG_D_47">PMG_D</a></td><td class="lr" colspan="8"><a href="#PMG_I_39">PMG_I</a></td></tr><tr class="firstrow"><td class="lr" colspan="16"><a href="#PARTID_D_31">PARTID_D</a></td><td class="lr" colspan="16"><a href="#PARTID_I_15">PARTID_I</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="MPAMEN_63">MPAMEN, bit [63]
              </h4><p>MPAM Enable. MPAM is enabled when MPAMEN == 1. When disabled, all PARTIDs and PMGs are output as their default value in the corresponding ID space.</p><p><del>Values of this field are:</del></p><table class="valuetable"><tr><th>MPAMEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The default PARTID and default PMG are output in MPAM information.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>MPAM information is output based on the MPAMn_ELx register for ELn according the MPAM configuration.</p></td></tr></table><p>If neither EL3 nor EL2 is implemented, this field is read/write.</p><p>If EL3 is implemented, this field is read-only and reads the current value of the read/write bit <a href="AArch64-mpam3_el3.html">MPAM3_EL3</a>.MPAMEN.</p><p>If EL3 is not implemented and EL2 is implemented, this field is read-only and reads the current value of the read/write bit <a href="AArch64-mpam2_el2.html">MPAM2_EL2</a>.MPAMEN.</p><p>This field resets to <span class="binarynumber">0</span>.
</p><p>Accessing this field has the following behavior:</p><ul><li>When <del>!HaveEL(</del>EL3<del>)</del> <ins>is not implemented </ins>and <del>!HaveEL(</del>EL2<ins> is not implemented,</ins><del>),</del>
               access to this field is <span class="access_level">RW</span>.</li><li>Otherwise,  access to this field is <span class="access_level">RO</span>.</li></ul><h4 id="0_62">
                Bits [62:61]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FORCED_NS_60">FORCED_NS, bit [60]
              <div style="font-size:smaller;"><br/>When ARMv8.6-MPAM is implemented:
                </div></h4><p>In the Secure state, FORCED_NS <del>Secure state </del>indicates the state of <a href="AArch64-mpam3_el3.html">MPAM3_EL3</a>.FORCE_NS.</p><table class="valuetable"><tr><th>FORCED_NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>In the Non-secure state, always reads as 0.</p><p>In the Secure state, indicates that <a href="AArch64-mpam3_el3.html">MPAM3_EL3</a>.FORCE_NS == 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>In the Secure state, indicates</ins><del>Indicate</del> that <a href="AArch64-mpam3_el3.html">MPAM3_EL3</a>.FORCE_NS == 1.</p></td></tr></table><p><ins>Always reads</ins><del>Reads</del> as 0 in the Non-secure state.</p><p>Writes are ignored.</p><p><ins>Access to this field is </ins><span class="access_level"><ins>RO</ins></span><ins>.</ins></p><h4 id="0_60"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_59">
                Bits [59:48]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="PMG_D_47">PMG_D, bits [47:40]
                  </h4><p>Performance monitoring group property for PARTID_D.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="PMG_I_39">PMG_I, bits [39:32]
                  </h4><p>Performance monitoring group property for PARTID_I.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="PARTID_D_31">PARTID_D, bits [31:16]
                  </h4><p>Partition ID for data accesses, including load and store accesses, made from EL1.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="PARTID_I_15">PARTID_I, bits [15:0]
                  </h4><p>Partition ID for instruction accesses made from EL1.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the MPAM1_EL1</h2><p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, without explicit synchronization, accesses from EL3 using the mnemonic MPAM1_EL1 or MPAM1_EL12 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</p><p>None of the fields in this register are permitted to be cached in a TLB.</p><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, MPAM1_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1010</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MPAM2_EL2.TRAPMPAM1EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '111' then
        return NVMem[0x900];
    else
        return MPAM1_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        return MPAM2_EL2;
    else
        return MPAM1_EL1;
elsif PSTATE.EL == EL3 then
    return MPAM1_EL1;
              </p><h4 class="assembler">MSR MPAM1_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1010</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MPAM2_EL2.TRAPMPAM1EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '111' then
        NVMem[0x900] = X[t];
    else
        MPAM1_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        MPAM2_EL2 = X[t];
    else
        MPAM1_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    MPAM1_EL1 = X[t];
              </p><h4 class="assembler">MRS &lt;Xt>, MPAM1_EL12</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b1010</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '101' then
        return NVMem[0x900];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if <del>EL2Enabled() &amp;&amp; </del>HCR_EL2.E2H == '1' then
        if HaveEL(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            return MPAM1_EL1;
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled()<ins> &amp;&amp; !ELUsingAArch32(EL2)</ins> &amp;&amp; HCR_EL2.E2H == '1' then
        return MPAM1_EL1;
    else
        UNDEFINED;
              </p><h4 class="assembler">MSR MPAM1_EL12, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b1010</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '101' then
        NVMem[0x900] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if <del>EL2Enabled() &amp;&amp; </del>HCR_EL2.E2H == '1' then
        if HaveEL(EL3) &amp;&amp; MPAM3_EL3.TRAPLOWER == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            MPAM1_EL1 = X[t];
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled()<ins> &amp;&amp; !ELUsingAArch32(EL2)</ins> &amp;&amp; HCR_EL2.E2H == '1' then
        MPAM1_EL1 = X[t];
    else
        UNDEFINED;
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>