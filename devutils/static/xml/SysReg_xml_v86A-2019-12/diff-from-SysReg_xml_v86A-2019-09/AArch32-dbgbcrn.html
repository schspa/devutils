<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>DBGBCR&lt;n></title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DBGBCR&lt;n>, Debug Breakpoint Control Registers, n =
      0 - 15</h1><p>The DBGBCR&lt;n> characteristics are:</p><h2>Purpose</h2><p>Holds control information for a breakpoint. 
Forms breakpoint n together with value register <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>. 
If EL2 is implemented and this breakpoint supports Context matching, 
<a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a> can be associated with a Breakpoint Extended Value 
Register <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n></a> for VMID matching.</p><h2>Configuration</h2><p>AArch32 System register DBGBCR&lt;n> bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1[31:0]
            </a>.
          </p><p>AArch32 System register DBGBCR&lt;n> bits [31:0]
            
                are architecturally mapped to
              External register <a href="ext-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1[31:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to DBGBCR&lt;n> are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>If breakpoint n is not implemented then accesses to this register are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>DBGBCR&lt;n> is a 32-bit register.</p><h2>Field descriptions</h2><p>The DBGBCR&lt;n> bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#0_31">RES0</a></td><td class="lr" colspan="4"><a href="#BT_23">BT</a></td><td class="lr" colspan="4"><a href="#LBN_19">LBN</a></td><td class="lr" colspan="2"><a href="#SSC_15">SSC</a></td><td class="lr" colspan="1"><a href="#HMC_13">HMC</a></td><td class="lr" colspan="4"><a href="#0_12">RES0</a></td><td class="lr" colspan="4"><a href="#BAS_8">BAS</a></td><td class="lr" colspan="2"><a href="#0_4">RES0</a></td><td class="lr" colspan="2"><a href="#PMC_2">PMC</a></td><td class="lr" colspan="1"><a href="#E_0">E</a></td></tr></tbody></table><div class="text_before_fields"><p>When the E field is zero, all the other fields in the register are ignored.</p></div><h4 id="0_31">
                Bits [31:24]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="BT_23">BT, bits [23:20]
                  </h4><p>Breakpoint Type. Possible values are:</p><table class="valuetable"><tr><th>BT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0000</td><td><p>Unlinked instruction address match. <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a> is the address of an instruction.</p></td></tr><tr><td class="bitfield">0b0001</td><td><p>As <span class="binarynumber">0b0000</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b0010</td><td><p>Unlinked Context ID match. When ARMv8.1-VHE is implemented, EL2 is using AArch64, and the Effective value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, if either the PE is executing at EL0 with <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE set to 0 or the PE is executing at EL2, then <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>.ContextID must match the <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> value. Otherwise <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>.ContextID must match the <a href="AArch32-contextidr.html">CONTEXTIDR</a> value.</p></td></tr><tr><td class="bitfield">0b0011</td><td><p>As <span class="binarynumber">0b0010</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b0100</td><td><p>Unlinked instruction address mismatch. <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a> is the address of an instruction to be stepped.</p></td></tr><tr><td class="bitfield">0b0101</td><td><p>As <span class="binarynumber">0b0100</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b0110</td><td><p>Unlinked <a href="AArch64-contextidr_el1.html">CONTEXTIDR_EL1</a> match. <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>.ContextID is a Context ID compared against <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p></td></tr><tr><td class="bitfield">0b0111</td><td><p>As <span class="binarynumber">0b0110</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b1000</td><td><p>Unlinked VMID match. <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n></a>.VMID is a VMID compared against <a href="AArch32-vttbr.html">VTTBR</a>.VMID.</p></td></tr><tr><td class="bitfield">0b1001</td><td><p>As <span class="binarynumber">0b1000</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b1010</td><td><p>Unlinked VMID and Context ID match. <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>.ContextID is a Context ID compared against <a href="AArch32-contextidr.html">CONTEXTIDR</a>, and <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n></a>.VMID is a VMID compared against <a href="AArch32-vttbr.html">VTTBR</a>.VMID.</p></td></tr><tr><td class="bitfield">0b1011</td><td><p>As <span class="binarynumber">0b1010</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b1100</td><td><p>Unlinked <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> match. <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n></a>.ContextID2 is a Context ID compared against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p></td></tr><tr><td class="bitfield">0b1101</td><td><p>As <span class="binarynumber">0b1100</span> with linking enabled.</p></td></tr><tr><td class="bitfield">0b1110</td><td><p>Unlinked Full Context ID match. <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>.ContextID is compared against <a href="AArch32-contextidr.html">CONTEXTIDR</a>, and <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n></a>.ContextID2 is compared against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p></td></tr><tr><td class="bitfield">0b1111</td><td><p>As <span class="binarynumber">0b1110</span> with linking enabled.</p></td></tr></table><p>For more information on Breakpoints and their constraints, see <span class="xref">'Breakpoint exceptions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2.9</span> and <span class="xref">'Reserved DBGBCR&lt;n>.BT values' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="LBN_19">LBN, bits [19:16]
                  </h4><p>Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.</p><p>For all other breakpoint types this field is ignored and reads of the register return an <span class="arm-defined-word">UNKNOWN</span> value.</p><p>This field is ignored when the value of DBGBCR&lt;n>.E is 0.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="SSC_15">SSC, bits [15:14]
                  </h4><p>Security state control. Determines the Security states under which a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields.</p><p>For more information, see <span class="xref">'Execution conditions for which a breakpoint generates Breakpoint exceptions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>, and <span class="xref">'Reserved DBGBCR&lt;n>.{SSC, HMC, PMC} values' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="HMC_13">HMC, bit [13]
              </h4><p>Higher mode control. Determines the debug perspective for deciding when a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields. For more information see the SSC, bits [15:14] description.</p><p>For more information on the operation of the SSC, HMC, and PMC fields, see <span class="xref">'Execution conditions for which a breakpoint generates Breakpoint exceptions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="0_12">
                Bits [12:9]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="BAS_8">BAS, bits [8:5]
                  </h4><p>Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and Execution state.</p><p>The permitted values depend on the breakpoint type.</p><p>For Address match breakpoints, the permitted values are:</p><table class="valuetable"><thead><tr><th>BAS</th><th>Match instruction at</th><th>Constraint for debuggers</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0011</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a></td><td>Use for T32 instructions</td></tr><tr><td><span class="binarynumber">0b1100</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>+2</td><td>Use for T32 instructions</td></tr><tr><td><span class="binarynumber">0b1111</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a></td><td>Use for A32 instructions</td></tr></tbody></table><p>All other values are reserved. For more information, see <span class="xref">'Reserved DBGBCR&lt;n>.BAS values' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>For more information on using the BAS field in Address Match breakpoints, see <span class="xref">'Using the BAS field in Address Match breakpoints' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>For Address mismatch breakpoints in an AArch32 stage 1 translation regime, the permitted values are:</p><table class="valuetable"><thead><tr><th>BAS</th><th>Step instruction at</th><th>Constraint for debuggers</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0000</span></td><td>-</td><td>Use for a match anywhere breakpoint</td></tr><tr><td><span class="binarynumber">0b0011</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a></td><td>Use for T32 instructions</td></tr><tr><td><span class="binarynumber">0b1100</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>+2</td><td>Use for T32 instructions</td></tr><tr><td><span class="binarynumber">0b1111</span></td><td><a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a></td><td>Use for A32 instructions</td></tr></tbody></table><p>All other values are reserved. For more information, see <span class="xref">'Reserved DBGBCR&lt;n>.BAS values' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>For more information on using the BAS field in address mismatch breakpoints, see <span class="xref">'Using the BAS field in Address Match breakpoints' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>For Context matching breakpoints, this field is <span class="arm-defined-word">RES1</span> and ignored.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="0_4">
                Bits [4:3]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="PMC_2">PMC, bits [2:1]
                  </h4><p>Privilege mode control. Determines the Exception level or levels at which a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields. For more information see the DBGBCR&lt;n>.SSC description.</p><p>For more information on the operation of the SSC, HMC, and PMC fields, see <span class="xref">'Execution conditions for which a breakpoint generates Breakpoint exceptions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G2 (AArch32 Self-hosted Debug)</span>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="E_0">E, bit [0]
              </h4><p>Enable breakpoint <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>. Possible values are:</p><table class="valuetable"><tr><th>E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Breakpoint disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Breakpoint enabled.</p></td></tr></table><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the DBGBCR&lt;n></h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBCR[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBCR[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBCR[UInt(CRm&lt;3:0>)];
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBCR[UInt(CRm&lt;3:0>)] = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBCR[UInt(CRm&lt;3:0>)] = R[t];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBCR[UInt(CRm&lt;3:0>)] = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>