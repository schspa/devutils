<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>HCR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">HCR, Hyp Configuration Register</h1><p>The HCR characteristics are:</p><h2>Purpose</h2><p>Provides configuration controls for virtualization, including defining whether various Non-secure operations are trapped to Hyp mode.</p><h2>Configuration</h2><p>AArch32 System register HCR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-hcr_el2.html">HCR_EL2[31:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to HCR are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into EL2
                
                  with EL2 using AArch32,
                
                or into
                
                    EL3 with EL3 using AArch32.
                  
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>HCR is a 32-bit register.</p><h2>Field descriptions</h2><p>The HCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#TRVM_30">TRVM</a></td><td class="lr" colspan="1"><a href="#HCD_29">HCD</a></td><td class="lr" colspan="1"><a href="#0_28">RES0</a></td><td class="lr" colspan="1"><a href="#TGE_27">TGE</a></td><td class="lr" colspan="1"><a href="#TVM_26">TVM</a></td><td class="lr" colspan="1"><a href="#TTLB_25">TTLB</a></td><td class="lr" colspan="1"><a href="#TPU_24">TPU</a></td><td class="lr" colspan="1"><a href="#TPC_23">TPC</a></td><td class="lr" colspan="1"><a href="#TSW_22">TSW</a></td><td class="lr" colspan="1"><a href="#TAC_21">TAC</a></td><td class="lr" colspan="1"><a href="#TIDCP_20">TIDCP</a></td><td class="lr" colspan="1"><a href="#TSC_19">TSC</a></td><td class="lr" colspan="1"><a href="#TID3_18">TID3</a></td><td class="lr" colspan="1"><a href="#TID2_17">TID2</a></td><td class="lr" colspan="1"><a href="#TID1_16">TID1</a></td><td class="lr" colspan="1"><a href="#TID0_15">TID0</a></td><td class="lr" colspan="1"><a href="#TWE_14">TWE</a></td><td class="lr" colspan="1"><a href="#TWI_13">TWI</a></td><td class="lr" colspan="1"><a href="#DC_12">DC</a></td><td class="lr" colspan="2"><a href="#BSU_11">BSU</a></td><td class="lr" colspan="1"><a href="#FB_9">FB</a></td><td class="lr" colspan="1"><a href="#VA_8">VA</a></td><td class="lr" colspan="1"><a href="#VI_7">VI</a></td><td class="lr" colspan="1"><a href="#VF_6">VF</a></td><td class="lr" colspan="1"><a href="#AMO_5">AMO</a></td><td class="lr" colspan="1"><a href="#IMO_4">IMO</a></td><td class="lr" colspan="1"><a href="#FMO_3">FMO</a></td><td class="lr" colspan="1"><a href="#PTW_2">PTW</a></td><td class="lr" colspan="1"><a href="#SWIO_1">SWIO</a></td><td class="lr" colspan="1"><a href="#VM_0">VM</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_31">
                Bit [31]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TRVM_30">TRVM, bit [30]
              </h4><p>Trap Reads of Virtual Memory controls. Traps Non-secure EL1 reads of the virtual memory control registers to EL2, when EL2 is enabled in the current Security state.</p><p>The registers for which read accesses are trapped are as follows:</p><p><a href="AArch32-sctlr.html">SCTLR</a>, <a href="AArch32-ttbr0.html">TTBR0</a>, <a href="AArch32-ttbr1.html">TTBR1</a>, <a href="AArch32-ttbcr.html">TTBCR</a>, <a href="AArch32-ttbcr2.html">TTBCR2</a>, <a href="AArch32-dacr.html">DACR</a>, <a href="AArch32-dfsr.html">DFSR</a>, <a href="AArch32-ifsr.html">IFSR</a>, <a href="AArch32-dfar.html">DFAR</a>, <a href="AArch32-ifar.html">IFAR</a>, <a href="AArch32-adfsr.html">ADFSR</a>, <a href="AArch32-aifsr.html">AIFSR</a>, <a href="AArch32-prrr.html">PRRR</a>, <a href="AArch32-nmrr.html">NMRR</a>, <a href="AArch32-mair0.html">MAIR0</a>, <a href="AArch32-mair1.html">MAIR1</a>, <a href="AArch32-amair0.html">AMAIR0</a>, <a href="AArch32-amair1.html">AMAIR1</a>, <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p><table class="valuetable"><tr><th>TRVM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 read accesses to the specified Virtual Memory controls are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="HCD_29">HCD, bit [29]
              <div style="font-size:smaller;"><br/><ins>When EL3 is not implemented:
                </ins></div></h4><p>HVC instruction disable. Disables Non-secure EL1 and EL2 execution of HVC instructions, when EL2 is enabled in the current Security state.</p><table class="valuetable"><tr><th>HCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>HVC instruction execution is enabled at EL2 and EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>HVC instructions are <span class="arm-defined-word">UNDEFINED</span> at EL2 and Non-secure EL1.</p><p>The Undefined Instruction exception is taken to the Exception level at which the HVC instruction is executed.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p></div><p><del>This bit is only implemented if EL3 is not implemented. Otherwise, it is </del><span class="arm-defined-word"><del>RES0</del></span><del>.</del></p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_29"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><h4 id="0_28">
                Bit [28]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TGE_27">TGE, bit [27]
              </h4><p>Trap General Exceptions, from Non-secure EL0.</p><table class="valuetable"><tr><th>TGE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control has no effect on execution at EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When EL2 is not enabled in the current Security state, this control has no effect on execution at EL0.</p><p>When EL2 is enabled in the current Security state, then:</p><ul><li>All exceptions that would be routed to EL1 are routed to EL2.
</li><li>The <a href="AArch32-sctlr.html">SCTLR</a>.M bit is treated as being 0 for all purposes other than returning the result of a direct read of <a href="AArch32-sctlr.html">SCTLR</a>.
</li><li>The HCR.{FMO, IMO, AMO} bits are treated as being 1 for all purposes other than returning the result of a direct read of HCR.
</li><li>All virtual interrupts are disabled.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> mechanisms for signaling virtual interrupts are disabled.
</li><li>An exception return to EL1 is treated as an illegal exception return.
</li><li>Monitor mode execution of an MSR or CPS instruction that changes <a href="AArch32-cpsr.html">CPSR</a>.M to a Non-secure EL1 mode is an illegal change to PSTATE.M. For more information see <span class="xref">'Illegal changes to PSTATE.M' in the ArmÂ® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section G1 (The AArch32 System Level Programmers' Model)</span>.
</li></ul></td></tr></table><p>Also, when HCR.TGE is 1:</p><ul><li>If EL3 is using AArch32, an attempt to change from a Secure PL1 mode to a Non-secure EL1 mode by changing <a href="AArch32-scr.html">SCR</a>.NS from 0 to 1 results in <a href="AArch32-scr.html">SCR</a>.NS remaining as 0.
</li><li>The <a href="AArch32-hdcr.html">HDCR</a>.{TDRA, TDOSA, TDA, TDE} bits are ignored and treated as being 1 other than for the purpose of a direct read of <a href="AArch32-hdcr.html">HDCR</a>.
</li></ul><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TVM_26">TVM, bit [26]
              </h4><p>Trap Virtual Memory controls. Traps Non-secure EL1 writes to the virtual memory control registers to EL2, when EL2 is enabled in the current Security state.</p><p>The registers for which write accesses are trapped are as follows:</p><p><a href="AArch32-sctlr.html">SCTLR</a>, <a href="AArch32-ttbr0.html">TTBR0</a>, <a href="AArch32-ttbr1.html">TTBR1</a>, <a href="AArch32-ttbcr.html">TTBCR</a>, <a href="AArch32-ttbcr2.html">TTBCR2</a>, <a href="AArch32-dacr.html">DACR</a>, <a href="AArch32-dfsr.html">DFSR</a>, <a href="AArch32-ifsr.html">IFSR</a>, <a href="AArch32-dfar.html">DFAR</a>, <a href="AArch32-ifar.html">IFAR</a>, <a href="AArch32-adfsr.html">ADFSR</a>, <a href="AArch32-aifsr.html">AIFSR</a>, <a href="AArch32-prrr.html">PRRR</a>, <a href="AArch32-nmrr.html">NMRR</a>, <a href="AArch32-mair0.html">MAIR0</a>, <a href="AArch32-mair1.html">MAIR1</a>, <a href="AArch32-amair0.html">AMAIR0</a>, <a href="AArch32-amair1.html">AMAIR1</a>, <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p><table class="valuetable"><tr><th>TVM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 write accesses to the specified virtual memory control registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TTLB_25">TTLB, bit [25]
              </h4><p>Trap TLB maintenance instructions. Traps Non-secure EL1 execution of a TLBI instruction to EL2, when EL2 is enabled in the current Security state.</p><p>This applies to the following instructions:</p><p><a href="AArch32-tlbiallis.html">TLBIALLIS</a>, <a href="AArch32-tlbimvais.html">TLBIMVAIS</a>, <a href="AArch32-tlbiasidis.html">TLBIASIDIS</a>, <a href="AArch32-tlbimvaais.html">TLBIMVAAIS</a>, <a href="AArch32-tlbimvalis.html">TLBIMVALIS</a>, <a href="AArch32-tlbimvaalis.html">TLBIMVAALIS</a>, <a href="AArch32-itlbiall.html">ITLBIALL</a>, <a href="AArch32-itlbimva.html">ITLBIMVA</a>, <a href="AArch32-itlbiasid.html">ITLBIASID</a>, <a href="AArch32-dtlbiall.html">DTLBIALL</a>, <a href="AArch32-dtlbimva.html">DTLBIMVA</a>, <a href="AArch32-dtlbiasid.html">DTLBIASID</a>, <a href="AArch32-tlbiall.html">TLBIALL</a>, <a href="AArch32-tlbimva.html">TLBIMVA</a>, <a href="AArch32-tlbiasid.html">TLBIASID</a>, <a href="AArch32-tlbimvaa.html">TLBIMVAA</a>, <a href="AArch32-tlbimval.html">TLBIMVAL</a>, <a href="AArch32-tlbimvaal.html">TLBIMVAAL</a></p><table class="valuetable"><tr><th>TTLB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 accesses to the specified TLB maintenance instructions are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TPU_24">TPU, bit [24]
              </h4><p>Trap cache maintenance instructions that operate to the Point of Unification. Traps Non-secure EL1 execution of those cache maintenance instructions to EL2, when EL2 is enabled in the current Security state.</p><p>This applies to the following instructions:</p><ul><li><a href="AArch32-icimvau.html">ICIMVAU</a>, <a href="AArch32-iciallu.html">ICIALLU</a>, <a href="AArch32-icialluis.html">ICIALLUIS</a>, <a href="AArch32-dccmvau.html">DCCMVAU</a>.
</li></ul><div class="note"><span class="note-header">Note</span><p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p></div><table class="valuetable"><tr><th>TPU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 execution of the specified cache maintenance instructions is trapped to EL2.</p></td></tr></table><p>If the Point of Unification is before any level of data cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any data or unified cache clean by VA to the Point of Unification instruction can be trapped when the value of this control is 1.</p><p>If the Point of Unification is before any level of instruction cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any instruction cache invalidate to the Point of Unification instruction can be trapped when the value of this control is 1.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TPC_23">TPC, bit [23]
              </h4><p>Trap data or unified cache maintenance instructions that operate to the Point of Coherency. Traps Non-secure EL1 execution of those cache maintenance instructions to EL2, when EL2 is enabled in the current Security state.</p><p>This applies to the following instructions:</p><ul><li><a href="AArch32-dcimvac.html">DCIMVAC</a>, <a href="AArch32-dccimvac.html">DCCIMVAC</a>, <a href="AArch32-dccmvac.html">DCCMVAC</a>.
</li></ul><div class="note"><span class="note-header">Note</span><p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p></div><table class="valuetable"><tr><th>TPC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 execution of the specified cache maintenance instructions is trapped to EL2.</p></td></tr></table><p>If the Point of Coherency is before any level of data cache, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the execution of any data or unified cache clean, invalidate, or clean and invalidate instruction that operates by VA to the point of coherency can be trapped when the value of this control is 1.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TSW_22">TSW, bit [22]
              </h4><p>Trap data or unified cache maintenance instructions that operate by Set/Way. Traps Non-secure EL1 execution of those cache maintenance instructions by set/way to EL2, when EL2 is enabled in the current Security state.</p><p>This applies to the following instructions:</p><ul><li><a href="AArch32-dcisw.html">DCISW</a>, <a href="AArch32-dccsw.html">DCCSW</a>, <a href="AArch32-dccisw.html">DCCISW</a>.
</li></ul><div class="note"><span class="note-header">Note</span><p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p></div><table class="valuetable"><tr><th>TSW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 execution of the specified cache maintenance instructions is trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TAC_21">TAC, bit [21]
              </h4><p>Trap Auxiliary Control Registers. Traps Non-secure EL1 accesses to the Auxiliary Control Registers to EL2, when EL2 is enabled in the current Security state, from both Execution states.</p><p>This applies to the following register accesses:</p><p><a href="AArch32-actlr.html">ACTLR</a> and, if implemented, <a href="AArch32-actlr2.html">ACTLR2</a>.</p><table class="valuetable"><tr><th>TAC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 accesses to the specified registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TIDCP_20">TIDCP, bit [20]
              </h4><p>Trap <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality. Traps Non-secure EL1 accesses to the encodings for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> System Registers to EL2, when EL2 is enabled in the current Security state.</p><p>MCR and MRC instructions accessing the following encodings:</p><ul><li>All coproc==p15, CRn==c9, Opcode1 = {0-7}, CRm == {c0-c2, c5-c8}, opcode2 == {0-7}.
</li><li>All coproc==p15, CRn==c10, Opcode1 =={0-7}, CRm == {c0, c1, c4, c8}, opcode2 == {0-7}.
</li><li>All coproc==p15, CRn==c11, Opcode1=={0-7}, CRm == {c0-c8, c15}, opcode2 == {0-7}.
</li></ul><p>When HCR.TIDCP is set to 1, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether any of this functionality accessed from Non-secure EL0 is trapped to EL2. Otherwise, it is <span class="arm-defined-word">UNDEFINED</span> and the PE takes an Undefined Instruction exception to Non-secure Undefined mode.</p><table class="valuetable"><tr><th>TIDCP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1 accesses to the specified System register encodings for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TSC_19">TSC, bit [19]
              </h4><p>Trap SMC instructions. Traps Non-secure EL1 execution of SMC instructions to Hyp mode.</p><table class="valuetable"><tr><th>TSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute an SMC instruction at Non-secure EL1 is trapped to Hyp mode, regardless of the value of <a href="AArch32-scr.html">SCR</a>.SCD.</p></td></tr></table><p>The Armv8-A architecture permits, but does not require, this trap to apply to conditional SMC instructions that fail their condition code check, in the same way as with traps on other conditional instructions.</p><div class="note"><span class="note-header">Note</span><ul><li>This trap is only implemented if the implementation includes EL3.</li><li>SMC instructions are always <span class="arm-defined-word">UNDEFINED</span> at PL0.</li><li>This bit traps execution of the SMC instruction. It is not a routing control for the SMC exception. Hyp Trap exceptions and SMC exceptions have different preferred return addresses.</li></ul></div><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TID3_18">TID3, bit [18]
              </h4><p>Trap ID group 3. Traps Non-secure EL1 reads of the following registers to EL2, when EL2 is enabled in the current Security state, as follows:</p><ul><li><a href="AArch32-id_pfr0.html">ID_PFR0</a>, <a href="AArch32-id_pfr1.html">ID_PFR1</a>, <a href="AArch32-id_dfr0.html">ID_DFR0</a>, <a href="AArch32-id_afr0.html">ID_AFR0</a>, <a href="AArch32-id_mmfr0.html">ID_MMFR0</a>, <a href="AArch32-id_mmfr1.html">ID_MMFR1</a>, <a href="AArch32-id_mmfr2.html">ID_MMFR2</a>, <a href="AArch32-id_mmfr3.html">ID_MMFR3</a>, <a href="AArch32-id_isar0.html">ID_ISAR0</a>, <a href="AArch32-id_isar1.html">ID_ISAR1</a>, <a href="AArch32-id_isar2.html">ID_ISAR2</a>, <a href="AArch32-id_isar3.html">ID_ISAR3</a>, <a href="AArch32-id_isar4.html">ID_ISAR4</a>, <a href="AArch32-id_isar5.html">ID_ISAR5</a>, <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a>, <a href="AArch32-mvfr2.html">MVFR2</a>.
</li><li><a href="AArch32-id_mmfr4.html">ID_MMFR4</a> and <a href="AArch32-id_mmfr5.html">ID_MMFR5</a> are trapped unless implemented as RAZ, when it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-id_mmfr4.html">ID_MMFR4</a> or <a href="AArch32-id_mmfr5.html">ID_MMFR5</a> are trapped.
</li><li><a href="AArch32-id_isar6.html">ID_ISAR6</a> is trapped unless implemented as RAZ, when it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-id_isar6.html">ID_ISAR6</a> are trapped.
</li><li><a href="AArch32-id_dfr1.html">ID_DFR1</a> is trapped unless implemented as RAZ, when it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-id_dfr1.html">ID_DFR1</a> are trapped.
</li><li>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit traps MRC accesses to registers not already mentioned, with coproc==p15, opc1 == 0, CRn == c0, CRm == {c2-c7}, opc2 == {0-7}.
</li></ul><table class="valuetable"><tr><th>TID3</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The specified Non-secure EL1 read accesses to ID group 3 registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TID2_17">TID2, bit [17]
              </h4><p>Trap ID group 2. Traps the following register accesses to EL2, when EL2 is enabled in the current Security state:</p><ul><li>Non-secure EL1 and EL0 reads of the <a href="AArch32-ctr.html">CTR</a>, <a href="AArch32-ccsidr.html">CCSIDR</a>, <a href="AArch32-ccsidr2.html">CCSIDR2</a>, <a href="AArch32-clidr.html">CLIDR</a>, and <a href="AArch32-csselr.html">CSSELR</a>.
</li><li>Non-secure EL1 and EL0 writes to the <a href="AArch32-csselr.html">CSSELR</a>.
</li></ul><table class="valuetable"><tr><th>TID2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The specified Non-secure EL1 and EL0 accesses to ID group 2 registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TID1_16">TID1, bit [16]
              </h4><p>Trap ID group 1. Traps Non-secure EL1 reads of the following registers to EL2, when EL2 is enabled in the current Security state:</p><p><a href="AArch32-tcmtr.html">TCMTR</a>, <a href="AArch32-tlbtr.html">TLBTR</a>, <a href="AArch32-revidr.html">REVIDR</a>, <a href="AArch32-aidr.html">AIDR</a>.</p><table class="valuetable"><tr><th>TID1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The specified Non-secure EL1 read accesses to ID group 1 registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TID0_15">TID0, bit [15]
              </h4><p>Trap ID group 0. Traps the following register accesses to EL2, when EL2 is enabled in the current Security state:</p><ul><li>Non-secure EL1 reads of the <a href="AArch32-jidr.html">JIDR</a> and <a href="AArch32-fpsid.html">FPSID</a>.
</li><li>If the <a href="AArch32-jidr.html">JIDR</a> is RAZ from Non-secure EL0, Non-secure EL0 reads of the <a href="AArch32-jidr.html">JIDR</a>.
</li></ul><div class="note"><span class="note-header">Note</span><ul><li>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the <a href="AArch32-jidr.html">JIDR</a> is RAZ or <span class="arm-defined-word">UNDEFINED</span> at EL0. If it is <span class="arm-defined-word">UNDEFINED</span> at EL0 then the Undefined Instruction exception takes precedence over this trap.</li><li>The <a href="AArch32-fpsid.html">FPSID</a> is not accessible at EL0.</li><li>Writes to the <a href="AArch32-fpsid.html">FPSID</a> are ignored, and not trapped by this control.</li></ul></div><table class="valuetable"><tr><th>TID0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The specified Non-secure EL1 read accesses to ID group 0 registers are trapped to EL2.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TWE_14">TWE, bit [14]
              </h4><p>Traps Non-secure EL0 and EL1 execution of WFE instructions to EL2, when EL2 is enabled in the current Security state.</p><table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFE instruction at Non-secure EL0 or EL1 is trapped to EL2, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE.</p></td></tr></table><p>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFE can complete at any time, even without a Wakeup event, the traps on WFE are not guaranteed to be taken, even if the WFE is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TWI_13">TWI, bit [13]
              </h4><p>Traps Non-secure EL0 and EL1 execution of WFI instructions to EL2, when EL2 is enabled in the current Security state.</p><table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFI instruction at Non-secure EL0 or EL1 is trapped to EL2, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI.</p></td></tr></table><p>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFI can complete at any time, even without a Wakeup event, the traps on WFI are not guaranteed to be taken, even if the WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="DC_12">DC, bit [12]
              </h4><p>Default Cacheability.</p><table class="valuetable"><tr><th>DC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control has no effect on the Non-secure EL1&amp;0 translation regime.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>In Non-secure state:</p><ul><li>The <a href="AArch32-sctlr.html">SCTLR</a>.M field behaves as 0 for all purposes other than a direct read of the value of the field.
</li><li>The HCR.VM field behaves as 1 for all purposes other than a direct read of the value of the field.
</li><li>The memory type produced by the first stage of the EL1&amp;0 translation regime is Normal Non-Shareable, Inner Write-Back Read-Allocate Write-Allocate, Outer Write-Back Read-Allocate Write-Allocate.
</li></ul></td></tr></table><p>This field has no effect on the EL2 and EL3 translation regimes.</p><p>This field is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="BSU_11">BSU, bits [11:10]
                  </h4><p>Barrier Shareability upgrade. This field determines the minimum shareability domain that is applied to any barrier instruction executed from Non-secure EL1 or Non-secure EL0:</p><table class="valuetable"><tr><th>BSU</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>No effect.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Inner Shareable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Outer Shareable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Full system.</p></td></tr></table><p>This value is combined with the specified level of the barrier held in its instruction, using the same principles as combining the shareability attributes from two stages of address translation.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="FB_9">FB, bit [9]
              </h4><p>Force broadcast. Causes the following instructions to be broadcast within the Inner Shareable domain when executed from Non-secure EL1:</p><p><a href="AArch32-bpiall.html">BPIALL</a>, <a href="AArch32-tlbiall.html">TLBIALL</a>, <a href="AArch32-tlbimva.html">TLBIMVA</a>, <a href="AArch32-tlbiasid.html">TLBIASID</a>, <a href="AArch32-dtlbiall.html">DTLBIALL</a>, <a href="AArch32-dtlbimva.html">DTLBIMVA</a>, <a href="AArch32-dtlbiasid.html">DTLBIASID</a>, <a href="AArch32-itlbiall.html">ITLBIALL</a>, <a href="AArch32-itlbimva.html">ITLBIMVA</a>, <a href="AArch32-itlbiasid.html">ITLBIASID</a>, <a href="AArch32-tlbimvaa.html">TLBIMVAA</a>, <a href="AArch32-iciallu.html">ICIALLU</a>, <a href="AArch32-tlbimval.html">TLBIMVAL</a>, <a href="AArch32-tlbimvaal.html">TLBIMVAAL</a>.</p><table class="valuetable"><tr><th>FB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This field has no effect on the operation of the specified instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When one of the specified instruction is executed at Non-secure EL1, the instruction is broadcast within the Inner Shareable shareability domain.</p></td></tr></table><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="VA_8">VA, bit [8]
              </h4><p>Virtual SError interrupt exception.</p><table class="valuetable"><tr><th>VA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This mechanism is not making a virtual SError interrupt pending.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>A virtual SError interrupt is pending because of this mechanism.</p></td></tr></table><p>The virtual SError interrupt is enabled only when the value of HCR.{TGE, AMO} is {0, 1}.</p><p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="VI_7">VI, bit [7]
              </h4><p>Virtual IRQ exception.</p><table class="valuetable"><tr><th>VI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This mechanism is not making a virtual IRQ pending.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>A virtual IRQ is pending because of this mechanism.</p></td></tr></table><p>The virtual IRQ is enabled only when the value of HCR.{TGE, IMO} is {0, 1}.</p><p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="VF_6">VF, bit [6]
              </h4><p>Virtual FIQ exception.</p><table class="valuetable"><tr><th>VF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This mechanism is not making a virtual FIQ pending.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>A virtual FIQ is pending because of this mechanism.</p></td></tr></table><p>The virtual FIQ is enabled only when the value of HCR.{TGE, FMO} is {0, 1}.</p><p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="AMO_5">AMO, bit [5]
              </h4><p>SError interrupt Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.A, and enables virtual exception signaling by the VA bit.</p><p>If the value of HCR.TGE is 0, then virtual SError interrupts are enabled in Non-secure state.</p><p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.AMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="IMO_4">IMO, bit [4]
              </h4><p>IRQ Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.I, and enables virtual exception signaling by the VI bit.</p><p>If the value of HCR.TGE is 0, then Virtual IRQ interrupts are enabled in the Non-secure state.</p><p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.IMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="FMO_3">FMO, bit [3]
              </h4><p>FIQ Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.F, and enables virtual exception signaling by the VF bit.</p><p>If the value of HCR.TGE is 0, then Virtual FIQ interrupts are enabled in the Non-secure state.</p><p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.FMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="PTW_2">PTW, bit [2]
              </h4><p>Protected Table Walk. In the Non-secure PL1&amp;0 translation regime, a translation table access made as part of a stage 1 translation table walk is subject to a stage 2 translation. The combining of the memory type attributes from the two stages of translation means the access might be made to a type of Device memory. If this occurs then the value of this bit determines the behavior:</p><table class="valuetable"><tr><th>PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The translation table walk occurs as if it is to Normal Non-cacheable memory. This means it can be made speculatively.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The memory access generates a stage 2 Permission fault.</p></td></tr></table><p>This field is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="SWIO_1">SWIO, bit [1]
              </h4><p>Set/Way Invalidation Override. Causes Non-secure EL1 execution of the data cache invalidate by set/way instructions to perform a data cache clean and invalidate by set/way.</p><table class="valuetable"><tr><th>SWIO</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control has no effect on the operation of data cache invalidate by set/way instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Data cache invalidate by set/way instructions perform a data cache clean and invalidate by set/way.</p></td></tr></table><p>When this bit is set to 1, <a href="AArch32-dcisw.html">DCISW</a> performs the same invalidation as a <a href="AArch32-dccisw.html">DCCISW</a> instruction.</p><p>As a result of changes to the behavior of <a href="AArch32-dcisw.html">DCISW</a>, this bit is redundant in Armv8. This bit can be implemented as <span class="arm-defined-word">RES1</span>.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="VM_0">VM, bit [0]
              </h4><p>Virtualization enable. Enables stage 2 address translation for the Non-secure EL1&amp;0 translation regime.</p><table class="valuetable"><tr><th>VM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Non-secure EL1&amp;0 stage 2 address translation disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Non-secure EL1&amp;0 stage 2 address translation enabled.</p></td></tr></table><p>If the HCR.DC bit is set to 1, then the behavior of the PE when executing in a Non-secure mode other than Hyp mode is consistent with HCR.VM being 1, regardless of the actual value of HCR.VM, other than the value returned by an explicit read of HCR.VM.</p><p>When the value of this bit is 1, data cache invalidate instructions executed at Non-secure EL1 perform a data cache clean and invalidate. For the invalidate by set/way instruction this behavior applies regardless of the value of the HCR.SWIO bit.</p><p>This bit is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL2 or EL3, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the HCR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    return HCR;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        UNDEFINED;
    else
        return HCR;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    HCR = R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        UNDEFINED;
    else
        HCR = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>