<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>SSBS</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SSBS, Speculative Store Bypass Safe</h1><p>The SSBS characteristics are:</p><h2>Purpose</h2><p>Allows access to the Speculative Store Bypass Safe bit.</p><h2>Configuration</h2><p>This register is present only
    when ARMv8.0-SSBS is implemented.
      
    Otherwise, direct accesses to SSBS are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>SSBS is a 64-bit register.</p><h2>Field descriptions</h2><p>The SSBS bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="19"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#SSBS_12">SSBS</a></td><td class="lr" colspan="12"><a href="#0_11">RES0</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="0_63">
                Bits [63:13]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="SSBS_12">SSBS, bit [12]
              </h4><p>Speculative Store Bypass Safe.</p><p>Prohibits speculative loads or stores which might practically allow a cache timing side channel.</p><p>A cache timing side channel might be exploited where a load or store uses an address that is derived from a register that is being loaded from memory using a load instruction speculatively read from a memory location. If PSTATE.SSBS is enabled, the address derived from the load instruction might be from earlier in the coherence order than the latest store to that memory location with the same virtual address.</p><table class="valuetable"><tr><th>SSBS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Hardware is not permitted to load or store speculatively, in a manner that could practically give rise to a cache timing side channel, using an address derived from a register value that has been loaded from memory using a load instruction (L) that speculatively reads an entry from earlier in the coherence order from that location being loaded from than the entry generated by the latest store (S) to that location using the same virtual address as L.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Hardware is permitted to load or store speculatively, in a manner that could practically give rise to a cache timing side channel, using an address derived from a register value that has been loaded from memory using a load instruction (L) that speculatively reads an entry from earlier in the coherence order fro that location being loaded from than the entry generated by the latest store (S) to that location using the same virtual address as L.</p></td></tr></table><p>The value of this bit is set to the value in the SCTLR_ELx.DSSBS field on taking an exception to ELx.</p><p>This field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0_11">
                Bits [11:0]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the SSBS</h2><p><del>For details on the operation of the MSR (immediate) accessor, see </del><span class="xref"><del>MSR (immediate)</del></span><del> in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile.</del></p><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, SSBS</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0010</td><td>0b110</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    return Zeros(51):PSTATE.SSBS:Zeros(12);
elsif PSTATE.EL == EL1 then
    return Zeros(51):PSTATE.SSBS:Zeros(12);
elsif PSTATE.EL == EL2 then
    return Zeros(51):PSTATE.SSBS:Zeros(12);
elsif PSTATE.EL == EL3 then
    return Zeros(51):PSTATE.SSBS:Zeros(12);
              </p><h4 class="assembler">MSR SSBS, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0010</td><td>0b110</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    PSTATE.SSBS = X[t]&lt;12>;
elsif PSTATE.EL == EL1 then
    PSTATE.SSBS = X[t]&lt;12>;
elsif PSTATE.EL == EL2 then
    PSTATE.SSBS = X[t]&lt;12>;
elsif PSTATE.EL == EL3 then
    PSTATE.SSBS = X[t]&lt;12>;
              </p><h4 class="assembler">MSR SSBS, #&lt;imm></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>op2</th></tr><tr><td>0b00</td><td>0b011</td><td>0b0100</td><td>0b001</td></tr></table></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>