<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>DBGBXVR&lt;n></title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DBGBXVR&lt;n>, Debug Breakpoint Extended Value Registers, n =
      0 - 15</h1><p>The DBGBXVR&lt;n> characteristics are:</p><h2>Purpose</h2><p>Holds a value for use in breakpoint matching, to support VMID matching. Used in conjunction with a control register <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n></a> and a value register <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n></a>, where EL2 is implemented and breakpoint n supports Context matching.</p><h2>Configuration</h2><p>AArch32 System register DBGBXVR&lt;n> bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1[63:32]
            </a>.
          </p><p>AArch32 System register DBGBXVR&lt;n> bits [31:0]
            
                are architecturally mapped to
              External register <a href="ext-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1[63:32]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to DBGBXVR&lt;n> are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>Accesses to this register are <span class="arm-defined-word">UNDEFINED</span> in any of the following cases:</p><ul><li>Breakpoint n is not implemented.
</li><li>Breakpoint n does not support Context matching.
</li><li>EL2 is not implemented.
</li></ul><p>For more information, see the description of the <a href="AArch32-dbgdidr.html">DBGDIDR</a>.CTX_CMPs field.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>How this register is interpreted depends on the value of <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n></a>.BT.</p><ul><li>When <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n></a>.BT is <span class="binarynumber">0b10xx</span>, this register holds a VMID.
</li><li>When <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n></a>.BT is <span class="binarynumber">0b11xx</span>, this register holds a Context ID.
</li></ul><p>For other values of <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n></a>.BT, this register is <span class="arm-defined-word">RES0</span>.</p><h2>Field descriptions</h2><p>The DBGBXVR&lt;n> bit assignments are:</p><h3>When DBGBCR&lt;n>.BT == 0b10xx and <del>HaveEL(</del>EL2<ins> is implemented:</ins><del>):</del></h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_0_31">RES0</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_VMID15:8_15">VMID[15:8]</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_VMID7:0_7">VMID[7:0]</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_0_31">
                Bits [31:16]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_VMID15:8_15">VMID[15:8], bits [15:8]
                  <div style="font-size:smaller;"><br/>When ARMv8.1-VMID16 is implemented<ins> and VTCR_EL2.VS == 1</ins>:
                </div></h4><p>Extension to VMID[7:0]. See VMID[7:0] for more details.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_0_15"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>.BT0b10xxandEL2isimplemented_VMID7:0_7">VMID[7:0], bits [7:0]
                  </h4><p><del>The VMID is 8 bits in the following cases.</del></p><p>VMID value for comparison.<ins> The VMID is 8 bits when any of the following are true:</ins></p><ul><li>EL2 is using AArch32.
</li><li><a href="AArch64-vtcr_el2.html"><ins>VTCR_EL2</ins></a><ins>.VS is 0.
</ins></li><li><span class="xref">ARMv8.1-VMID16</span> is not implemented.
</li></ul><p><del>When </del><span class="xref"><del>ARMv8.1-VMID16</del></span><del> is implemented and EL2 is using AArch64, it is </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> whether the VMID is 8 bits or 16 bits.</del></p><p><del>VMID[15:8] is </del><span class="arm-defined-word"><del>RES0</del></span><del> if any of the following applies:</del></p><ul><li><del>The implementation has an 8-bit VMID.
</del></li><li><a href="AArch64-vtcr_el2.html"><del>VTCR_EL2</del></a><del>.VS has a value of 0.
</del></li><li><del>EL2 is using AArch32.
</del></li></ul><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>.BT == 0b11xx and <del>HaveEL(</del>EL2<ins> is implemented:</ins><del>):</del></h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>.BT0b11xxandEL2isimplemented_ContextID2_31">ContextID2</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>.BT0b11xxandEL2isimplemented_ContextID2_31">ContextID2, bits [31:0]
                  <div style="font-size:smaller;"><br/>When ARMv8.1-VHE is implemented<ins> or ARMv8.2-Debug is implemented</ins>:
                </div></h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>.BT0b11xxandEL2isimplemented_0_31"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the DBGBXVR&lt;n></h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0001</td><td>n[3:0]</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBXVR[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBXVR[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBXVR[UInt(CRm&lt;3:0>)];
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0001</td><td>n[3:0]</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBXVR[UInt(CRm&lt;3:0>)] = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    elsif ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBXVR[UInt(CRm&lt;3:0>)] = R[t];
elsif PSTATE.EL == EL3 then
    if ELUsingAArch32(EL1) &amp;&amp; DBGOSLSR.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBXVR[UInt(CRm&lt;3:0>)] = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>