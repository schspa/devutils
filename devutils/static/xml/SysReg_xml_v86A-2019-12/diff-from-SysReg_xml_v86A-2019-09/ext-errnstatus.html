<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>ERR&lt;n>STATUS</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">ERR&lt;n>STATUS, Error Record Primary Status Register, n =
      0 - 65534</h1><p>The ERR&lt;n>STATUS characteristics are:</p><h2>Purpose</h2><p>Contains status information for the error record, including:</p><ul><li><p><del>Whether any error has been detected (valid).</del></p><ins>Whether any error has been detected (valid).
</ins></li><li><p><del>Whether any detected error was not corrected, and returned to a master.</del></p><ins>Whether any detected error was not corrected, and returned to a master.
</ins></li><li><p><del>Whether any detected error was not corrected and deferred.</del></p><ins>Whether any detected error was not corrected and deferred.
</ins></li><li><p><del>Whether an error record has been discarded because additional errors have been detected before the first error was handled by software (overflow).</del></p><ins>Whether an error record has been discarded because additional errors have been detected before the first error was handled by software (overflow).
</ins></li><li><p><del>Whether any error has been reported.</del></p><ins>Whether any error has been reported.
</ins></li><li><p><del>Whether the other error record registers contain valid information.</del></p><ins>Whether the other error record registers contain valid information.
</ins></li><li><p><del>Whether the error was recorded because poison data was detected or because a corrupt value was detected by an error detection code.</del></p><ins>Whether the error was reported because poison data was detected or because a corrupt value was detected by an error detection code.
</ins></li><li><p><del>A primary error code.</del></p><ins>A primary error code.
</ins></li><li><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> extended error code.
</ins></li><li><p><del>An </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> extended error code.</del></p></li></ul><p>Within this register:</p><ul><li><p><del>The {AV, V, MV} bits are valid bits that define whether the error record registers are valid.</del></p><ins>The {AV, V, MV} bits are valid bits that define whether the error record registers are valid.
</ins></li><li><p><del>The {UE, OF, CE, DE, UET} bits encode the type of error or errors recorded.</del></p><ins>The {UE, OF, CE, DE, UET} bits encode the types of error or errors recorded.
</ins></li><li><p><del>The {CI, ER, PN, IERR, SERR} fields are syndrome fields.</del></p><ins>The {CI, ER, PN, IERR, SERR} fields are syndrome fields.
</ins></li></ul><h2>Configuration</h2><p><del>This register is present only
    when RAS is implemented.
      
    Otherwise, direct accesses to ERR&lt;n>STATUS are </del><span class="arm-defined-word"><del>UNDEFINED</del></span><del>.</del></p><p><del>The number of error records that are implemented is </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del>.</del></p><p><del>If error record &lt;n> is not implemented, ERR&lt;n>STATUS is </del><span class="arm-defined-word"><del>RES0</del></span><del>.</del></p><p><ins>This</ins><del>Some</del> <ins>register</ins><del>or</del> <ins>is</ins><del>all</del> <ins>present</ins><del>RW</del> <ins>only
    when</ins><del>fields</del> <ins>error</ins><del>of</del> <ins>record</ins><del>this</del> <ins>&lt;n></ins><del>register</del> <ins>is</ins><del>have</del> <ins>implemented.
      
    Otherwise,</ins><del>defined</del> <ins>direct</ins><del>reset</del> <ins>accesses to ERR&lt;n>STATUS are</ins><del>values.</del> <span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><p><a href="ext-errnfr.html">ERR&lt;q>FR</a> describes the features implemented by the node that owns error record &lt;n>. &lt;q> is the index of the first error record owned by the same node as error record &lt;n>. If the node owns a single record, then q = n.</p><p>For <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fields in <ins>ERR&lt;n>STATUS</ins><del>this register</del>, writing zero must always be supported to return the error record to an initial<ins> quiescent</ins> state.</p><p>In particular, if any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome fields might generate a Fault Handling or Error Recovery Interrupt request, writing zero is sufficient to deactivate the Interrupt request.</p><p>Fields that are read-only, non-zero<ins>,</ins> and ignore writes are compliant with this requirement.</p><div class="note"><span class="note-header">Note</span><p>Arm recommends that any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome fields that can generate a Fault Handling, Error Recovery, Critical, or <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>, interrupt request are disabled at Cold reset and are enabled by software writing an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> non-zero value to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> field in ERR&lt;q><ins>CTRL.</ins><del>CTRL, where q is the index of the first error record owned by the same node as error record n. If the node owns a single record then q = n.</del></p></div><h2>Attributes</h2><p>ERR&lt;n>STATUS is a 64-bit register.</p><h2>Field descriptions</h2><p>The ERR&lt;n>STATUS bit assignments are:</p><h3>When <ins>RAS System Architecture v1.1</ins><del>ARMv8.4-RAS</del> is implemented:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenRASSystemArchitecturev1.1isimplemented_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_AV_31">AV</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_V_30">V</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_UE_29">UE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_ER_28">ER</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_OF_27">OF</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_MV_26">MV</a></td><td class="lr" colspan="2"><a href="#WhenRASSystemArchitecturev1.1isimplemented_CE_25">CE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_DE_23">DE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_PN_22">PN</a></td><td class="lr" colspan="2"><a href="#WhenRASSystemArchitecturev1.1isimplemented_UET_21">UET</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.1isimplemented_CI_19">CI</a></td><td class="lr" colspan="3"><a href="#WhenRASSystemArchitecturev1.1isimplemented_0_18">RES0</a></td><td class="lr" colspan="8"><a href="#WhenRASSystemArchitecturev1.1isimplemented_IERR_15">IERR</a></td><td class="lr" colspan="8"><a href="#WhenRASSystemArchitecturev1.1isimplemented_SERR_7">SERR</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenRASSystemArchitecturev1.1isimplemented_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenRASSystemArchitecturev1.1isimplemented_AV_31">AV, bit [31]
              <div style="font-size:smaller;"><br/><ins>When the error record includes an address associated with an error:
                </ins></div></h4><p>Address Valid.</p><table class="valuetable"><tr><th>AV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="ext-errnaddr.html">ERR&lt;n>ADDR</a> not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="ext-errnaddr.html">ERR&lt;n>ADDR</a> contains an address associated with the highest priority error recorded by this record.</p></td></tr></table><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_0_31"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><h4 id="WhenRASSystemArchitecturev1.1isimplemented_V_30">V, bit [30]
              </h4><p>Status Register Valid.</p><table class="valuetable"><tr><th>V</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>ERR&lt;n>STATUS not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>ERR&lt;n>STATUS valid. At least one error has been recorded.</p></td></tr></table><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_UE_29">UE, bit [29]
              </h4><p>Uncorrected <ins>Error.</ins><del>error.</del></p><table class="valuetable"><tr><th>UE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No errors have been detected, or all detected errors have been either corrected or deferred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one detected error was not corrected and not deferred.</p></td></tr></table><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write one to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_ER_28">ER, bit [28]
              </h4><p>Error Reported.</p><table class="valuetable"><tr><th>ER</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No in-band error (External <ins>Abort</ins><del>abort</del>) reported.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An External <ins>Abort</ins><del>abort</del> was signaled by the node to the master making the access or other transaction. This can be because any of the following are true:</p><ul><li><ins>The applicable one of the </ins><a href="ext-errnctlr.html"><ins>ERR&lt;q>CTLR</ins></a><ins>.{WUE,RUE,UE} bits is implemented and was set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> when an Uncorrected error was detected.
</ins></li><li><p><del>The applicable one of the </del><a href="ext-errnctlr.html"><del>ERR&lt;q>CTLR</del></a><del>.{WUE,RUE,UE} bits is implemented, and was set to 1 when an Uncorrected error was detected.</del></p></li><li><p><del>The applicable one of the </del><a href="ext-errnctlr.html"><del>ERR&lt;q>CTLR</del></a><del>.{WUE,RUE,UE} bits is not implemented.</del></p><ins>The applicable one of the </ins><a href="ext-errnctlr.html"><ins>ERR&lt;q>CTLR</ins></a><ins>.{WUE,RUE,UE} bits is not implemented and the node always reports errors.
</ins></li></ul></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit can be set to<del> 1 by a Deferred error.</del> <span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.</ins></p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write one to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><ins>ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins> and this bit is never set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>ERR&lt;n>STATUS.UE is set to 0 and this bit is never set to 1 by a Deferred error.</del></p></li><li><ins>ERR&lt;n>STATUS.{UE,DE} == {0,0} and this bit can be set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>ERR&lt;n>STATUS.{UE, DE} are both set to 0, and this bit can be set to 1 by a Deferred error.</del></p></li></ul><p>This bit is read/write-one-to-clear.</p><div class="note"><span class="note-header">Note</span><p>An External <ins>Abort</ins><del>abort</del> signaled by the node might be masked and not generate any exception.</p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_OF_27">OF, bit [27]
              </h4><p>Overflow.</p><p>Indicates that multiple errors have been detected. This bit is set to<del> 1 when one of the following occurs:</del> <span class="binarynumber"><ins>0b1</ins></span><ins> when one of the following occurs:</ins></p><ul><li><p><del>A Corrected error counter is implemented, an error is counted, and the counter overflows.</del></p><ins>A Corrected error counter is implemented, an error is counted, and the counter overflows.
</ins></li><li><ins>ERR&lt;n>STATUS.V was previously set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins>, a Corrected error counter is not implemented, and a Corrected error is recorded.
</ins></li><li><p><del>ERR&lt;n>STATUS.V was previously set to 1, a Corrected error counter is not implemented, and a Corrected error is recorded.</del></p></li><li><ins>ERR&lt;n>STATUS.V was previously set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins>, and a type of error other than a Corrected error is recorded.
</ins></li><li><p><del>ERR&lt;n>STATUS.V was previously set to 1, and a type of error other than a Corrected error is recorded.</del></p></li></ul><p>Otherwise, this bit is unchanged when an error is recorded.</p><p>If a Corrected error counter is implemented:</p><ul><li><ins>A direct write that modifies the counter overflow flag indirectly might set this bit to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.
</ins></li><li><p><del>A direct write that modifies the counter overflow flag indirectly might set this bit to an </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> value.</del></p></li><li><ins>A direct write to this bit that clears this bit to zero might indirectly set the counter overflow flag to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.
</ins></li><li><p><del>A direct write to this bit that clears this bit to zero might indirectly set the counter overflow flag to an </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> value.</del></p></li></ul><table class="valuetable"><tr><th>OF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Since this bit was last cleared to zero, no error syndrome has been discarded and, if a Corrected error counter is implemented, it has not overflowed.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Since this bit was last cleared to zero, at least one error syndrome has been discarded or, if a Corrected error counter is implemented, it might have overflowed.</p></td></tr></table><p><ins>When</ins><del>If</del> <del>this bit is nonzero, then software must write 1 to this bit, to clear this bit to zero, when </del>clearing ERR&lt;n>STATUS.V to<del> 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_MV_26">MV, bit [26]
              <div style="font-size:smaller;"><br/><ins>When the error record includes an additional information for an error:
                </ins></div></h4><p>Miscellaneous Registers Valid.</p><table class="valuetable"><tr><th>MV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del>, </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><del>, </del><a href="ext-errnmisc2.html"><del>ERR&lt;n>MISC2</del></a><del>, and </del><a href="ext-errnmisc3.html"><del>ERR&lt;n>MISC3</del></a><ins>ERR&lt;n>MISC&lt;m></ins><del>are</del> not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> contents of the<ins> ERR&lt;n>MISC&lt;m> registers contains additional information for an error recorded by this record.</ins><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del>, </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><del>, </del><a href="ext-errnmisc2.html"><del>ERR&lt;n>MISC2</del></a><del>, and </del><a href="ext-errnmisc3.html"><del>ERR&lt;n>MISC3</del></a><del> registers contain additional information for an error recorded by this record.</del></p></td></tr></table><p>This bit is read/write-one-to-clear.</p><div class="note"><span class="note-header">Note</span><p>If the<ins> ERR&lt;n>MISC&lt;m> registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</ins><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del>, </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><del>, </del><a href="ext-errnmisc2.html"><del>ERR&lt;n>MISC2</del></a><del>, and </del><a href="ext-errnmisc3.html"><del>ERR&lt;n>MISC3</del></a><del> registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</del></p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_0_26"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><h4 id="WhenRASSystemArchitecturev1.1isimplemented_CE_25">CE, bits [25:24]
                  </h4><p>Corrected Error.</p><table class="valuetable"><tr><th>CE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>No errors were corrected.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>At least one transient error was corrected.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>At least one error was corrected.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>At least one persistent error was corrected.</p></td></tr></table><p>The mechanism by which a node detects whether a correctable error is transient or persistent is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>. If no such mechanism is implemented, then the node sets this field to <span class="binarynumber">0b10</span> when an error is corrected.</p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this field is nonzero, then software must write ones to this field to clear this field to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</ins></p><p><ins>This</ins><del>If ERR&lt;n>STATUS.V is set to 0, this</del> field is not valid and reads <span class="arm-defined-word">UNKNOWN</span> <ins>if ERR&lt;n>STATUS.V ==</ins><del>.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This field is read/<ins>write-ones-to-clear.</ins><del>write-one-to-clear.</del> Writing a value other than all-zeros or all-ones sets this field to an <span class="arm-defined-word">UNKNOWN</span> value.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_DE_23">DE, bit [23]
              </h4><p>Deferred Error.</p><table class="valuetable"><tr><th>DE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No errors were deferred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one error was not corrected and deferred.</p></td></tr></table><p>Support for deferring errors is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write 1 to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p><ins>This</ins><del>If ERR&lt;n>STATUS.V is set to 0, this</del> bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> <ins>if ERR&lt;n>STATUS.V ==</ins><del>.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_PN_22">PN, bit [22]
              </h4><p>Poison.</p><table class="valuetable"><tr><th>PN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Uncorrected error or Deferred error recorded because a corrupt value was detected, for example, by an error detection code (EDC).</p><div class="note"><span class="note-header">Note</span><p>If a producer node detects a corrupt value and defers the error by producing a poison value, then this bit is set to<del> 0 at the producer node.</del> <span class="binarynumber"><ins>0b0</ins></span><ins> at the producer node.</ins></p></div></td></tr><tr><td class="bitfield">0b1</td><td><p>Uncorrected error or Deferred error recorded because a poison value was detected.</p><div class="note"><span class="note-header">Note</span><p>This might only be an indication of poison, because, in some EDC schemes, a poison value is encoded as an unlikely form of corrupt data, meaning it is possible to mistake a corrupt value as a poison value.</p></div></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether a node can distinguish a poison value from a corrupt value.</p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write 1 to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><p><del>ERR&lt;n>STATUS.{DE, UE} are both set to 0.</del></p><ins>ERR&lt;n>STATUS.{DE,UE} == {0,0}.
</ins></li></ul><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_UET_21">UET, bits [21:20]
                  </h4><p><del>Describes the state of the component after detecting or consuming an Uncorrected error.</del></p><p>Uncorrected Error Type.<ins> Describes the state of the component after detecting or consuming an Uncorrected error.</ins></p><table class="valuetable"><tr><th>UET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Uncorrected error, Uncontainable error (UC).</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Uncorrected error, Unrecoverable error (UEU).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Uncorrected error, Latent or Restartable error (UEO).</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Uncorrected error, Signaled or Recoverable error (UER).</p></td></tr></table><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this field is nonzero, then software must write ones to this field to clear this field to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</ins></p><p>This field is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><ins>ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.UE is set to 0.</del></p></li></ul><p>This field is read/<ins>write-ones-to-clear.</ins><del>write-one-to-clear.</del> Writing a value other than all-zeros or all-ones sets this field to an <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="note"><span class="note-header"><ins class="nocount">Note</ins></span><p><ins>Software might use the information in the error record registers to determine what recovery is necessary.</ins></p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_CI_19">CI, bit [19]
              </h4><p><del>Indicates whether a critical error condition has been recorded.</del></p><p>Critical <ins>Error. Indicates whether a critical error condition has been recorded.</ins><del>error.</del></p><table class="valuetable"><tr><th>CI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No critical error <ins>condition.</ins><del>condition recorded.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>Critical error <ins>condition.</ins><del>condition recorded.</del></p></td></tr></table><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write 1 to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_0_18">
                Bits [18:16]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenRASSystemArchitecturev1.1isimplemented_IERR_15">IERR, bits [15:8]
                  </h4><p><del>This field is not valid and reads </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> if ERR&lt;n>STATUS.V is set to 0.</del></p><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> error code.<ins> Used with any primary error code SERR value. Further</ins> <span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> information can be placed in the MISC registers.</ins></p><p><ins>This</ins><del>Used</del> <ins>field</ins><del>with</del> <ins>is</ins><del>any</del> <ins>not</ins><del>primary</del> <ins>valid</ins><del>error</del> <ins>and</ins><del>code</del> <ins>reads</ins><del>SERR value. Further</del> <span class="arm-defined-word"><ins>UNKNOWN</ins><del>IMPLEMENTATION DEFINED</del></span><ins> if ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.</ins><del>information can be placed in the MISC registers.</del></p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.1isimplemented_SERR_7">SERR, bits [7:0]
                  </h4><p><del>Indicates the type of error. The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</del></p><p>Architecturally-defined primary error code.<ins> The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</ins></p><table class="valuetable"><tr><th>SERR</th><th>Meaning</th></tr><tr><td class="bitfield">0x00</td><td><p>No error.</p></td></tr><tr><td class="bitfield">0x01</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> error.</p></td></tr><tr><td class="bitfield">0x02</td><td><p>Data value from (non-associative) internal memory. For example, ECC from on-chip SRAM or buffer.</p></td></tr><tr><td class="bitfield">0x03</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> pin. For example, <span class="signal">nSEI</span> pin.</p></td></tr><tr><td class="bitfield">0x04</td><td><p>Assertion failure. For example, consistency failure.</p></td></tr><tr><td class="bitfield">0x05</td><td><p>Error detected on internal data path. For example, parity on ALU result.</p></td></tr><tr><td class="bitfield">0x06</td><td><p>Data value from associative memory. For example, ECC error on cache data.</p></td></tr><tr><td class="bitfield">0x07</td><td><p>Address/control value from associative memory. For example, ECC error on cache tag.</p></td></tr><tr><td class="bitfield">0x08</td><td><p>Data value from a TLB. For example, ECC error on TLB data.</p></td></tr><tr><td class="bitfield">0x09</td><td><p>Address/control value from a TLB. For example, ECC error on TLB tag.</p></td></tr><tr><td class="bitfield">0x0A</td><td><p>Data value from producer. For example, parity error on write data bus.</p></td></tr><tr><td class="bitfield">0x0B</td><td><p>Address/control value from producer. For example, parity error on address bus.</p></td></tr><tr><td class="bitfield">0x0C</td><td><p>Data value from (non-associative) external memory. For example, ECC error in SDRAM.</p></td></tr><tr><td class="bitfield">0x0D</td><td><p>Illegal address (software fault). For example, access to unpopulated memory.</p></td></tr><tr><td class="bitfield">0x0E</td><td><p>Illegal access (software fault). For example, byte write to word register.</p></td></tr><tr><td class="bitfield">0x0F</td><td><p>Illegal state (software fault). For example, device not ready.</p></td></tr><tr><td class="bitfield">0x10</td><td><p>Internal data register. For example, parity on a SIMD&amp;FP register. For a PE, all general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are data registers.</p></td></tr><tr><td class="bitfield">0x11</td><td><p>Internal control register. For example, Parity on a System register. For a PE, all registers other than general-purpose, stack pointer, SIMD&amp;FP, and SVE registers are control registers.</p></td></tr><tr><td class="bitfield">0x12</td><td><p>Error response from slave. For example, error response from cache write-back.</p></td></tr><tr><td class="bitfield">0x13</td><td><p>External timeout. For example, timeout on interaction with another node.</p></td></tr><tr><td class="bitfield">0x14</td><td><p>Internal timeout. For example, timeout on interface within the node.</p></td></tr><tr><td class="bitfield">0x15</td><td><p>Deferred error from slave not supported at master. For example, poisoned data received from a slave by a master that cannot defer the error further.</p></td></tr><tr><td class="bitfield"><ins>0x16</ins></td><td><p><ins>Deferred error from master not supported at slave. For example, poisoned data received from a master by a slave that cannot defer the error further.</ins></p></td></tr><tr><td class="bitfield"><ins>0x17</ins></td><td><p><ins>Deferred error from slave passed through. For example, poisoned data received from a slave and returned to a master.</ins></p></td></tr><tr><td class="bitfield"><ins>0x18</ins></td><td><p><ins>Deferred error from master passed through. For example, poisoned data received from a master and deferred to a slave.</ins></p></td></tr><tr><td class="bitfield"><ins>0x19</ins></td><td><p><ins>Error recorded by PCIe error logs. Indicates that the node has recorded an error in a PCIe error log. This might be the PCIe device status register, AER, DVSEC, or other mechanisms defined by PCIe.</ins></p></td></tr></table><p>All other values are reserved.<del> Reserved values might be defined in a future version of the architecture.</del></p><p>This field is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><div class="text_after_fields"></div><h3><ins>When RAS System Architecture v1.0 is implemented</ins><del>Otherwise</del>:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenRASSystemArchitecturev1.0isimplemented_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_AV_31">AV</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_V_30">V</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_UE_29">UE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_ER_28">ER</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_OF_27">OF</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_MV_26">MV</a></td><td class="lr" colspan="2"><a href="#WhenRASSystemArchitecturev1.0isimplemented_CE_25">CE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_DE_23">DE</a></td><td class="lr" colspan="1"><a href="#WhenRASSystemArchitecturev1.0isimplemented_PN_22">PN</a></td><td class="lr" colspan="2"><a href="#WhenRASSystemArchitecturev1.0isimplemented_UET_21">UET</a></td><td class="lr" colspan="4"><a href="#WhenRASSystemArchitecturev1.0isimplemented_0_19">RES0</a></td><td class="lr" colspan="8"><a href="#WhenRASSystemArchitecturev1.0isimplemented_IERR_15">IERR</a></td><td class="lr" colspan="8"><a href="#WhenRASSystemArchitecturev1.0isimplemented_SERR_7">SERR</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenRASSystemArchitecturev1.0isimplemented_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenRASSystemArchitecturev1.0isimplemented_AV_31">AV, bit [31]
              <div style="font-size:smaller;"><br/><ins>When the error record includes an address associated with an error:
                </ins></div></h4><p>Address Valid.</p><table class="valuetable"><tr><th>AV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="ext-errnaddr.html">ERR&lt;n>ADDR</a> not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="ext-errnaddr.html">ERR&lt;n>ADDR</a> contains an address associated with the highest priority error recorded by this record.</p></td></tr></table><p>This bit ignores writes if <del>any of </del>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and the highest priority of these is not being cleared to 0 in the same write.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_0_31"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><h4 id="WhenRASSystemArchitecturev1.0isimplemented_V_30">V, bit [30]
              </h4><p>Status Register Valid.</p><table class="valuetable"><tr><th>V</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>ERR&lt;n>STATUS not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>ERR&lt;n>STATUS valid. At least one error has been recorded.</p></td></tr></table><p>This bit ignores writes if <del>any of </del>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and and is not being cleared to 0 in the same write.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and is not being cleared to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_UE_29">UE, bit [29]
              </h4><p>Uncorrected <ins>Error.</ins><del>error.</del></p><table class="valuetable"><tr><th>UE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No errors have been detected, or all detected errors have been either corrected or deferred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one detected error was not corrected and not deferred.</p></td></tr></table><p><del>This bit is not valid and reads </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> if ERR&lt;n>STATUS.V is set to 0.</del></p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write one to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p><ins>This</ins><del>If</del> <ins>bit</ins><del>ERR&lt;n>STATUS.OF</del> is <ins>not</ins><del>set</del> <ins>valid</ins><del>to</del> <del>1 </del>and <ins>reads</ins><del>is not being cleared to 0 in the same write, this bit ignores writes.</del> <span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> if ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>. This bit ignores writes if ERR&lt;n>STATUS.OF == </ins><span class="binarynumber"><ins>0b1</ins></span><ins> and is not being cleared to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_ER_28">ER, bit [28]
              </h4><p>Error Reported.</p><table class="valuetable"><tr><th>ER</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No in-band error (External <ins>Abort</ins><del>abort</del>) reported.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An External <ins>Abort</ins><del>abort</del> was signaled by the node to the master making the access or other transaction. This can be because any of the following are true:</p><ul><li><ins>The applicable one of the </ins><a href="ext-errnctlr.html"><ins>ERR&lt;q>CTLR</ins></a><ins>.{WUE,RUE,UE} bits is implemented and was set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> when an Uncorrected error was detected.
</ins></li><li><p><del>The applicable one of the </del><a href="ext-errnctlr.html"><del>ERR&lt;q>CTLR</del></a><del>.{WUE,RUE,UE} bits is implemented, and was set to 1 when an Uncorrected error was detected.</del></p></li><li><p><del>The applicable one of the </del><a href="ext-errnctlr.html"><del>ERR&lt;q>CTLR</del></a><del>.{WUE,RUE,UE} bits is not implemented.</del></p><ins>The applicable one of the </ins><a href="ext-errnctlr.html"><ins>ERR&lt;q>CTLR</ins></a><ins>.{WUE,RUE,UE} bits is not implemented and the node always reports errors.
</ins></li></ul></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit can be set to<del> 1 by a Deferred error.</del> <span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.</ins></p><p>If this bit is nonzero, then software must write<del> 1 to this bit, to clear this bit to zero, when:</del> <span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero, when any of:</ins></p><ul><li><ins>Clearing ERR&lt;n>STATUS.V to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>Clearing ERR&lt;n>STATUS.V to 0.</del></p></li><li><ins>Clearing ERR&lt;n>STATUS.UE to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is never set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>Clearing ERR&lt;n>STATUS.UE to 0, if this bit is never set to 1 by a Deferred error.</del></p></li><li><ins>Clearing ERR&lt;n>STATUS.{UE,DE} to {0,0}, if this bit can be set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>Clearing both ERR&lt;n>STATUS.{UE, DE} to 0, if this bit can be set to 1 by a Deferred error.</del></p></li></ul><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><ins>ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins> and this bit is never set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>ERR&lt;n>STATUS.UE is set to 0 and this bit is never set to 1 by a Deferred error.</del></p></li><li><ins>ERR&lt;n>STATUS.{UE,DE} == {0,0} and this bit can be set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins> by a Deferred error.
</ins></li><li><p><del>ERR&lt;n>STATUS.{UE, DE} are both set to 0, and this bit can be set to 1 by a Deferred error.</del></p></li></ul><p>This bit ignores writes if <del>any of </del>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and the highest priority of these is not being cleared to 0 in the same write.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><div class="note"><span class="note-header">Note</span><p>An External <ins>Abort</ins><del>abort</del> signaled by the node might be masked and not generate any exception.</p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_OF_27">OF, bit [27]
              </h4><p>Overflow.</p><p>Indicates that multiple errors have been detected. This bit is set to<del> 1 when one of the following occurs:</del> <span class="binarynumber"><ins>0b1</ins></span><ins> when one of the following occurs:</ins></p><ul><li><ins>An Uncorrected error is detected and ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li><p><del>An Uncorrected error is detected and ERR&lt;n>STATUS.UE == 1.</del></p></li><li><ins>A Deferred error is detected, ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins> and ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li><p><del>A Deferred error is detected, ERR&lt;n>STATUS.UE == 0 and ERR&lt;n>STATUS.DE == 1.</del></p></li><li><ins>A Corrected error is detected, no Corrected error counter is implemented, ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, and ERR&lt;n>STATUS.CE != </ins><span class="binarynumber"><ins>0b00</ins></span><ins>. ERR&lt;n>STATUS.CE might be updated for the new Corrected error.
</ins></li><li><p><del>A Corrected error is detected, no Corrected error counter is implemented, ERR&lt;n>STATUS.UE == 0, ERR&lt;n>STATUS.DE == 0, and ERR&lt;n>STATUS.CE != </del><span class="binarynumber"><del>0b00</del></span><del>. ERR&lt;n>STATUS.CE might be updated for the new Corrected error.</del></p></li><li><ins>A Corrected error counter is implemented, ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, and the counter overflows.
</ins></li><li><p><del>A Corrected error counter is implemented, ERR&lt;n>STATUS.UE == 0, ERR&lt;n>STATUS.DE == 0, and the counter overflows.</del></p></li></ul><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is set to<del> 1 when one of the following occurs:</del> <span class="binarynumber"><ins>0b1</ins></span><ins> when one of the following occurs:</ins></p><ul><li><ins>A Deferred error is detected and ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li><p><del>A Deferred error is detected and ERR&lt;n>STATUS.UE == 1.</del></p></li><li><ins>A Corrected error is detected, no Corrected error counter is implemented, and either or both the ERR&lt;n>STATUS.UE or ERR&lt;n>STATUS.DE bits are set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li><p><del>A Corrected error is detected, no Corrected error counter is implemented, and either or both the ERR&lt;n>STATUS.UE or ERR&lt;n>STATUS.DE bits are set to 1.</del></p></li><li><ins>A Corrected error counter is implemented, either or both the ERR&lt;n>STATUS.UE or ERR&lt;n>STATUS.DE bits are set to </ins><span class="binarynumber"><ins>0b1</ins></span><ins>, and the counter overflows.
</ins></li><li><p><del>A Corrected error counter is implemented, either or both the ERR&lt;n>STATUS.UE or ERR&lt;n>STATUS.DE bits are set to 1, and the counter overflows.</del></p></li></ul><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is <ins>cleared</ins><del>set</del> to<del> 0 when one of the following occurs:</del> <span class="binarynumber"><ins>0b0</ins></span><ins> when one of the following occurs:</ins></p><ul><li><ins>An Uncorrected error is detected and ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>An Uncorrected error is detected and ERR&lt;n>STATUS.UE == 0.</del></p></li><li><ins>A Deferred error is detected, ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins> and ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>A Deferred error is detected, ERR&lt;n>STATUS.UE == 0 and ERR&lt;n>STATUS.DE == 0.</del></p></li><li><ins>A Corrected error is detected, ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins> and ERR&lt;n>STATUS.CE == </ins><span class="binarynumber"><ins>0b00</ins></span><ins>.
</ins></li><li><p><del>A Corrected error is detected, ERR&lt;n>STATUS.UE == 0, ERR&lt;n>STATUS.DE == 0 and ERR&lt;n>STATUS.CE == </del><span class="binarynumber"><del>0b00</del></span><del>.</del></p></li></ul><p>The <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> clearing of this bit might also depend on the value of the other error status bits.</p><p>If a Corrected error counter is implemented:</p><ul><li><ins>A direct write that modifies the counter overflow flag indirectly might set this bit to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.
</ins></li><li><p><del>A direct write that modifies the counter overflow flag indirectly might set this bit to an </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> value.</del></p></li><li><ins>A direct write to this bit that clears this bit to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> might indirectly set the counter overflow flag to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.
</ins></li><li><p><del>A direct write to this bit that clears this bit to 0 might indirectly set the counter overflow flag to an </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> value.</del></p></li></ul><table class="valuetable"><tr><th>OF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If ERR&lt;n>STATUS.UE ==<del> 1, then no error syndrome for an Uncorrected error has been discarded.</del> <span class="binarynumber"><ins>0b1</ins></span><ins>, then no error syndrome for an Uncorrected error has been discarded.</ins></p><p>If ERR&lt;n>STATUS.UE ==<del> 0 and ERR&lt;n>STATUS.DE == 1, then no error syndrome for a Deferred error has been discarded.</del> <span class="binarynumber"><ins>0b0</ins></span><ins> and ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b1</ins></span><ins>, then no error syndrome for a Deferred error has been discarded.</ins></p><p>If ERR&lt;n>STATUS.UE ==<del> 0, ERR&lt;n>STATUS.DE == 0, and a Corrected error counter is implemented, then the counter has not overflowed.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, and a Corrected error counter is implemented, then the counter has not overflowed.</ins></p><p>If ERR&lt;n>STATUS.UE ==<del> 0, ERR&lt;n>STATUS.DE == 0, ERR&lt;n>STATUS.CE !=</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.DE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>, ERR&lt;n>STATUS.CE != </ins><span class="binarynumber">0b00</span>, and no Corrected error counter is implemented, then no error syndrome for a Corrected error has been discarded.</p><div class="note"><span class="note-header">Note</span><p>This bit might have been set to<del> 1 when an error syndrome was discarded and later cleared to 0 when a higher priority syndrome was recorded.</del> <span class="binarynumber"><ins>0b1</ins></span><ins> when an error syndrome was discarded and later cleared to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> when a higher priority syndrome was recorded.</ins></p></div></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one error syndrome has been discarded or, if a Corrected error counter is implemented, it might have overflowed.</p></td></tr></table><p><ins>When</ins><del>If</del> <del>this bit is nonzero, then software must write 1 to this bit, to clear this bit to zero, when </del>clearing ERR&lt;n>STATUS.V to<del> 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_MV_26">MV, bit [26]
              <div style="font-size:smaller;"><br/><ins>When the error record includes an additional information for an error:
                </ins></div></h4><p>Miscellaneous Registers Valid.</p><table class="valuetable"><tr><th>MV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del> and </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><ins>ERR&lt;n>MISC&lt;m> </ins>not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> contents of the<ins> ERR&lt;n>MISC&lt;m> registers contains additional information for an error recorded by this record.</ins><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del> and </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><del> registers contains additional information for an error recorded by this record.</del></p></td></tr></table><p>This bit ignores writes if <del>any of </del>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and the highest priority of these is not being cleared to 0 in the same write.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><div class="note"><span class="note-header">Note</span><p>If the<ins> ERR&lt;n>MISC&lt;m> registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</ins><a href="ext-errnmisc0.html"><del>ERR&lt;n>MISC0</del></a><del> and </del><a href="ext-errnmisc1.html"><del>ERR&lt;n>MISC1</del></a><del> registers can contain additional information for a previously recorded error, then the contents must be self-describing to software or a user. For example, certain fields might relate only to Corrected errors, and other fields only to the most recent error that was not discarded.</del></p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_0_26"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><h4 id="WhenRASSystemArchitecturev1.0isimplemented_CE_25">CE, bits [25:24]
                  </h4><p>Corrected Error.</p><table class="valuetable"><tr><th>CE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>No errors were corrected.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>At least one transient error was corrected.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>At least one error was corrected.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>At least one persistent error was corrected.</p></td></tr></table><p>The mechanism by which a node detects whether a correctable error is transient or persistent is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>. If no such mechanism is implemented, then the node sets this field to <span class="binarynumber">0b10</span> when an error is corrected.</p><p><del>If ERR&lt;n>STATUS.V is set to 0, this field is not valid and reads </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del>.</del></p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this field is nonzero, then software must write ones to this field to clear this field to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this field is nonzero, then software must write ones to this field to clear this field to zero.</ins></p><p><ins>This</ins><del>If</del> <ins>field</ins><del>ERR&lt;n>STATUS.OF</del> is <ins>not</ins><del>set</del> <ins>valid</ins><del>to</del> <del>1 </del>and <ins>reads</ins><del>is not being cleared to 0 in the same write, this field ignores writes.</del> <span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> if ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>. This field ignores writes if ERR&lt;n>STATUS.OF == </ins><span class="binarynumber"><ins>0b1</ins></span><ins> and is not being cleared to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> in the same write.</ins></p><p>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <span class="arm-defined-word">UNKNOWN</span> value.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_DE_23">DE, bit [23]
              </h4><p>Deferred Error.</p><table class="valuetable"><tr><th>DE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No errors were deferred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>At least one error was not corrected and deferred.</p></td></tr></table><p>Support for deferring errors is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p><del>If ERR&lt;n>STATUS.V is set to 0, this bit is not valid and reads </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del>.</del></p><p>When clearing ERR&lt;n>STATUS.V to<del> 0, if this bit is nonzero, then software must write 1 to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>, if this bit is nonzero, then software must write </ins><span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero.</ins></p><p><ins>This</ins><del>If</del> <ins>bit</ins><del>ERR&lt;n>STATUS.OF</del> is <ins>not</ins><del>set</del> <ins>valid</ins><del>to</del> <del>1 </del>and <ins>reads</ins><del>is not being cleared to 0 in the same write, this bit ignores writes.</del> <span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> if ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>. This bit ignores writes if ERR&lt;n>STATUS.OF == </ins><span class="binarynumber"><ins>0b1</ins></span><ins> and is not being cleared to </ins><span class="binarynumber"><ins>0b0</ins></span><ins> in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_PN_22">PN, bit [22]
              </h4><p>Poison.</p><table class="valuetable"><tr><th>PN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Uncorrected error or Deferred error recorded because a corrupt value was detected, for example, by an error detection code (EDC).</p><div class="note"><span class="note-header">Note</span><p>If a producer node detects a corrupt value and defers the error by producing a poison value, then this bit is set to<del> 0 at the producer node.</del> <span class="binarynumber"><ins>0b0</ins></span><ins> at the producer node.</ins></p></div></td></tr><tr><td class="bitfield">0b1</td><td><p>Uncorrected error or Deferred error recorded because a poison value was detected.</p><div class="note"><span class="note-header">Note</span><p>This might only be an indication of poison, because, in some EDC schemes, a poison value is encoded as an unlikely form of corrupt data, meaning it is possible to mistake a corrupt value as a poison value.</p></div></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether a node can distinguish a poison value from a corrupt value.</p><p><ins>If</ins><del>When</del> <del>clearing ERR&lt;n>STATUS.V to 0, if </del>this bit is nonzero, then software must write<del> 1 to this bit to clear this bit to zero.</del> <span class="binarynumber"><ins>0b1</ins></span><ins> to this bit to clear this bit to zero, when any of:</ins></p><p><del>When clearing both ERR&lt;n>STATUS.{DE, UE} to 0, if this bit is nonzero, then software must write 1 to this bit to clear this bit to zero.</del></p><ul><li><ins>Clearing ERR&lt;n>STATUS.V to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><ins>Clearing both ERR&lt;n>STATUS.{DE, UE} to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li></ul><p>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><p><del>ERR&lt;n>STATUS.{DE, UE} are both set to 0.</del></p><ins>ERR&lt;n>STATUS.{DE,UE} == {0,0}.
</ins></li></ul><p><ins>This</ins><del>When</del> <ins>bit</ins><del>any</del> <ins>ignores</ins><del>of</del> <ins>writes if </ins>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and the highest priority of these is not being cleared to 0 in the same write, this bit ignores writes.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>This bit is read/write-one-to-clear.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_UET_21">UET, bits [21:20]
                  </h4><p><del>Describes the state of the component after detecting or consuming an Uncorrected error.</del></p><p>Uncorrected Error Type.<ins> Describes the state of the component after detecting or consuming an Uncorrected error.</ins></p><table class="valuetable"><tr><th>UET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Uncorrected error, Uncontainable error (UC).</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Uncorrected error, Unrecoverable error (UEU).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Uncorrected error, Latent or Restartable error (UEO).</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Uncorrected error, Signaled or Recoverable error (UER).</p></td></tr></table><p><ins>If</ins><del>When</del> <del>clearing ERR&lt;n>STATUS.V to 0, if </del>this field is nonzero, then software must write ones to this field to clear this field to <ins>zero, when any of:</ins><del>zero.</del></p><p><del>When clearing ERR&lt;n>STATUS.UE to 0, if this field is nonzero, then software must write ones to this field to clear this field to zero.</del></p><ul><li><ins>Clearing ERR&lt;n>STATUS.V to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><ins>Clearing ERR&lt;n>STATUS.UE to </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li></ul><p>This field is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if any of the following are true:</p><ul><li><ins>ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.V is set to 0.</del></p></li><li><ins>ERR&lt;n>STATUS.UE == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>.
</ins></li><li><p><del>ERR&lt;n>STATUS.UE is set to 0.</del></p></li></ul><p><ins>This</ins><del>When</del> <ins>field</ins><del>any</del> <ins>ignores</ins><del>of</del> <ins>writes if </ins>ERR&lt;n>STATUS.{CE,<del> </del>DE,<del> </del>UE} <ins>!=</ins><del>are</del> <ins>{</ins><del>set to 1, and the highest priority of these is not being cleared to 0 in the same write, this field ignores writes.</del><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>This field is read/write-ones-to-clear. Writing a value other than all-zeros or all-ones sets this field to an <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="note"><span class="note-header"><ins class="nocount">Note</ins></span><p><ins>Software might use the information in the error record registers to determine what recovery is necessary.</ins></p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_0_19">
                Bits [19:16]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenRASSystemArchitecturev1.0isimplemented_IERR_15">IERR, bits [15:8]
                  </h4><p><del>This field is not valid and reads </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> if ERR&lt;n>STATUS.V is set to 0.</del></p><p><del>When any of ERR&lt;n>STATUS.{CE, DE, UE} are set to 1, and the highest priority of these is not being cleared to 0 in the same write, this field ignores writes.</del></p><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> error code.<ins> Used with any primary error code SERR value. Further</ins> <span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> information can be placed in the MISC registers.</ins></p><p><ins>This</ins><del>Used</del> <ins>field</ins><del>with</del> <ins>is</ins><del>any</del> <ins>not</ins><del>primary</del> <ins>valid</ins><del>error</del> <ins>and</ins><del>code</del> <ins>reads</ins><del>SERR value. Further</del> <span class="arm-defined-word"><ins>UNKNOWN</ins><del>IMPLEMENTATION DEFINED</del></span><ins> if ERR&lt;n>STATUS.V == </ins><span class="binarynumber"><ins>0b0</ins></span><ins>. This field ignores writes if ERR&lt;n>STATUS.{CE,DE,UE} != {</ins><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0},</ins><del>information</del> <ins>and</ins><del>can</del> <ins>the</ins><del>be</del> <ins>highest</ins><del>placed</del> <ins>priority of these is not being cleared to zero </ins>in the <ins>same</ins><del>MISC</del> <ins>write.</ins><del>registers.</del></p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="WhenRASSystemArchitecturev1.0isimplemented_SERR_7">SERR, bits [7:0]
                  </h4><p><del>Indicates the type of error. The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</del></p><p>Architecturally-defined primary error code.<ins> The primary error code might be used by a fault handling agent to triage an error without requiring device-specific code. For example, to count and threshold corrected errors in software, or generate a short log entry.</ins></p><table class="valuetable"><tr><th>SERR</th><th>Meaning</th></tr><tr><td class="bitfield">0x00</td><td><p>No error.</p></td></tr><tr><td class="bitfield">0x01</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> error.</p></td></tr><tr><td class="bitfield">0x02</td><td><p>Data value from (non-associative) internal memory. For example, ECC from on-chip SRAM or buffer.</p></td></tr><tr><td class="bitfield">0x03</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> pin. For example, <span class="signal">nSEI</span> pin.</p></td></tr><tr><td class="bitfield">0x04</td><td><p>Assertion failure. For example, consistency failure.</p></td></tr><tr><td class="bitfield">0x05</td><td><p>Error detected on internal data path. For example, parity on ALU result.</p></td></tr><tr><td class="bitfield">0x06</td><td><p>Data value from associative memory. For example, ECC error on cache data.</p></td></tr><tr><td class="bitfield">0x07</td><td><p>Address/control value from associative memory. For example, ECC error on cache tag.</p></td></tr><tr><td class="bitfield">0x08</td><td><p>Data value from a TLB. For example, ECC error on TLB data.</p></td></tr><tr><td class="bitfield">0x09</td><td><p>Address/control value from a TLB. For example, ECC error on TLB tag.</p></td></tr><tr><td class="bitfield">0x0A</td><td><p>Data value from producer. For example, parity error on write data bus.</p></td></tr><tr><td class="bitfield">0x0B</td><td><p>Address/control value from producer. For example, parity error on address bus.</p></td></tr><tr><td class="bitfield">0x0C</td><td><p>Data value from (non-associative) external memory. For example, ECC error in SDRAM.</p></td></tr><tr><td class="bitfield">0x0D</td><td><p>Illegal address (software fault). For example, access to unpopulated memory.</p></td></tr><tr><td class="bitfield">0x0E</td><td><p>Illegal access (software fault). For example, byte write to word register.</p></td></tr><tr><td class="bitfield">0x0F</td><td><p>Illegal state (software fault). For example, device not ready.</p></td></tr><tr><td class="bitfield">0x10</td><td><p>Internal data register. For example, parity on a SIMD&amp;FP register. For a PE, all general-purpose, stack pointer, <del>and </del>SIMD&amp;FP<ins>, and SVE</ins> registers are data registers.</p></td></tr><tr><td class="bitfield">0x11</td><td><p>Internal control register. For example, Parity on a System register. For a PE, all registers other than general-purpose, stack pointer, <del>and </del>SIMD&amp;FP<ins>, and SVE</ins> registers are control registers.</p></td></tr><tr><td class="bitfield">0x12</td><td><p>Error response from slave. For example, error response from cache write-back.</p></td></tr><tr><td class="bitfield">0x13</td><td><p>External timeout. For example, timeout on interaction with another node.</p></td></tr><tr><td class="bitfield">0x14</td><td><p>Internal timeout. For example, timeout on interface within the node.</p></td></tr><tr><td class="bitfield">0x15</td><td><p>Deferred error from slave not supported at master. For example, poisoned data received from a slave by a master that cannot defer the error further.</p></td></tr><tr><td class="bitfield"><ins>0x16</ins></td><td><p><ins>Deferred error from master not supported at slave. For example, poisoned data received from a master by a slave that cannot defer the error further.</ins></p></td></tr><tr><td class="bitfield"><ins>0x17</ins></td><td><p><ins>Deferred error from slave passed through. For example, poisoned data received from a slave and returned to a master.</ins></p></td></tr><tr><td class="bitfield"><ins>0x18</ins></td><td><p><ins>Deferred error from master passed through. For example, poisoned data received from a master and deferred to a slave.</ins></p></td></tr><tr><td class="bitfield"><ins>0x19</ins></td><td><p><ins>Error recorded by PCIe error logs. Indicates that the node has recorded an error in a PCIe error log. This might be the PCIe device status register, AER, DVSEC, or other mechanisms defined by PCIe.</ins></p></td></tr></table><p><del>When any of ERR&lt;n>STATUS.{CE, DE, UE} are set to 1, and the highest priority of these is not being cleared to 0 in the same write, this field ignores writes.</del></p><p>All other values are reserved.<del> Reserved values might be defined in a future version of the architecture.</del></p><p>This field is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if ERR&lt;n>STATUS.V <ins>==</ins><del>is set to 0.</del> <span class="binarynumber"><ins>0b0</ins></span><ins>. This field ignores writes if ERR&lt;n>STATUS.{CE,DE,UE} != {</ins><span class="binarynumber"><ins>0b00</ins></span><ins>,0,0}, and the highest priority of these is not being cleared to zero in the same write.</ins></p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>field</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><div class="text_after_fields"></div><h2>Accessing the ERR&lt;n>STATUS</h2><p><ins>The</ins><del>After</del> <ins>{AV,</ins><del>reading</del> <ins>V,</ins><del>the</del> <ins>UE,</ins><del>status</del> <ins>ER</ins><del>register</del>, <ins>OF,</ins><del>software</del> <ins>MV,</ins><del>must</del> <ins>CE,</ins><del>clear</del> <ins>DE,</ins><del>the</del> <ins>PN,</ins><del>valid</del> <ins>UET,</ins><del>bits</del> <ins>CI} fields are write-one-to-clear, meaning writes of zero are ignored, and a write of one or all-ones </ins>to <ins>the</ins><del>allow</del> <ins>field</ins><del>new</del> <ins>clears</ins><del>errors</del> <ins>the field </ins>to <ins>zero. The {IERR, SERR} fields are read/write fields, although the set of permitted values that can </ins>be <ins>written to the fields is</ins><del>recorded.</del> <span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins>.</ins></p><p><ins>After</ins><del>Between</del> reading <ins>ERR&lt;n>STATUS, software must clear </ins>the <ins>valid bits in the </ins>register <ins>to allow new errors to be recorded. However, between reading the register </ins>and clearing the valid bits, a new error might have overwritten the register. To prevent this <del>new </del>error being lost<ins> by software, the register prevents updates to fields that might have been updated by a new error.</ins><del>:</del></p><p><ins>When RAS System Architecture v1.0 is implemented:</ins></p><ul><li><p><del>When ARMv8.4-RAS is not implemented, some control bits use a form of read/write-one-to-clear and ignore writes depending on the values of other bits and which bits are being cleared.</del></p><ins>Writes to the {UE, DE, CE} fields are ignored if the OF bit is set and is not being cleared.
</ins></li><li><p><del>When ARMv8.4-RAS is implemented, a write to ERR&lt;n>STATUS is ignored if both:</del></p><ul><li><p><del>Any of the ERR&lt;n>STATUS.{V, UE, OF, CE, DE} fields are nonzero before the write.</del></p></li><li><p><del>The write does not clear the nonzero ERR&lt;n>STATUS.{V, UE, OF, CE, DE} field(s) to zero by writing one(s) to the applicable field(s).</del></p></li></ul><ins>Writes to the V bit are ignored if any of the {UE, DE, CE} fields are nonzero and are not being cleared.
</ins></li><li><ins>Writes to the {AV, MV} bits and {ER, PN, UET, IERR, SERR} syndrome fields are ignored if the highest priority error status field is nonzero and not being cleared. The error status fields in priority order from highest to lowest, are UE, DE, and CE.
</ins></li></ul><p><ins>When</ins><del>Software</del> <ins>RAS</ins><del>must</del> <ins>System</ins><del>write</del> <ins>Architecture</ins><del>ones</del> <ins>v1.1</ins><del>to</del> <ins>is</ins><del>the</del> <ins>implemented</ins><del>{ER</del>, <ins>a</ins><del>PN,</del> <ins>write</ins><del>UET,</del> <ins>to</ins><del>CI}</del> <ins>the</ins><del>fields</del> <ins>register</ins><del>when</del> <ins>is</ins><del>clearing</del> <ins>ignored</ins><del>ERR&lt;n>STATUS.{V,</del> <ins>if</ins><del>UE,</del> <ins>all</ins><del>OF,</del> <ins>of:</ins><del>CE, DE}.</del></p><ul><li><ins>Any of {V, UE, OF, CE, DE} fields are nonzero before the write.
</ins></li><li><ins>The write does not clear the nonzero {V, UE, OF, CE, DE} fields to zero by writing ones to the applicable field or fields.
</ins></li></ul><p><ins>To ensure correct and portable operation, when software is clearing the valid bits in the register to allow new errors to be recorded, software must:</ins></p><ul><li><ins>Determine which fields must be cleared to zero by reading ERR&lt;n>STATUS.
</ins></li><li><ins>Write ones to all the write-one-to-clear fields that are nonzero.
</ins></li><li><ins>Write zero to all the read/write fields.
</ins></li><li><ins>Write zero to all the write-one-to-clear fields that are zero.
</ins></li></ul><h4>ERR&lt;n>STATUS can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>RAS</td><td><span class="hexnumber">0x010</span> + 64n</td><td>ERR&lt;n>STATUS</td></tr></table><p>Accesses on this interface are <span class="access_level">RW</span>.</p><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>