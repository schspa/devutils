<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>SCTLR_EL3</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SCTLR_EL3, System Control Register (EL3)</h1><p>The SCTLR_EL3 characteristics are:</p><h2>Purpose</h2><p>Provides top level control of the system, including its memory system, at EL3.</p><h2>Configuration</h2><p><del>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into EL3 using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> values.
              </del></p><p>This register is present only
    when <del>HaveEL(</del>EL3<ins> is implemented.</ins><del>).</del>
      
    Otherwise, direct accesses to SCTLR_EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>SCTLR_EL3 is a 64-bit register.</p><h2>Field descriptions</h2><p>The SCTLR_EL3 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="19"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#DSSBS_44">DSSBS</a></td><td class="lr" colspan="1"><a href="#ATA_43">ATA</a></td><td class="lr" colspan="1"><a href="#0_42">RES0</a></td><td class="lr" colspan="2"><a href="#TCF_41">TCF</a></td><td class="lr" colspan="2"><a href="#0_39">RES0</a></td><td class="lr" colspan="1"><a href="#ITFSB_37">ITFSB</a></td><td class="lr" colspan="1"><a href="#BT_36">BT</a></td><td class="lr" colspan="4"><a href="#0_35">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#EnIA_31">EnIA</a></td><td class="lr" colspan="1"><a href="#EnIB_30">EnIB</a></td><td class="lr" colspan="2"><a href="#1_29">RES1</a></td><td class="lr" colspan="1"><a href="#EnDA_27">EnDA</a></td><td class="lr" colspan="1"><a href="#0_26">RES0</a></td><td class="lr" colspan="1"><a href="#EE_25">EE</a></td><td class="lr" colspan="1"><a href="#0_24">RES0</a></td><td class="lr" colspan="1"><a href="#1_23">RES1</a></td><td class="lr" colspan="1"><a href="#EIS_22">EIS</a></td><td class="lr" colspan="1"><a href="#IESB_21">IESB</a></td><td class="lr" colspan="1"><a href="#0_20">RES0</a></td><td class="lr" colspan="1"><a href="#WXN_19">WXN</a></td><td class="lr" colspan="1"><a href="#1_18">RES1</a></td><td class="lr" colspan="1"><a href="#0_17">RES0</a></td><td class="lr" colspan="1"><a href="#1_16">RES1</a></td><td class="lr" colspan="2"><a href="#0_15">RES0</a></td><td class="lr" colspan="1"><a href="#EnDB_13">EnDB</a></td><td class="lr" colspan="1"><a href="#I_12">I</a></td><td class="lr" colspan="1"><a href="#EOS_11">EOS</a></td><td class="lr" colspan="4"><a href="#0_10">RES0</a></td><td class="lr" colspan="1"><a href="#nAA_6">nAA</a></td><td class="lr" colspan="2"><a href="#1_5">RES1</a></td><td class="lr" colspan="1"><a href="#SA_3">SA</a></td><td class="lr" colspan="1"><a href="#C_2">C</a></td><td class="lr" colspan="1"><a href="#A_1">A</a></td><td class="lr" colspan="1"><a href="#M_0">M</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="0_63">
                Bits [63:45]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="DSSBS_44">DSSBS, bit [44]
              <div style="font-size:smaller;"><br/>When ARMv8.0-SSBS is implemented:
                </div></h4><p>Default PSTATE.SSBS value on Exception Entry.</p><table class="valuetable"><tr><th>DSSBS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>PSTATE.SSBS is set to 0 on an exception to EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>PSTATE.SSBS is set to 1 on an exception to EL3.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0_44"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ATA_43">ATA, bit [43]
              <div style="font-size:smaller;"><br/>When ARMv8.5-MemTag is implemented:
                </div></h4><p>Allocation Tag Access in EL3. Controls EL3 access to Allocation Tags.</p><p>When access to Allocation Tags is prevented:</p><ul><li><p>Instructions which Load or Store data are Unchecked.</p></li><li><p>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</p></li><li><p>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</p></li><li><p>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</p></li></ul><table class="valuetable"><tr><th>ATA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Access to Allocation Tags is prevented.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Access to Allocation Tags is not prevented.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_43"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_42">
                Bit [42]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TCF_41">TCF, bits [41:40]
                  <div style="font-size:smaller;"><br/>When ARMv8.5-MemTag is implemented:
                </div></h4><p>Tag Check <ins>Fault</ins><del>Fail</del> in EL3. Controls the effect of <ins>Tag</ins><del>tag</del> <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> due to Loads and Stores in EL3.</p><table class="valuetable"><tr><th>TCF</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Tag <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> have no effect on the PE.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Tag <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> causes a synchronous exception.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Tag <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> are asynchronously accumulated.</p></td></tr></table><p>The value <span class="binarynumber">0b11</span> is reserved.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_41"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_39">
                Bits [39:38]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ITFSB_37">ITFSB, bit [37]
              <div style="font-size:smaller;"><br/>When ARMv8.5-MemTag is implemented:
                </div></h4><p>When asynchronous exceptions are being generated by Tag Check <ins>Faults</ins><del>fails</del> which are generated for Loads and Stores at any exception level, controls the auto-synchronisaton of Tag Check <ins>Faults</ins><del>fails</del> into <a href="AArch64-tfsre0_el1.html">TFSRE0_EL1</a> and <a href="AArch64-tfsr_elx.html">TFSR_ELx</a>.</p><table class="valuetable"><tr><th>ITFSB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Tag <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> are not synchronized on entry to EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Tag <ins>Check</ins><del>check</del> <ins>Faults</ins><del>fails</del> are synchronized on entry to EL3.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_37"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="BT_36">BT, bit [36]
              <div style="font-size:smaller;"><br/>When ARMv8.5-BTI is implemented:
                </div></h4><p>PAC Branch Type compatibility at EL3.</p><table class="valuetable"><tr><th>BT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When the PE is executing at EL3, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When the PE is executing at EL3, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <span class="binarynumber">0b11</span>.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_36"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_35">
                Bits [35:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EnIA_31">EnIA, bit [31]
              <div style="font-size:smaller;"><br/>When ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL3 translation regime.</p><p>Possible values of this bit are:</p><table class="valuetable"><tr><th>EnIA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is not enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is enabled.</p></td></tr></table><p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACIA and AuthIA pseudocode functions. Specifically, when the field is 1, AddPACIA returns a copy of a pointer to which a pointer authentication code has been added, and AuthIA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_31"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EnIB_30">EnIB, bit [30]
              <div style="font-size:smaller;"><br/>When ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL3 translation regime.</p><p>Possible values of this bit are:</p><table class="valuetable"><tr><th>EnIB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is not enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is enabled.</p></td></tr></table><p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACIB and AuthIB pseudocode functions. Specifically, when the field is 1, AddPACIB returns a copy of a pointer to which a pointer authentication code has been added, and AuthIB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_30"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="1_29">
                Bits [29:28]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="EnDA_27">EnDA, bit [27]
              <div style="font-size:smaller;"><br/>When ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL3 translation regime.</p><table class="valuetable"><tr><th>EnDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Pointer authentication (using the APDAKey_EL1 key) of data addresses is not enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Pointer authentication (using the APDAKey_EL1 key) of data addresses is enabled.</p></td></tr></table><p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACDA and AuthDA pseudocode functions. Specifically, when the field is 1, AddPACDA returns a copy of a pointer to which a pointer authentication code has been added, and AuthDA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_27"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_26">
                Bit [26]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EE_25">EE, bit [25]
              </h4><p>Endianness of data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime.</p><table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Explicit data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime are little-endian.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Explicit data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime are big-endian.</p></td></tr></table><p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p><p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p><p>The EE bit is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL3, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0_24">
                Bit [24]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="1_23">
                Bit [23]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="EIS_22">EIS, bit [22]
              <div style="font-size:smaller;"><br/>When ARMv8.5-CSEH is implemented:
                </div></h4><p>Exception Entry is Context Synchronizing.</p><table class="valuetable"><tr><th>EIS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The taking of an exception to EL3 is not a context synchronizing event.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The taking of an exception to EL3 is a context synchronizing event.</p></td></tr></table><p>If SCTLR_EL3.EIS is set to <span class="binarynumber">0b0</span>:</p><ul><li>Indirect writes to <a href="AArch64-esr_el3.html">ESR_EL3</a>, <a href="AArch64-far_el3.html">FAR_EL3</a>, <a href="AArch64-spsr_el3.html">SPSR_EL3</a>, <a href="AArch64-elr_el3.html">ELR_EL3</a> are synchronized on exception entry to EL3, so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.
</li><li>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
</li><li>Exception Catch debug events are synchronous debug events.
</li><li>DCPS* and DRPS instructions are context synchronization events.
</li></ul><p>The following are not affected by the value of SCTLR_EL3.EIS:</p><ul><li>Changes to the PSTATE information on entry to EL3.
</li><li>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
</li><li>Debug state exit.
</li></ul><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_22"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="IESB_21">IESB, bit [21]
              <div style="font-size:smaller;"><br/>When ARMv8.2-IESB is implemented:
                </div></h4><p>Implicit Error Synchronization event enable.</p><table class="valuetable"><tr><th>IESB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An implicit error synchronization event is added:</p><ul><li><p>At each exception taken to EL3.</p></li><li><p>Before the operational pseudocode of each <span class="instruction">ERET</span> instruction executed at EL3.</p></li></ul></td></tr></table><p>When the PE is in Debug state, the effect of this field is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and its Effective value might be 0 or 1 regardless of the value of the field. If the Effective value of the field is 1, then an implicit  error synchronization event is added after each <span class="instruction">DCPSx</span> instruction taken to EL3 and before each <span class="instruction">DRPS</span> instruction executed at EL3, in addition to the other cases where it is added.</p><p>When ARMv8.4-DFE is implemented, and the Effective value of SCR_EL3.NMEA is 1, this field is ignored and its Effective value is 1.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_21"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_20">
                Bit [20]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WXN_19">WXN, bit [19]
              </h4><p>Write permission implies XN (Execute-never). For the EL3 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p><table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control has no effect on memory access permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any region that is writable in the EL3 translation regime is forced to XN for accesses from software executing at EL3.</p></td></tr></table><p>This bit applies only when SCTLR_EL3.M bit is set.</p><p>The WXN bit is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_18">
                Bit [18]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="0_17">
                Bit [17]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="1_16">
                Bit [16]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="0_15">
                Bits [15:14]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EnDB_13">EnDB, bit [13]
              <div style="font-size:smaller;"><br/>When ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL3 translation regime.</p><table class="valuetable"><tr><th>EnDB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Pointer authentication (using the APDBKey_EL1 key) of data addresses is not enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Pointer authentication (using the APDBKey_EL1 key) of data addresses is enabled.</p></td></tr></table><p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>This field controls the behavior of the AddPACDB and AuthDB pseudocode functions. Specifically, when the field is 1, AddPACDB returns a copy of a pointer to which a pointer authentication code has been added, and AuthDB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</p></div><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="I_12">I, bit [12]
              </h4><p>Instruction access Cacheability control, for accesses at EL3:</p><table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>All instruction access to Normal memory from EL3 are Non-cacheable for all levels of instruction and unified cache.</p><p>If the value of SCTLR_EL3.M is 0, instruction accesses from stage 1 of the EL3 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control has no effect on the Cacheability of instruction access to Normal memory from EL3.</p><p>If the value of SCTLR_EL3.M is 0, instruction accesses from stage 1 of the EL3 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p></td></tr></table><p>This bit has no effect on the EL1&amp;0, EL2, or EL2&amp;0 translation regimes.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="EOS_11">EOS, bit [11]
              <div style="font-size:smaller;"><br/>When ARMv8.5-CSEH is implemented:
                </div></h4><p>Exception Exit is Context Synchronizing.</p><table class="valuetable"><tr><th>EOS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>An exception return from EL3 is not a context synchronizing event</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An exception return from EL3 is a context synchronizing event</p></td></tr></table><p>If SCTLR_EL3.EOS is set to <span class="binarynumber">0b0</span>:</p><ul><li>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
</li><li>Exception Catch debug events are synchronous debug events.
</li><li>DCPS* and DRPS instructions are context synchronization events.
</li></ul><p>The following are not affected by the value of SCTLR_EL3.EOS:</p><ul><li>The indirect write of the PSTATE and PC values from <a href="AArch64-spsr_el3.html">SPSR_EL3</a> and <a href="AArch64-elr_el3.html">ELR_EL3</a> on exception return is synchronized. 
</li><li>If the PE enters Debug state before the first instruction after an Exception return from EL3 to Non-secure state, any pending Halting debug event completes execution.
</li><li>The GIC behavior that allocates interrupts to FIQ or IRQ changes simultaneously with leaving the EL3 Exception level.
</li><li>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
</li><li>Exit from Debug state.
</li></ul><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_11"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="0_10">
                Bits [10:7]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="nAA_6">nAA, bit [6]
              <div style="font-size:smaller;"><br/>When ARMv8.4-LSE is implemented:
                </div></h4><p>Non-aligned access. This bit controls generation of Alignment faults at EL3 under certain conditions.</p><table class="valuetable"><tr><th>nAA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes for accesses.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control bit does not cause LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, or STLURH to generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="1_5">
                Bits [5:4]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="SA_3">SA, bit [3]
              </h4><p>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL3 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1 (The AArch64 System Level Programmers' Model)</span>.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="C_2">C, bit [2]
              </h4><p>Cacheability control, for data accesses.</p><table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>All data access to Normal memory from EL3, and all Normal memory accesses to the EL3 translation tables, are Non-cacheable for all levels of data and unified cache.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control has no effect on the Cacheability of:</p><ul><li><p>Data access to Normal memory from EL3.</p></li><li><p>Normal memory accesses to the EL3 translation tables.</p></li></ul></td></tr></table><p>This bit has no effect on the EL1&amp;0, EL2, or EL2&amp;0 translation regimes.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="A_1">A, bit [1]
              </h4><p>Alignment check enable. This is the enable bit for Alignment fault checking at EL3.</p><table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Alignment fault checking disabled when executing at EL3.</p><p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Alignment fault checking enabled when executing at EL3.</p><p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p></td></tr></table><p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p><p>In a system where the PE resets into EL3, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="M_0">M, bit [0]
              </h4><p>MMU enable for EL3 stage 1 address translation. Possible values of this bit are:</p><table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL3 stage 1 address translation disabled.</p><p>See the SCTLR_EL3.I field for the behavior of instruction accesses to Normal memory.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL3 stage 1 address translation enabled.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the SCTLR_EL3</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, SCTLR_EL3</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    return SCTLR_EL3;
              </p><h4 class="assembler">MSR SCTLR_EL3, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    SCTLR_EL3 = X[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>