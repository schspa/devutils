<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>SCR_EL3</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SCR_EL3, Secure Configuration Register</h1><p>The SCR_EL3 characteristics are:</p><h2>Purpose</h2><p>Defines the configuration of the current Security state. It specifies:</p><ul><li>The Security state of EL0, EL1, and EL2. The Security state is either Secure or Non-secure.
</li><li>The Execution state at lower Exception levels.
</li><li>Whether IRQ, FIQ, SError interrupts, and External abort exceptions are taken to EL3.
</li><li>Whether various operations are trapped to EL3.
</li></ul><h2>Configuration</h2><p>AArch64 System register SCR_EL3 bits [31:0]
            
            can be mapped to
            AArch32 System register <a href="AArch32-scr.html">SCR[31:0]
            </a>, but this is not architecturally mandated.
          </p><p><del>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> values.
              </del></p><p>This register is present only
    when <del>HaveEL(</del>EL3<ins> is implemented.</ins><del>).</del>
      
    Otherwise, direct accesses to SCR_EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>SCR_EL3 is a 64-bit register.</p><h2>Field descriptions</h2><p>The SCR_EL3 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="28"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#AMVOFFEN_35">AMVOFFEN</a></td><td class="lr" colspan="1"><a href="#0_34">RES0</a></td><td class="lr" colspan="2"><a href="#TWEDEL_33">TWEDEL</a></td></tr><tr class="firstrow"><td class="lr" colspan="2"><a href="#TWEDEL_33">TWEDEL</a></td><td class="lr" colspan="1"><a href="#TWEDEn_29">TWEDEn</a></td><td class="lr" colspan="1"><a href="#ECVEn_28">ECVEn</a></td><td class="lr" colspan="1"><a href="#FGTEn_27">FGTEn</a></td><td class="lr" colspan="1"><a href="#ATA_26">ATA</a></td><td class="lr" colspan="1"><a href="#EnSCXT_25">EnSCXT</a></td><td class="lr" colspan="3"><a href="#0_24">RES0</a></td><td class="lr" colspan="1"><a href="#FIEN_21">FIEN</a></td><td class="lr" colspan="1"><a href="#NMEA_20">NMEA</a></td><td class="lr" colspan="1"><a href="#EASE_19">EASE</a></td><td class="lr" colspan="1"><a href="#EEL2_18">EEL2</a></td><td class="lr" colspan="1"><a href="#API_17">API</a></td><td class="lr" colspan="1"><a href="#APK_16">APK</a></td><td class="lr" colspan="1"><a href="#TERR_15">TERR</a></td><td class="lr" colspan="1"><a href="#TLOR_14">TLOR</a></td><td class="lr" colspan="1"><a href="#TWE_13">TWE</a></td><td class="lr" colspan="1"><a href="#TWI_12">TWI</a></td><td class="lr" colspan="1"><a href="#ST_11">ST</a></td><td class="lr" colspan="1"><a href="#RW_10">RW</a></td><td class="lr" colspan="1"><a href="#SIF_9">SIF</a></td><td class="lr" colspan="1"><a href="#HCE_8">HCE</a></td><td class="lr" colspan="1"><a href="#SMD_7">SMD</a></td><td class="lr" colspan="1"><a href="#0_6">RES0</a></td><td class="lr" colspan="2"><a href="#1_5">RES1</a></td><td class="lr" colspan="1"><a href="#EA_3">EA</a></td><td class="lr" colspan="1"><a href="#FIQ_2">FIQ</a></td><td class="lr" colspan="1"><a href="#IRQ_1">IRQ</a></td><td class="lr" colspan="1"><a href="#NS_0">NS</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="0_63">
                Bits [63:36]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="AMVOFFEN_35">AMVOFFEN, bit [35]
              <div style="font-size:smaller;"><br/>When ARMv8.6-AMU is implemented:
                </div></h4><p>Activity Monitors Virtual Offsets Enable.</p><table class="valuetable"><tr><th>AMVOFFEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses to <a href="AArch64-amevcntvoff0n_el2.html">AMEVCNTVOFF0&lt;n>_EL2</a> and <a href="AArch64-amevcntvoff1n_el2.html">AMEVCNTVOFF1&lt;n>_EL2</a> at EL2 are trapped to EL3. Indirect reads of the virtual offset registers are zero.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to <a href="AArch64-amevcntvoff0n_el2.html">AMEVCNTVOFF0&lt;n>_EL2</a> and <a href="AArch64-amevcntvoff1n_el2.html">AMEVCNTVOFF1&lt;n>_EL2</a> are not affected by this field.</p></td></tr></table><p><ins>This field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="0_35"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_34">
                Bit [34]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TWEDEL_33">TWEDEL, bits [33:30]
                  <div style="font-size:smaller;"><br/>When ARMv8.6-TWED is implemented:
                </div></h4><p>TWE Delay. A 4-bit unsigned number that, when SCR_EL3.TWEDEn is 1, encodes the minimum delay in taking a trap of WFE caused by SCR_EL3.TWE as 2^(TWEDEL + 8) cycles.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_33"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TWEDEn_29">TWEDEn, bit [29]
              <div style="font-size:smaller;"><br/>When ARMv8.6-TWED is implemented:
                </div></h4><p>TWE Delay Enable. Enables a configurable delayed trap of the WFE instruction caused by SCR_EL3.TWE.</p><table class="valuetable"><tr><th>TWEDEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The delay for taking a WFE trap is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The delay for taking a WFE trap is at least the number of cycles defined in SCR_EL3.TWEDEL.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_29"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ECVEn_28">ECVEn, bit [28]
              <div style="font-size:smaller;"><br/>When ARMv8.6-ECV is implemented:
                </div></h4><p>ECV Enable. Enables access to the <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> register.</p><table class="valuetable"><tr><th>ECVEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL2 accesses to <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> are trapped to EL3, and the value of <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> is treated as 0 for all purposes other than direct reads or writes to the register from EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL2 accesses to <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> are not trapped to EL3 by this mechanism.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_28"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FGTEn_27">FGTEn, bit [27]
              <div style="font-size:smaller;"><br/>When ARMv8.6-FGT is implemented:
                </div></h4><p>Enables access to the Fine-Grained Traps registers: <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a>.</p><table class="valuetable"><tr><th>FGTEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL2 Accesses to <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> registers are trapped to EL3, and those registers behave as if all bits are set to 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL2 Accesses to <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> registers are not trapped to EL3 by this mechanism.</p></td></tr></table><p>Traps caused by accesses to the fine-grained trap registers are reported using the EC code of <span class="hexnumber">0x18</span> and its associated ISS.</p><h4 id="0_27"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ATA_26">ATA, bit [26]
              <div style="font-size:smaller;"><br/>When ARMv8.5-MemTag is implemented:
                </div></h4><p>Allocation Tag Access. Controls access at EL2, EL1 and EL0 to Allocation Tags.</p><p>When access is prevented:</p><ul><li><p>Instructions which Load or Store data are Unchecked.</p></li><li><p>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</p></li><li><p>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</p></li><li><p>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</p></li><li><p>MRS and MSR instructions at EL1 and EL2 using <a href="AArch64-gcr_el1.html">GCR_EL1</a>, <a href="AArch64-rgsr_el1.html">RGSR_EL1</a>, <a href="AArch64-tfsr_el1.html">TFSR_EL1</a>, <a href="AArch64-tfsr_el2.html">TFSR_EL2</a> or <a href="AArch64-tfsre0_el1.html">TFSRE0_EL1</a> that are not <span class="arm-defined-word">UNDEFINED</span> or trapped to a lower Exception level are trapped to EL3.</p></li><li><p>MRS and MSR instructions at EL2 using <a href="AArch64-tfsr_el1.html">TFSR_EL12</a> that are not <span class="arm-defined-word">UNDEFINED</span> are trapped to EL3.</p></li></ul><table class="valuetable"><tr><th>ATA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Access is prevented.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Access is not prevented.</p></td></tr></table><p>This field is permitted to be cached in a TLB.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_26"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EnSCXT_25">EnSCXT, bit [25]
              <div style="font-size:smaller;"><br/>When ARMv8.0-CSV2 is implemented:
                </div></h4><p>Enable access to the <a href="AArch64-scxtnum_el2.html">SCXTNUM_EL2</a>, <a href="AArch64-scxtnum_el1.html">SCXTNUM_EL1</a>, and <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> registers. The defined values are:</p><table class="valuetable"><tr><th>EnSCXT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL2, EL1 and EL0 access to <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a>, EL2 and EL1 access to <a href="AArch64-scxtnum_el1.html">SCXTNUM_EL1</a>, EL2 access to <a href="AArch64-scxtnum_el2.html">SCXTNUM_EL2</a> registers are disabled by this mechanism, causing an exception to EL3, and the values of these registers to be treated as 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause accesses to <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a>, <a href="AArch64-scxtnum_el1.html">SCXTNUM_EL1</a>, <a href="AArch64-scxtnum_el2.html">SCXTNUM_EL2</a> to be trapped.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_25"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_24">
                Bits [24:22]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FIEN_21">FIEN, bit [21]
              <div style="font-size:smaller;"><br/>When ARMv8.4-RAS is implemented:
                </div></h4><p>Fault Injection enable. Trap accesses to the RAS ERX* registers <a href="AArch64-erxpfgcdn_el1.html">ERXPFGCDN_EL1</a>, <a href="AArch64-erxpfgctl_el1.html">ERXPFGCTL_EL1</a>, and <a href="AArch64-erxpfgf_el1.html">ERXPFGF_EL1</a> from EL1 and EL2 to EL3, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><table class="valuetable"><tr><th>FIEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses to the specified registers from EL1 and EL2 generate a Trap exception to EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><p>If EL3 is not implemented, the Effective value of SCR_EL3.FIEN is <span class="binarynumber">0b1</span>.</p><p>If <a href="AArch64-erridr_el1.html">ERRIDR_EL1</a>.NUM is zero, meaning no error records are implemented, or no error record accessible using System registers is owned by a node that implements the RAS Common Fault Injection Model Extension, then this bit might be <span class="arm-defined-word">RES0</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_21"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="NMEA_20">NMEA, bit [20]
              <div style="font-size:smaller;"><br/>When ARMv8.4-DFE is implemented:
                </div></h4><p>Non-maskable External Aborts. When <a href="AArch64-scr_el3.html">SCR_EL3</a>.EA == 1, controls whether PSTATE.A masks SError interrupts at EL3.</p><table class="valuetable"><tr><th>NMEA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If <a href="AArch64-scr_el3.html">SCR_EL3</a>.EA == 1, asserted SError interrupts are not taken at EL3 if PSTATE.A == 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If <a href="AArch64-scr_el3.html">SCR_EL3</a>.EA == 1, asserted SError interrupts are taken at EL3 regardless of the value of PSTATE.A.</p></td></tr></table><p>When SCR_EL3.EA == 0:</p><ul><li>Asserted SError interrupts are not taken at EL3 regardless of the value of PSTATE.A and this field.
</li><li>This field is ignored and its Effective value is 0.
</li></ul><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_20"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EASE_19">EASE, bit [19]
              <div style="font-size:smaller;"><br/>When ARMv8.4-DFE is implemented:
                </div></h4><p>External aborts to SError interrupt vector.</p><table class="valuetable"><tr><th>EASE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Synchronous External abort exceptions taken to EL3 are taken to the appropriate synchronous exception vector offset from <a href="AArch64-vbar_el3.html">VBAR_EL3</a>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Synchronous External abort exceptions taken to EL3 are taken to the appropriate SError interrupt vector offset from <a href="AArch64-vbar_el3.html">VBAR_EL3</a>.</p></td></tr></table><p>This field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_19"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="EEL2_18">EEL2, bit [18]
              <div style="font-size:smaller;"><br/>When ARMv8.4-SecEL2 is implemented:
                </div></h4><p>Secure EL2 Enable.</p><table class="valuetable"><tr><th>EEL2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>All behaviors associated with Secure EL2 are disabled. All registers, including timer registers, defined by <span class="xref">ARMv8.4-SecEL2</span> are <span class="arm-defined-word">UNDEFINED</span>, and those timers are disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>All behaviors associated with Secure EL2 are enabled.</p></td></tr></table><p>When the value of this bit is 1, then:</p><ul><li><p>When SCR_EL3.NS == 0, the SCR_EL3.RW bit is treated as 1 for all purposes other than reading or writing the register.</p></li><li><p>If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2, using the EC value of <a href="AArch64-esr_el2.html">ESR_EL2</a>.EC== <span class="hexnumber">0x3</span> :</p><ul><li>A read or write of the <a href="AArch32-scr.html">SCR</a>.
</li><li>A read or write of the <a href="AArch32-nsacr.html">NSACR</a>.
</li><li>A read or write of the <a href="AArch32-mvbar.html">MVBAR</a>.
</li><li>A read or write of the <a href="AArch32-sdcr.html">SDCR</a>.
</li><li>Execution of an ATS12NSO** instruction.
</li></ul></li><li><p>If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2 using the EC value of <a href="AArch64-esr_el2.html">ESR_EL2</a>.EC== <span class="hexnumber">0x0</span> :</p><ul><li>Execution of an SRS instruction that uses R13_mon.
</li><li>Execution of an MRS (Banked register) or MSR (Banked register) instruction that would access <a href="AArch32-spsr_mon.html">SPSR_mon</a>, R13_mon, or R14_mon.
</li></ul></li></ul><div class="note"><span class="note-header">Note</span><p>If the Effective value of SCR_EL3.EEL2 is 0, then these operations executed in Secure EL1 using AArch32 are trapped to EL3.</p></div><p>In a Secure only implementation that does not implement EL3 but implements EL2, behaves as if SCR_EL3.EEL2 == 1.</p><p>This bit is permitted to be cached in a TLB.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_18"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="API_17">API, bit [17]
              <div style="font-size:smaller;"><br/>When ARMv8.4-SecEL2 is implemented and ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls the use of the following instructions related to Pointer Authentication. Traps are reported using EC syndrome value <span class="hexnumber">0x09</span>:</p><ul><li>PACGA, which is always enabled.
</li><li>AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZB, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:<ul><li>In EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE==0 or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H==0, and the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N>&lt;M> == 1.
</li><li>In EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE==1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H==1, and the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N>&lt;M> == 1.
</li><li>In EL1, when the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N>&lt;M> == 1.
</li><li>In EL2, when the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N>&lt;M> == 1.
</li></ul></li></ul><table class="valuetable"><tr><th>API</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.API bit.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><p>An instruction is trapped only if Pointer Authentication is enabled for that instruction, for more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>If <span class="xref">ARMv8.3-PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="API_17"><div style="font-size:smaller;"><br/>When ARMv8.4-SecEL2 is not implemented and ARMv8.3-PAuth is implemented:
                </div></h4><p>Controls the use of instructions related to Pointer Authentication:</p><ul><li>PACGA.
</li><li>AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZ, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:<ul><li>In Non-secure EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE==0 or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H==0, and the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N>&lt;M>== 1.
</li><li>In Non-secure EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE==1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H==1, and the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N>&lt;M> == 1.
</li><li>In Secure EL0, when the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N>&lt;M> == 1.
</li><li>In Secure or Non-secure EL1, when the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N>&lt;M> == 1.
</li><li>In EL2, when the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N>&lt;M> == 1.
</li></ul></li></ul><table class="valuetable"><tr><th>API</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.API bit.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>If <span class="xref">ARMv8.3-PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_17"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="APK_16">APK, bit [16]
              <div style="font-size:smaller;"><br/>When ARMv8.3-PAuth is implemented:
                </div></h4><p>Trap registers holding "key" values for Pointer Authentication. Traps accesses to the following registers, using EC syndrome value <span class="hexnumber">0x18</span>, from EL1 or EL2 to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.APK bit or other traps:</p><ul><li><p><a href="AArch64-apiakeylo_el1.html">APIAKeyLo_EL1</a>, <a href="AArch64-apiakeyhi_el1.html">APIAKeyHi_EL1</a>, <a href="AArch64-apibkeylo_el1.html">APIBKeyLo_EL1</a>, <a href="AArch64-apibkeyhi_el1.html">APIBKeyHi_EL1</a>.</p></li><li><p><a href="AArch64-apdakeylo_el1.html">APDAKeyLo_EL1</a>, <a href="AArch64-apdakeyhi_el1.html">APDAKeyHi_EL1</a>, <a href="AArch64-apdbkeylo_el1.html">APDBKeyLo_EL1</a>, <a href="AArch64-apdbkeyhi_el1.html">APDBKeyHi_EL1</a>.</p></li><li><p><a href="AArch64-apgakeylo_el1.html">APGAKeyLo_EL1</a>, and <a href="AArch64-apgakeyhi_el1.html">APGAKeyHi_EL1</a>.</p></li></ul><table class="valuetable"><tr><th>APK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Access to the registers holding "key" values for pointer authentication from EL1 or EL2 are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.APK bit or other traps.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><p>For more information, see <span class="xref">'System register control of pointer authentication' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><div class="note"><span class="note-header">Note</span><p>If <span class="xref">ARMv8.3-PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_16"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TERR_15">TERR, bit [15]
              <div style="font-size:smaller;"><br/>When RAS is implemented:
                </div></h4><p>Trap Error record accesses. Accesses to the RAS ERR and RAS ERX registers from EL1 and EL2 to EL3 are trapped as follows:</p><ul><li><p>If EL1 is using AArch64, <a href="AArch64-erridr_el1.html">ERRIDR_EL1</a>, <a href="AArch64-errselr_el1.html">ERRSELR_EL1</a>, <a href="AArch64-erxaddr_el1.html">ERXADDR_EL1</a>, <a href="AArch64-erxctlr_el1.html">ERXCTLR_EL1</a>, <a href="AArch64-erxfr_el1.html">ERXFR_EL1</a>, <a href="AArch64-erxmisc0_el1.html">ERXMISC0_EL1</a>, <a href="AArch64-erxmisc1_el1.html">ERXMISC1_EL1</a>, and <a href="AArch64-erxstatus_el1.html">ERXSTATUS_EL1</a>, are trapped and reported using EC syndrome value <span class="hexnumber">0x18</span>.</p></li><li><p>If <span class="xref">ARMv8.4-RAS</span> is implemented, <a href="AArch64-erxmisc2_el1.html">ERXMISC2_EL1</a>, and <a href="AArch64-erxmisc3_el1.html">ERXMISC3_EL1</a>, are trapped and reported using EC syndrome value <span class="hexnumber">0x18</span>.</p></li><li><p>If EL1 is using AArch32, accesses by MCR or MRC to the following registers are reported using EC syndrome value <span class="hexnumber">0x03</span>, accesses by MCRR or MRRC are reported using EC syndrome value <span class="hexnumber">0x04</span>:</p><ul><li><a href="AArch32-erridr.html">ERRIDR</a>, <a href="AArch32-errselr.html">ERRSELR</a>, <a href="AArch32-erxaddr.html">ERXADDR</a>, <a href="AArch32-erxaddr2.html">ERXADDR2</a>, <a href="AArch32-erxctlr.html">ERXCTLR</a>, <a href="AArch32-erxctlr2.html">ERXCTLR2</a>, <a href="AArch32-erxfr.html">ERXFR</a>, <a href="AArch32-erxfr2.html">ERXFR2</a>, <a href="AArch32-erxmisc0.html">ERXMISC0</a>, <a href="AArch32-erxmisc1.html">ERXMISC1</a>, <a href="AArch32-erxmisc2.html">ERXMISC2</a>, <a href="AArch32-erxmisc3.html">ERXMISC3</a>, and <a href="AArch32-erxstatus.html">ERXSTATUS</a>.
</li></ul></li><li><p>If ARMv8.4-RAS is implemented, accesses by MCR or MRC to the following registers are reported using EC syndrome value <span class="hexnumber">0x03</span>, accesses by MCRR or MRRC are reported using EC syndrome value <span class="hexnumber">0x04</span>:</p><ul><li><a href="AArch32-erxmisc4.html">ERXMISC4</a>, <a href="AArch32-erxmisc5.html">ERXMISC5</a>, <a href="AArch32-erxmisc6.html">ERXMISC6</a>, and <a href="AArch32-erxmisc7.html">ERXMISC7</a>.
</li></ul></li></ul><table class="valuetable"><tr><th>TERR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to the specified registers from EL1 and EL2 generate a Trap exception to EL3.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_15"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TLOR_14">TLOR, bit [14]
              <div style="font-size:smaller;"><br/>When ARMv8.1-LOR is implemented:
                </div></h4><p>Trap LOR registers. Traps accesses to the <a href="AArch64-lorsa_el1.html">LORSA_EL1</a>, <a href="AArch64-lorea_el1.html">LOREA_EL1</a>, <a href="AArch64-lorn_el1.html">LORN_EL1</a>, <a href="AArch64-lorc_el1.html">LORC_EL1</a>, and <a href="AArch64-lorid_el1.html">LORID_EL1</a> registers from EL1 and EL2 to EL3, unless the access has been trapped to EL2.</p><table class="valuetable"><tr><th>TLOR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL1 and EL2 accesses to the LOR registers that are not <span class="arm-defined-word">UNDEFINED</span> are trapped to EL3, unless it is trapped <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TLOR.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_14"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TWE_13">TWE, bit [13]
              </h4><p>Traps EL2, EL1, and EL0 execution of WFE instructions to EL3, from both Security states and both Execution states, reported using EC syndrome value <span class="hexnumber">0x01</span>.</p><table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFE instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE, <a href="AArch32-hcr.html">HCR</a>.TWE, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.nTWE, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.nTWE, or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TWE.</p></td></tr></table><p>In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>For more information about when WFE instructions can cause the PE to enter a low-power state, see <span class="xref">'Wait for Event mechanism and Send event' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="TWI_12">TWI, bit [12]
              </h4><p>Traps EL2, EL1, and EL0 execution of WFI instructions to EL3, from both Security states and both Execution states, reported using EC syndrome value <span class="hexnumber">0x01</span>.</p><table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFI instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI, <a href="AArch32-hcr.html">HCR</a>.TWI, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.nTWI, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.nTWI, or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TWI.</p></td></tr></table><p>In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>For more information about when WFI instructions can cause the PE to enter a low-power state, see <span class="xref">'Wait for Interrupt' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="ST_11">ST, bit [11]
              </h4><p>Traps Secure EL1 accesses to the Counter-timer Physical Secure timer registers to EL3, from AArch64 state only, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><table class="valuetable"><tr><th>ST</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Secure EL1 using AArch64 accesses to the <a href="AArch64-cntps_tval_el1.html">CNTPS_TVAL_EL1</a>, <a href="AArch64-cntps_ctl_el1.html">CNTPS_CTL_EL1</a>, and <a href="AArch64-cntps_cval_el1.html">CNTPS_CVAL_EL1</a> are trapped to EL3 when Secure EL2 is disabled. If Secure EL2 is enabled, the behavior is as if the value of this field was <span class="binarynumber">0b1</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>Accesses to the Counter-timer Physical Secure timer registers are always enabled at EL3. These registers are not accessible at EL0.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="RW_10">RW, bit [10]
              <div style="font-size:smaller;"><br/><ins>When AArch32 is supported at any Exception level:
                </ins></div></h4><p>Execution state control for lower Exception levels.</p><table class="valuetable"><tr><th>RW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Lower levels are all AArch32.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The next lower level is AArch64.</p><p>If EL2 is present:</p><ul><li><p>EL2 is AArch64.</p></li><li><p>EL2 controls EL1 and EL0 behaviors.</p></li></ul><p>If EL2 is not present:</p><ul><li><p>EL1 is AArch64.</p></li><li><p>EL0 is determined by the Execution state described in the current process state when executing at EL0.</p></li></ul></td></tr></table><p>If AArch32 state is not supported by the implementation at EL2 and AArch32 state is not supported by the implementation at EL1, then this bit is RAO/WI.</p><p>If AArch32 state is supported by the implementation at EL1, SCR_EL3.NS == 1 and AArch32 state is not supported by the implementation at EL2, the Effective value of this bit is 1.</p><p>If AArch32 state is supported by the implementation at EL1, <span class="xref">ARMv8.4-SecEL2</span> is implemented and SCR_EL3.{EEL2, NS} == {1, 0}, the Effective value of this bit is 1.</p><p>This bit is permitted to be cached in a TLB.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="1_10"><div style="font-size:smaller;"><br/><ins>
              Otherwise:
            </ins></div></h4><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RAO/WI</ins></span><ins>.</ins></p><h4 id="SIF_9">SIF, bit [9]
              <div style="font-size:smaller;"><br/>When ARMv8.4-SecEL2 is implemented:
                </div></h4><p>Secure instruction fetch. When the PE is in Secure state, this bit disables instruction fetch from memory marked in the first stage of translation as being Non-secure. The possible values for this bit are:</p><table class="valuetable"><tr><th>SIF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Secure state instruction fetches from memory marked in the first stage of translation as being Non-secure are permitted.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Secure state instruction fetches from memory marked in the first stage of translation as being Non-secure are not permitted.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SIF_9"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Secure instruction fetch. When the PE is in Secure state, this bit disables instruction fetch from Non-secure memory.</p><table class="valuetable"><tr><th>SIF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Secure state instruction fetches from Non-secure memory are permitted.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Secure state instruction fetches from Non-secure memory are not permitted.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="HCE_8">HCE, bit [8]
              </h4><p>Hypervisor Call instruction enable. Enables HVC instructions at EL3 and, if EL2 is enabled in the current Security state, at EL2 and EL1, in both Execution states, reported using EC syndrome value <span class="hexnumber">0x00</span>.</p><table class="valuetable"><tr><th>HCE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>HVC instructions are <span class="arm-defined-word">UNDEFINED</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>HVC instructions are enabled at EL3, EL2, and EL1.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0 and, if Secure EL2 is disabled, at Secure EL1. Any resulting exception is taken from the current Exception level to the current Exception level.</p></div><p>If EL2 is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SMD_7">SMD, bit [7]
              </h4><p>Secure Monitor Call disable. Disables <span class="instruction">SMC</span> instructions at EL1 and above, from both Security states and both Execution states, reported using EC syndrome value <span class="hexnumber">0x00</span>.</p><table class="valuetable"><tr><th>SMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">SMC</span> instructions are enabled at EL3, EL2 and EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><span class="instruction">SMC</span> instructions are <span class="arm-defined-word">UNDEFINED</span>.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p><span class="instruction">SMC</span> instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0. Any resulting exception is taken from the current Exception level to the current Exception level.</p><p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC or <a href="AArch32-hcr.html">HCR</a>.TSC traps attempted EL1 execution of <span class="instruction">SMC</span> instructions to EL2, that trap has priority over this disable.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bit [6]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="1_5">
                Bits [5:4]
              </h4><p>Reserved, <span class="arm-defined-word">RES1</span>.</p><h4 id="EA_3">EA, bit [3]
              </h4><p>External Abort and SError interrupt routing.</p><table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, External aborts and SError interrupts are not taken to EL3.</p><p>In addition, when executing at EL3:</p><ul><li><p>SError interrupts are not taken.</p></li><li><p>External aborts are taken to EL3.</p></li></ul></td></tr><tr><td class="bitfield">0b1</td><td><p>When executing at any Exception level, External aborts and SError interrupts are taken to EL3.</p></td></tr></table><p>For more information, see <span class="xref">'Asynchronous exception routing' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1 (The AArch64 System Level Programmers' Model)</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="FIQ_2">FIQ, bit [2]
              </h4><p>Physical FIQ Routing.</p><table class="valuetable"><tr><th>FIQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, physical FIQ interrupts are not taken to EL3.</p><p>When executing at EL3, physical FIQ interrupts are not taken.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When executing at any Exception level, physical FIQ interrupts are taken to EL3.</p></td></tr></table><p>For more information, see <span class="xref">'Asynchronous exception routing' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IRQ_1">IRQ, bit [1]
              </h4><p>Physical IRQ Routing.</p><table class="valuetable"><tr><th>IRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, physical IRQ interrupts are not taken to EL3.</p><p>When executing at EL3, physical IRQ interrupts are not taken.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When executing at any Exception level, physical IRQ interrupts are taken to EL3.</p></td></tr></table><p>For more information, see <span class="xref">'Asynchronous exception routing' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="NS_0">NS, bit [0]
              </h4><p>Non-secure bit.</p><table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Indicates that EL0 and EL1 are in Secure state.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Indicates that Exception levels lower than EL3 are in Non-secure state, and so memory accesses from those Exception levels cannot access Secure memory.</p></td></tr></table><p>When SCR_EL3.{EEL2, NS} == {1, 0}, then EL2 is using AArch64 and in Secure state.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the SCR_EL3</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, SCR_EL3</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    return SCR_EL3;
              </p><h4 class="assembler">MSR SCR_EL3, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    SCR_EL3 = X[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>