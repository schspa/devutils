<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>ERR&lt;n>CTLR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">ERR&lt;n>CTLR, Error Record Control Register, n =
      0 - 65534</h1><p>The ERR&lt;n>CTLR characteristics are:</p><h2>Purpose</h2><p>The error control register contains enable bits for the node that writes to this record<del>, which</del>:</p><ul><li><p><del>Enable error recovery reporting as a read or write error response.</del></p></li><li><p><del>When ARMv.4-RAS is implemented, enable a critical error interrupt.</del></p></li><li><p><del>Enable error detection and correction.</del></p><ins>Enabling error detection and correction.
</ins></li><li><p><del>Enable an error recovery interrupt.</del></p><ins>Enabling the critical error, error recovery, and fault handling interrupts.
</ins></li><li><p><del>Enable a fault handling interrupt.</del></p><ins>Enabling in-band error response for Uncorrected errors.
</ins></li></ul><p>For each bit, if the selected node does not support the feature, then the bit is <span class="arm-defined-word">RES0</span>. The definition of each record is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><h2>Configuration</h2><p><del>The number of error records that are implemented is </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del>.</del></p><p><del>If error record &lt;n> is not implemented, or error record &lt;n> is not the first error record owned by the node, ERR&lt;n>CTLR is </del><span class="arm-defined-word"><del>RES0</del></span><del>.</del></p><p><ins>This</ins><del>Some</del> <ins>register</ins><del>or</del> <ins>is</ins><del>all</del> <ins>present</ins><del>RW</del> <ins>only
    when</ins><del>fields</del> <ins>error</ins><del>of</del> <ins>record</ins><del>this</del> <ins>&lt;n></ins><del>register</del> <ins>is</ins><del>have</del> <ins>implemented</ins><del>defined</del> <ins>and</ins><del>reset</del> <ins>error record &lt;n> is the first error record owned by a node.
      
    Otherwise, direct accesses to ERR&lt;n>CTLR are</ins><del>values.</del> <span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><p><a href="ext-errnfr.html">ERR&lt;n>FR</a> describes the features implemented by the node.</p><h2>Attributes</h2><p>ERR&lt;n>CTLR is a 64-bit register.</p><h2>Field descriptions</h2><p>The ERR&lt;n>CTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#IMPLEMENTATIONDEFINED_63">IMPLEMENTATION DEFINED</a></td></tr><tr class="firstrow"><td class="lr" colspan="18"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#CI_13">CI</a></td><td class="lr" colspan="1"><a href="#0_12">RES0</a></td><td class="lr" colspan="1"><a href="#WDUI_11">WDUI</a></td><td class="lr" colspan="1"><a href="#DUI_10">DUI</a></td><td class="lr" colspan="1"><a href="#WCFI_9">WCFI</a></td><td class="lr" colspan="1"><a href="#CFI_8">CFI</a></td><td class="lr" colspan="1"><a href="#WUE_7">WUE</a></td><td class="lr" colspan="1"><a href="#WFI_6">WFI</a></td><td class="lr" colspan="1"><a href="#WUI_5">WUI</a></td><td class="lr" colspan="1"><a href="#UE_4">UE</a></td><td class="lr" colspan="1"><a href="#FI_3">FI</a></td><td class="lr" colspan="1"><a href="#UI_2">UI</a></td><td class="lr" colspan="1"><a href="#IMPLEMENTATIONDEFINED_1">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#ED_0">ED</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="IMPLEMENTATIONDEFINED_63">IMPLEMENTATION DEFINED, bits [63:32]
                  </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>Reserved for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> controls. Must permit SBZP write policy for software.</p><p><del>This field reads as an </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> value and writes to this field have </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> behavior.</del></p><h4 id="0_31">
                Bits [31:14]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="CI_13">CI, bit [13]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.CI == 0b10:
                </div></h4><p><del>When enabled, the critical error interrupt is generated for a critical error condition.</del></p><p>Critical error interrupt enable.<ins> When enabled, the critical error interrupt is generated for a critical error condition.</ins></p><table class="valuetable"><tr><th>CI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Critical error interrupt not generated for critical errors. Critical errors are treated as Uncontained errors.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Critical error interrupt generated for critical errors.</p></td></tr></table><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_13"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_12">
                Bit [12]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WDUI_11">WDUI, bit [11]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.DUI == 0b11:
                </div></h4><p>Error recovery interrupt for deferred errors on writes enable.</p><p>When enabled, the error recovery interrupt is generated for <del>all </del>detected Deferred errors on writes.</p><table class="valuetable"><tr><th>WDUI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt not generated for deferred errors on writes.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt generated for deferred errors on writes.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_11"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="DUI_10">DUI, bit [10]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.DUI == 0b10:
                </div></h4><p>Error recovery interrupt for deferred errors enable.<del> This control applies to errors arising from both reads and writes.</del></p><p>When<del> enabled, an error recovery interrupt is generated for all detected Deferred errors.</del> <a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.DUI == </ins><span class="binarynumber"><ins>0b10</ins></span><ins>, this control applies to errors arising from both reads and writes.</ins></p><p><ins>When enabled, the error recovery interrupt is generated for all detected Deferred errors.</ins></p><table class="valuetable"><tr><th>DUI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt not generated for deferred errors.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt generated for deferred errors.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="RDUI_10"><div style="font-size:smaller;"><br/>When ERR&lt;n>FR.DUI == 0b11:
                </div></h4><p><del>When </del><a href="ext-errnfr.html"><del>ERR&lt;n>FR</del></a><del>.DUI == </del><span class="binarynumber"><del>0b11</del></span><del>, this field is named RDUI.</del></p><p>Error recovery interrupt for deferred errors on reads enable.</p><p>When<del> enabled, the error recovery interrupt is generated for all detected Deferred errors on reads.</del> <a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.DUI == </ins><span class="binarynumber"><ins>0b11</ins></span><ins>, this bit is named RDUI.</ins></p><p><ins>When enabled, the error recovery interrupt is generated for detected Deferred errors on reads.</ins></p><table class="valuetable"><tr><th>RDUI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt not generated for deferred errors on reads.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt generated for deferred errors on reads.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_10"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WCFI_9">WCFI, bit [9]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.CFI == 0b11:
                </div></h4><p>Fault handling interrupt for Corrected errors on writes enable.</p><p>When enabled:</p><ul><li>If the node implements Corrected error counters<ins> for writes</ins>, then the fault handling interrupt is generated when a counter overflows and the overflow bit for the counter is set to<del> 1. For more information, see</del> <span class="binarynumber"><ins>0b1</ins></span><ins>. For more information, see </ins><a href="ext-errnmisc0.html">ERR&lt;n>MISC0</a>.
</li><li>Otherwise, the fault handling interrupt is also generated for <del>all </del>detected Corrected errors <ins>onwrites.</ins><del>on writes.</del>
</li></ul><table class="valuetable"><tr><th>WCFI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt not generated for Corrected errors on writes.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt generated for Corrected errors on writes.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_9"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="CFI_8">CFI, bit [8]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.CFI == 0b10:
                </div></h4><p>Fault handling interrupt for Corrected errors enable.<del> This control applies to errors arising from both reads and writes.</del></p><p><ins>When </ins><a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.CFI == </ins><span class="binarynumber"><ins>0b10</ins></span><ins>, this control applies to errors arising from both reads and writes.</ins></p><p>When enabled:</p><ul><li>If the node implements Corrected error counters, then the fault handling interrupt is generated when a counter overflows and the overflow bit for the counter is set to<del> 1. For more information, see</del> <span class="binarynumber"><ins>0b1</ins></span><ins>. For more information, see </ins><a href="ext-errnmisc0.html">ERR&lt;n>MISC0</a>.
</li><li>Otherwise, the fault handling interrupt is <ins>also </ins>generated for all detected Corrected errors.
</li></ul><table class="valuetable"><tr><th>CFI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt not generated for Corrected errors.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt generated for Corrected errors.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="RCFI_8"><div style="font-size:smaller;"><br/>When ERR&lt;n>FR.CFI == 0b11:
                </div></h4><p><del>When </del><a href="ext-errnfr.html"><del>ERR&lt;n>FR</del></a><del>.CFI == </del><span class="binarynumber"><del>0b11</del></span><del>, this field is named RCFI.</del></p><p>Fault handling interrupt for Corrected errors on reads enable.</p><p><ins>When </ins><a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.CFI == </ins><span class="binarynumber"><ins>0b11</ins></span><ins>, this bit is named RCFI.</ins></p><p>When enabled:</p><ul><li>If the node implements Corrected error counters<ins> for reads</ins>, then the fault handling interrupt is generated when a counter overflows and the overflow bit for the counter is set to<del> 1. For more information, see</del> <span class="binarynumber"><ins>0b1</ins></span><ins>. For more information, see </ins><a href="ext-errnmisc0.html">ERR&lt;n>MISC0</a>.
</li><li>Otherwise, the fault handling interrupt is <ins>also </ins>generated for <del>all </del>detected Corrected errors <ins>onreads.</ins><del>on reads.</del>
</li></ul><table class="valuetable"><tr><th>RCFI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt not generated for Corrected errors on reads.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt generated for Corrected errors on reads.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_8"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WUE_7">WUE, bit [7]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UE == 0b11:
                </div></h4><p>In-band Uncorrected error reporting on writes enable.</p><p>When enabled, responses to writes that detect an Uncorrected error that cannot be deferred are signaled in-band as a detected Uncorrected error (External <ins>Abort</ins><del>abort</del>).</p><table class="valuetable"><tr><th>WUE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors <ins>on</ins><del>disabled</del> <ins>writes</ins><del>for</del> <ins>disabled.</ins><del>writes.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors <ins>on</ins><del>enabled</del> <ins>writes</ins><del>for</del> <ins>enabled.</ins><del>writes.</del></p></td></tr></table><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_7"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WFI_6">WFI, bit [6]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.FI == 0b11:
                </div></h4><p>Fault handling interrupt on writes enable.</p><p>When enabled:</p><ul><li>The fault handling interrupt is generated for <del>all </del>detected Deferred errors and Uncorrected <ins>errors.</ins><del>errors on writes.</del>
</li><li>If the <ins>corresponding </ins>fault handling interrupt for Corrected errors control is not implemented:<ul><li>If the node implements Corrected error counters<ins> for writes</ins>, then the fault handling interrupt is also generated when a counter overflows and the overflow bit for the counter is set to<del> 1.</del> <span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li>Otherwise, the fault handling interrupt is also generated for <del>all </del>detected Corrected errors on writes.
</li></ul></li></ul><table class="valuetable"><tr><th>WFI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt <del>disabled </del>on <ins>writes disabled.</ins><del>writes.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt <del>enabled </del>on <ins>writes enabled.</ins><del>writes.</del></p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_6"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WUI_5">WUI, bit [5]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UI == 0b11:
                </div></h4><p>Uncorrected error recovery interrupt on writes enable.</p><p>When enabled, the error recovery interrupt is generated for <del>all </del>detected Uncorrected errors on writes that are not deferred.</p><table class="valuetable"><tr><th>WUI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt <del>disabled </del>on <ins>writes disabled.</ins><del>writes.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt <del>enabled </del>on <ins>writes enabled.</ins><del>writes.</del></p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_5"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="UE_4">UE, bit [4]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UE == 0b10:
                </div></h4><p>In-band Uncorrected error reporting enable.</p><p>When<del> enabled, responses to transactions that detect an Uncorrected error that cannot be deferred are signaled in-band as a detected Uncorrected error (External abort).</del> <a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.UE == </ins><span class="binarynumber"><ins>0b10</ins></span><ins>, this control applies to errors arising from both reads and writes.</ins></p><p><ins>When enabled, responses to transactions that detect an Uncorrected error that cannot be deferred are signaled in-band as a detected Uncorrected error (External Abort).</ins></p><table class="valuetable"><tr><th>UE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors enabled.</p></td></tr></table><div class="note"><span class="note-header"><del class="nocount">Note</del></span><p><del>This control applies to errors arising from both reads and writes.</del></p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="RUE_4"><div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UE == 0b11:
                </div></h4><p><del>When </del><a href="ext-errnfr.html"><del>ERR&lt;n>FR</del></a><del>.UE == </del><span class="binarynumber"><del>0b11</del></span><del>, this field is named RUE.</del></p><p>In-band Uncorrected error reporting on reads enable.</p><p>When<del> enabled, responses to reads that detect an Uncorrected error that cannot be deferred are signaled in-band as a detected Uncorrected error (External abort).</del> <a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.UE == </ins><span class="binarynumber"><ins>0b11</ins></span><ins>, this bit is named RUE.</ins></p><p><ins>When enabled, responses to reads that detect an Uncorrected error that cannot be deferred are signaled in-band as a detected Uncorrected error (External Abort).</ins></p><table class="valuetable"><tr><th>RUE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors <ins>on</ins><del>disabled</del> <ins>reads</ins><del>for</del> <ins>disabled.</ins><del>reads.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>External <ins>Abort</ins><del>abort</del> response for Uncorrected errors <ins>on</ins><del>enabled</del> <ins>reads</ins><del>for</del> <ins>enabled.</ins><del>reads.</del></p></td></tr></table><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_4"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FI_3">FI, bit [3]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.FI == 0b10:
                </div></h4><p>Fault handling interrupt enable.<del> This control applies to errors arising from both reads and writes.</del></p><p><ins>When </ins><a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.FI == </ins><span class="binarynumber"><ins>0b10</ins></span><ins>, this control applies to errors arising from both reads and writes.</ins></p><p>When enabled:</p><ul><li>The fault handling interrupt is generated for all detected Deferred errors and Uncorrected errors.
</li><li>If the fault handling interrupt for Corrected errors control is not implemented:<ul><li>If the node implements Corrected error counters, then the fault handling interrupt is also generated when a counter overflows and the overflow bit for the counter is set to<del> 1.</del> <span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li>Otherwise, the fault handling interrupt is also generated for all detected Corrected errors.
</li></ul></li></ul><table class="valuetable"><tr><th>FI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt enabled.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="RFI_3"><div style="font-size:smaller;"><br/>When ERR&lt;n>FR.FI == 0b11:
                </div></h4><p><del>When </del><a href="ext-errnfr.html"><del>ERR&lt;n>FR</del></a><del>.FI == </del><span class="binarynumber"><del>0b11</del></span><del>, this field is named RFI.</del></p><p>Fault handling interrupt on reads enable.</p><p><ins>When </ins><a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.FI == </ins><span class="binarynumber"><ins>0b11</ins></span><ins>, this bit is named RFI.</ins></p><p>When enabled:</p><ul><li>The fault handling interrupt is generated for <del>all </del>detected Deferred errors and Uncorrected <ins>errors.</ins><del>errors on reads.</del>
</li><li>If the <ins>corresponding </ins>fault handling interrupt for Corrected errors control is not implemented:<ul><li>If the node implements Corrected error counters<ins> for reads</ins>, then the fault handling interrupt is also generated when a counter overflows and the overflow bit for the counter is set to<del> 1.</del> <span class="binarynumber"><ins>0b1</ins></span><ins>.
</ins></li><li>Otherwise, the fault handling interrupt is also generated for <del>all </del>detected Corrected errors on reads.
</li></ul></li></ul><table class="valuetable"><tr><th>RFI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault handling interrupt <del>disabled </del>on <ins>reads disabled.</ins><del>reads.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault handling interrupt <del>enabled </del>on <ins>reads enabled.</ins><del>reads.</del></p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_3"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="UI_2">UI, bit [2]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UI == 0b10:
                </div></h4><p>Uncorrected error recovery interrupt enable.<del> This control applies to errors arising from both reads and writes.</del></p><p><ins>When </ins><a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.UI == </ins><span class="binarynumber"><ins>0b10</ins></span><ins>, this control applies to errors arising from both reads and writes.</ins></p><p>When enabled, the error recovery interrupt is generated for all detected Uncorrected errors that are not deferred.</p><table class="valuetable"><tr><th>UI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt enabled.</p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="RUI_2"><div style="font-size:smaller;"><br/>When ERR&lt;n>FR.UI == 0b11:
                </div></h4><p><del>When </del><a href="ext-errnfr.html"><del>ERR&lt;n>FR</del></a><del>.UI == </del><span class="binarynumber"><del>0b11</del></span><del>, this field is named RUI.</del></p><p>Uncorrected error recovery interrupt on reads enable.</p><p>When<del> enabled, the error recovery interrupt is generated for all detected Uncorrected errors on reads that are not deferred.</del> <a href="ext-errnfr.html"><ins>ERR&lt;n>FR</ins></a><ins>.UI == </ins><span class="binarynumber"><ins>0b11</ins></span><ins>, this bit is named RUI.</ins></p><p><ins>When enabled, the error recovery interrupt is generated for detected Uncorrected errors on reads that are not deferred.</ins></p><table class="valuetable"><tr><th>RUI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error recovery interrupt <del>disabled </del>on <ins>reads disabled.</ins><del>reads.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error recovery interrupt <del>enabled </del>on <ins>reads enabled.</ins><del>reads.</del></p></td></tr></table><p>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</p><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li></ul><h4 id="0_2"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="IMPLEMENTATIONDEFINED_1">IMPLEMENTATION DEFINED, bit [1]
              </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>Reserved for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> controls. Must permit SBZP write policy for software.</p><p><del>This bit reads as an </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> value and writes to this bit have </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> behavior.</del></p><h4 id="ED_0">ED, bit [0]
              <div style="font-size:smaller;"><br/>When ERR&lt;n>FR.ED == 0b10:
                </div></h4><p><del>When disabled, the node behaves as if error detection and correction are disabled, and no errors are recorded or signaled by the node. Arm recommends that, when disabled, correct error detection and correction codes are written for writes, unless disabled by an </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> control for error injection.</del></p><p>Error reporting and logging enable.<ins> When disabled, the node behaves as if error detection and correction are disabled, and no errors are recorded or signaled by the node. Arm recommends that, when disabled, correct error detection and correction codes are written for writes, unless disabled by an</ins> <span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> control for error injection.</ins></p><table class="valuetable"><tr><th>ED</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Error reporting disabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Error reporting enabled.</p></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the node fully disables error detection and correction when reporting is disabled. That is, even with error reporting disabled, the node might continue to silently correct errors. Uncorrectable errors might result in corrupt data being silently propagated by the node.</p><div class="note"><span class="note-header">Note</span><p>If this node requires initialization after Cold reset to prevent signaling false errors, then Arm recommends this bit is set to<del> 0 on Cold reset. This allows boot software to initialize a node without signaling errors. Software can enable error reporting after the node is initialized. If the Cold reset value is 1, the reset values of other controls in this register are</del> <span class="binarynumber"><ins>0b0</ins></span><ins> on Cold reset, meaning errors are not reported from Cold reset. This allows boot software to initialize a node without signaling errors. Software can enable error reporting after the node is initialized. Otherwise, the Cold reset value is </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins>. If the Cold reset value is </ins><span class="binarynumber"><ins>0b1</ins></span><ins>, the reset values of other controls in this register are also </ins><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> and should not be <span class="arm-defined-word">UNKNOWN</span>.</p></div><p>The following resets apply:</p><ul><li><p><ins>On</ins><del>This</del> <ins>an</ins><del>bit</del> <ins>Error</ins><del>is</del> <ins>recovery</ins><del>preserved</del> <ins>reset,</ins><del>on</del> <ins>the</ins><del>an</del> <ins>value</ins><del>Error</del> <ins>of</ins><del>Recovery</del> <ins>this field is unchanged.</ins><del>reset.</del></p></li><li><p>On a Cold reset, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p></li></ul><h4 id="0_0"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><h2>Accessing the ERR&lt;n>CTLR</h2><h4>ERR&lt;n>CTLR can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>RAS</td><td><span class="hexnumber">0x008</span> + 64n</td><td>ERR&lt;n>CTLR</td></tr></table><p>Accesses on this interface are <span class="access_level">RW</span>.</p><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>