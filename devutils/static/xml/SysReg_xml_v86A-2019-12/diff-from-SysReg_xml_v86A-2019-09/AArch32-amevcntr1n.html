<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>AMEVCNTR1&lt;n></title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">AMEVCNTR1&lt;n>, Activity Monitors Event Counter Registers 1, n =
      0 - 15</h1><p>The AMEVCNTR1&lt;n> characteristics are:</p><h2>Purpose</h2><p>Provides access to the auxiliary activity monitor event counters.</p><h2>Configuration</h2><p>AArch32 System register AMEVCNTR1&lt;n> bits [63:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-amevcntr1n_el0.html">AMEVCNTR1&lt;n>_EL0[63:0]
            </a>.
          </p><p>AArch32 System register AMEVCNTR1&lt;n> bits [63:0]
            
                are architecturally mapped to
              External register <a href="ext-amevcntr1n.html">AMEVCNTR1&lt;n>[63:0]
            </a>.
          </p><p>This register is present only
    when AMUv1 is implemented.
      
    Otherwise, direct accesses to AMEVCNTR1&lt;n> are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>AMEVCNTR1&lt;n> is a 64-bit register.</p><h2>Field descriptions</h2><p>The AMEVCNTR1&lt;n> bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#ACNT_63">ACNT</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#ACNT_63">ACNT</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="ACNT_63">ACNT, bits [63:0]
                  </h4><p>Auxiliary activity monitor event counter n.</p><p>Value of auxiliary activity monitor event counter n, where n is the number of this register and is a number from 0 to 15.</p><p>If <span class="xref">ARMv8.6-AMU</span> is implemented, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.AMVOFFEN is 1, <a href="AArch64-scr_el3.html">SCR_EL3</a>.AMVOFFEN is 1, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is not {1,1}, EL2 is using AArch64 and is implemented in the current Security state, and <a href="AArch64-amcr_el0.html">AMCR_EL0</a>.CG1RZ is 0, reads to these registers at EL0 or EL1 return (PCount&lt;63:0> - <a href="AArch64-amevcntvoff1n_el2.html">AMEVCNTVOFF1&lt;n>_EL2</a>&lt;63:0>).</p><p>PCount is the physical count returned when AMEVCNTR1&lt;n> is read from EL2 or EL3.</p><p>If the counter is enabled, writes to this register have <span class="arm-defined-word">UNPREDICTABLE</span> results.</p><p>On a Cold reset, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the AMEVCNTR1&lt;n></h2><ul><li><del>Accesses to the register are </del><span class="arm-defined-word"><del>UNDEFINED</del></span><del>.
</del></li><li><del>Accesses to the register behave as RAZ/WI.
</del></li><li><del>Accesses to the register execute as a </del><span class="instruction"><del>NOP</del></span><del>.
</del></li></ul><p>If &lt;n> is greater than or equal to the number of auxiliary activity monitor event counters, reads and writes of AMEVCNTR1&lt;n> are <span class="arm-defined-word"><ins>UNDEFINED</ins><del>CONSTRAINED UNPREDICTABLE</del></span><ins>.</ins><del>, and the following behaviors are permitted:</del></p><div class="note"><span class="note-header">Note</span><p><a href="AArch32-amcgcr.html">AMCGCR</a>.CG1NC identifies the number of auxiliary activity monitor event counters.</p></div><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b010:n[3]</td><td><del>0b0:</del>n[2:0]</td></tr></table><p class="pseudocode">
if CRm == <ins>'0100'</ins><del>100</del> then
    if PSTATE.EL == EL0 then
        if !ELUsingAArch32(EL1) &amp;&amp; AMUSERENR_EL0.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            else
                AArch64.AArch32SystemAccessTrap(EL1, 0x04);
        elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
                AArch32.TakeHypTrapException(0x00);
            else
                UNDEFINED;
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; <del>HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; HSTR_EL2.T4 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T4 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; </del>CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL1) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HAFGRTR_EL2.AMEVCNTR1&lt;n>_EL0 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL1 then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; <del>HSTR_EL2.T4 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T4 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; </del>CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL2 then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL3 then
        return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
elsif CRm == <ins>'0101'</ins><del>101</del> then
    if PSTATE.EL == EL0 then
        if !ELUsingAArch32(EL1) &amp;&amp; AMUSERENR_EL0.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            else
                AArch64.AArch32SystemAccessTrap(EL1, 0x04);
        elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
                AArch32.TakeHypTrapException(0x00);
            else
                UNDEFINED;
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; HSTR_EL2.T5 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL1) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HAFGRTR_EL2.AMEVCNTR1&lt;n>_EL0 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL1 then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T5 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL2 then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; !HighestELUsingAArch32() &amp;&amp; AMCR_EL0.CG1RZ == '1' then
            Zeros();
        elsif !IsHighestEL(PSTATE.EL) &amp;&amp; HighestELUsingAArch32() &amp;&amp; AMCR.CG1RZ == '1' then
            Zeros();
        else
            return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
    elsif PSTATE.EL == EL3 then
        return AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)];
else
    UNDEFINED;
              </p><h4 class="assembler">MCRR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b010:n[3]</td><td><del>0b0:</del>n[2:0]</td></tr></table><p class="pseudocode">
if CRm == <del>100 then
    if PSTATE.EL == EL0 then
        if !ELUsingAArch32(EL1) &amp;&amp; AMUSERENR_EL0.EN == </del>'<ins>0100</ins><del>0</del>' then<del>
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            else
                AArch64.AArch32SystemAccessTrap(EL1, 0x04);
        elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
                AArch32.TakeHypTrapException(0x00);
            else
                UNDEFINED;
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; HSTR_EL2.T4 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T4 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        else
            AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];</del>
    <del>elsif PSTATE.EL == EL1 then
        </del>if <ins>IsHighestEL</ins><del>EL2Enabled() &amp;&amp; !ELUsingAArch32</del>(<del>EL2) &amp;&amp; HSTR_EL2.T4 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T4 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        else
            AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];
    elsif </del>PSTATE.EL<del> == EL2 then
        if HaveEL(EL3</del>) <del>&amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' </del>then<del>
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);</del>
        <del>else
            </del>AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];
    <ins>else</ins><del>elsif PSTATE.EL == EL3 then</del>
        <ins>UNDEFINED;</ins><del>AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];</del>
elsif CRm == <ins>'0101'</ins><del>101</del> then
    if PSTATE.EL == <del>EL0 then
        if !ELUsingAArch32(</del>EL1<del>)</del> &amp;&amp; <del>AMUSERENR_EL0.EN == '0' then
            if </del>EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; <del>HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            else
                AArch64.AArch32SystemAccessTrap(EL1, 0x04);
        elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
            if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
                AArch64.AArch32SystemAccessTrap(EL2, 0x04);
            elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
                AArch32.TakeHypTrapException(0x00);
            else
                UNDEFINED;
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; </del>HSTR_EL2.T5 == '1' then<del>
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);</del>
        <del>elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            </del>AArch64.AArch32SystemAccessTrap(EL2, 0x04);<del>
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            AArch32.TakeHypTrapException(0x04);
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        else
            AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];</del>
    elsif PSTATE.EL == EL1 <del>then
        if EL2Enabled() </del>&amp;&amp; <del>!ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T5 == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif </del>EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then<del>
            AArch32.TakeHypTrapException(0x04);</del>
        <del>elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x04);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
            </del>AArch32.TakeHypTrapException(0x04);<del>
        elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);
        else
            AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];</del>
    elsif <ins>IsHighestEL</ins><del>PSTATE.EL == EL2 then
        if HaveEL</del>(<ins>PSTATE.EL</ins><del>EL3</del>) <del>&amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' </del>then<del>
            AArch64.AArch32SystemAccessTrap(EL3, 0x04);</del>
        <del>else
            </del>AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];
    <ins>else</ins><del>elsif PSTATE.EL == EL3 then</del>
        <ins>UNDEFINED;</ins><del>AMEVCNTR1[UInt(CRm&lt;0>:opc1&lt;2:0>)] = R[t2]:R[t];</del>
else
    UNDEFINED;
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>