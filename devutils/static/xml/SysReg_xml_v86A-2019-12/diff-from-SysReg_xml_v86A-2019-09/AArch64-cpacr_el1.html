<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>CPACR_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">CPACR_EL1, Architectural Feature Access Control Register</h1><p>The CPACR_EL1 characteristics are:</p><h2>Purpose</h2><p>Controls access to trace, SVE, Advanced SIMD and floating-point functionality.</p><h2>Configuration</h2><p>AArch64 System register CPACR_EL1 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-cpacr.html">CPACR[31:0]
            </a>.
          </p><p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} == {1, 1}, the fields in this register have no effect on execution at EL0 and EL1. In this case, the controls provided by <a href="AArch64-cptr_el2.html">CPTR_EL2</a> are used.</p><p><del class="nocount">
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>CPACR_EL1 is a 64-bit register.</p><h2>Field descriptions</h2><p>The CPACR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="3"><a href="#0_63">RES0</a></td><td class="lr" colspan="1"><a href="#TTA_28">TTA</a></td><td class="lr" colspan="6"><a href="#0_27">RES0</a></td><td class="lr" colspan="2"><a href="#FPEN_21">FPEN</a></td><td class="lr" colspan="2"><a href="#0_19">RES0</a></td><td class="lr" colspan="2"><a href="#ZEN_17">ZEN</a></td><td class="lr" colspan="16"><a href="#0_15">RES0</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="0_63">
                Bits [63:29]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TTA_28">TTA, bit [28]
              </h4><p>Traps EL0 and EL1 System register accesses to all implemented trace registers to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from both Execution states as follows:</p><ul><li><p>In AArch64 state, accesses to trace registers are trapped, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p></li><li><p>In AArch32 state, MRC and MCR accesses to trace registers are trapped, reported using EC syndrome value <span class="hexnumber">0x05</span>.</p></li><li><p>In AArch32 state, MRRC and MCRR accesses to trace registers are trapped, reported using EC syndrome value <span class="hexnumber">0x0C</span>.</p></li></ul><table class="valuetable"><tr><th>TTA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control causes EL0 and EL1 System register accesses to all implemented trace registers to be trapped.</p></td></tr></table><div class="note"><span class="note-header">Note</span><ul><li>The ETMv4 architecture does not permit EL0 to access the trace registers. If the Armv8-A architecture is implemented with an ETMv4 implementation, EL0 accesses to the trace registers are <span class="arm-defined-word">UNDEFINED</span>, and any resulting exception is higher priority than an exception that would be generated because the value of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA is 1.</li><li>The Armv8-A architecture does not provide traps on trace register accesses through the optional memory-mapped interface.</li></ul></div><p>System register accesses to the trace registers can have side-effects. When a System register access is trapped, any side-effects that are normally associated with the access do not occur before the exception is taken.</p><p>If System register access to the trace functionality is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_27">
                Bits [27:22]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="FPEN_21">FPEN, bits [21:20]
                  </h4><p>Traps EL0 and EL1 accesses to the SVE, Advanced SIMD, and floating-point registers to EL1, reported using EC syndrome value <span class="hexnumber">0x07</span>, or to EL2 reported using EC syndrome value <span class="hexnumber">0x00</span>, when EL2 is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, from both Execution states as follows:</p><ul><li>In AArch64 state, accesses to <a href="AArch64-fpcr.html">FPCR</a>, <a href="AArch64-fpsr.html">FPSR</a>, any of the SIMD and floating-point registers V0-V31, including their views as D0-D31 registers or S0-31 registers. See <span class="xref">'The SIMD and floating-point registers, V0-V31' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.
</li><li><a href="AArch32-fpcsr.html">FPCSR</a>, and any of the SIMD and floating-point registers Q0-15, including their views as D0-D31 registers or S0-31 registers. See <span class="xref">'Advanced SIMD and floating-point System registers' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.
</li></ul><table class="valuetable"><tr><th>FPEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>This control causes any instructions at EL0 or EL1 that use the registers associated with SVE, Advanced SIMD and floating-point execution to be trapped, unless they are trapped by <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>This control causes any instructions at EL0 that use the registers associated with SVE, Advanced SIMD and floating-point execution to be trapped, unless they are trapped by <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN, but does not cause any instruction at EL1 to be trapped.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>This control causes any instructions at EL0 or EL1 that use the registers associated with SVE, Advanced SIMD and floating-point execution to be trapped, unless they are trapped by <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr></table><p>Writes to <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a> and <a href="AArch32-mvfr2.html">MVFR2</a> from EL1 or higher are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> and whether these accesses can be trapped by this control depends on implemented <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behavior.</p><div class="note"><span class="note-header">Note</span><ul><li>Attempts to write to the FPSID count as use of the registers for accesses from EL1 or higher.</li><li>Accesses from EL0 to <a href="AArch32-fpsid.html">FPSID</a>, <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a>, <a href="AArch32-mvfr2.html">MVFR2</a>, and <a href="AArch32-fpexc.html">FPEXC</a> are <span class="arm-defined-word">UNDEFINED</span>, and any resulting exception is higher priority than an exception that would be generated because the value of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN is not <span class="binarynumber">0b11</span>.</li></ul></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_19">
                Bits [19:18]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ZEN_17">ZEN, bits [17:16]
                  <div style="font-size:smaller;"><br/>When SVE is implemented:
                </div></h4><p>Traps SVE instructions and instructions that access SVE System registers at EL0 and EL1 to EL1, or to EL2 when it is implemented and enabled for the current Security state and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1.</p><table class="valuetable"><tr><th>ZEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>This control causes these instructions executed at EL0 or EL1 to be trapped.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>This control causes these instructions executed at EL0 to be trapped, but does not cause any instruction at EL1 to be trapped.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>This control causes these instructions executed at EL0 or EL1 to be trapped.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>This control does not cause any instruction to be trapped.</p></td></tr></table><p>If <span class="xref">SVE</span>is not implemented, this field is <span class="arm-defined-word">RES0</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_17"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_15">
                Bits [15:0]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the CPACR_EL1</h2><p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, without explicit synchronization, access from EL3 using the mnemonic CPACR_EL1 or CPACR_EL12 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</p><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, CPACR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0000</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.CPACR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '111' then
        return NVMem[0x100];
    else
        return CPACR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        return CPTR_EL2;
    else
        return CPACR_EL1;
elsif PSTATE.EL == EL3 then
    return CPACR_EL1;
              </p><h4 class="assembler">MSR CPACR_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0001</td><td>0b0000</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.CPACR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '111' then
        NVMem[0x100] = X[t];
    else
        CPACR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HCR_EL2.E2H == '1' then
        CPTR_EL2 = X[t];
    else
        CPACR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    CPACR_EL1 = X[t];
              </p><h4 class="assembler">MRS &lt;Xt>, CPACR_EL12</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b0001</td><td>0b0000</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '101' then
        return NVMem[0x100];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if <del>EL2Enabled() &amp;&amp; </del>HCR_EL2.E2H == '1' then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            return CPACR_EL1;
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled()<ins> &amp;&amp; !ELUsingAArch32(EL2)</ins> &amp;&amp; HCR_EL2.E2H == '1' then
        return CPACR_EL1;
    else
        UNDEFINED;
              </p><h4 class="assembler">MSR CPACR_EL12, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b101</td><td>0b0001</td><td>0b0000</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '101' then
        NVMem[0x100] = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if <del>EL2Enabled() &amp;&amp; </del>HCR_EL2.E2H == '1' then
        if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TCPAC == '1' then
            AArch64.SystemAccessTrap(EL3, 0x18);
        else
            CPACR_EL1 = X[t];
    else
        UNDEFINED;
elsif PSTATE.EL == EL3 then
    if EL2Enabled()<ins> &amp;&amp; !ELUsingAArch32(EL2)</ins> &amp;&amp; HCR_EL2.E2H == '1' then
        CPACR_EL1 = X[t];
    else
        UNDEFINED;
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>