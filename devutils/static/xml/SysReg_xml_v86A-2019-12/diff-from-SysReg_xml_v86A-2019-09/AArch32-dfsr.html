<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>DFSR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DFSR, Data Fault Status Register</h1><p>The DFSR characteristics are:</p><h2>Purpose</h2><p>Holds status information about the last data fault.</p><h2>Configuration</h2><p>AArch32 System register DFSR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-esr_el1.html">ESR_EL1[31:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to DFSR are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>The current translation table format determines which format of the register is used.</p><p><del class="nocount">
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>DFSR is a 32-bit register.</p><h2>Field descriptions</h2><p>The DFSR bit assignments are:</p><h3>When TTBCR.EAE == 0:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="15"><a href="#WhenTTBCR.EAE0_0_31">RES0</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_FnV_16">FnV</a></td><td class="lr" colspan="2"><a href="#WhenTTBCR.EAE0_AET_15">AET</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_CM_13">CM</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_ExT_12">ExT</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_WnR_11">WnR</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_FS4_10">FS[4]</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_LPAE_9">LPAE</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE0_0_8">RES0</a></td><td class="lr" colspan="4"><a href="#WhenTTBCR.EAE0_Domain_7">Domain</a></td><td class="lr" colspan="4"><a href="#WhenTTBCR.EAE0_FS3:0_3">FS[3:0]</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="WhenTTBCR.EAE0_0_31">
                Bits [31:17]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenTTBCR.EAE0_FnV_16">FnV, bit [16]
              </h4><p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p><table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="AArch32-dfar.html">DFAR</a> is valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="AArch32-dfar.html">DFAR</a> is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p></td></tr></table><p>This field is only valid for a synchronous External abort other than a synchronous External abort on a translation table walk. It is <span class="arm-defined-word">RES0</span> for all other Data Abort exceptions.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_AET_15">AET, bits [15:14]
                  </h4><p>Asynchronous Error Type. When the RAS Extension is implemented, this field describes the state of the PE after taking an asynchronous Data Abort exception. Possible values are:</p><table class="valuetable"><tr><th>AET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Uncontainable error (UC) or uncategorized.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Unrecoverable error (UEU).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Restartable error (UEO) or Corrected error (CE).</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Recoverable error (UER).</p></td></tr></table><p>When the RAS Extension is not implemented, or on a synchronous Data Abort, this field is <span class="arm-defined-word">RES0</span>.</p><div class="note"><span class="note-header">Note</span><p>Armv8.2 requires the implementation of the RAS Extension.</p></div><p>In the event of multiple errors taken as a single SError interrupt exception, the overall state of the PE is reported.</p><div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. The recovery software must also examine any implemented fault records to determine the location and extent of the error.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_CM_13">CM, bit [13]
              </h4><p>Cache maintenance fault. For synchronous faults, this bit indicates whether a cache maintenance instruction generated the fault. The possible values of this bit are:</p><table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort not caused by execution of a cache maintenance instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by execution of a cache maintenance instruction, or on an address translation.</p></td></tr></table><p>On a synchronous Data Abort on a translation table walk, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>On an asynchronous fault, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_ExT_12">ExT, bit [12]
              </h4><p>External abort type. This bit can be used to provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p><p>In an implementation that does not provide any classification of External aborts, this bit is <span class="arm-defined-word">RES0</span>.</p><p>For aborts other than External aborts this bit always returns 0.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_WnR_11">WnR, bit [11]
              </h4><p>Write not Read bit. Indicates whether the abort was caused by a write or a read instruction. The possible values of this bit are:</p><table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort caused by a read instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by a write instruction.</p></td></tr></table><p>For faults on the cache maintenance and address translation System instructions in the (coproc==<span class="binarynumber">0b1111</span>) encoding space this bit always returns a value of 1.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_FS4_10">FS[4], bit [10]
              </h4><p>This field is bit[4] of FS[4:0].</p><p>Fault status bits. Possible values of FS[4:0] are:</p><table class="valuetable"><tr><th>FS</th><th>Meaning</th><th><ins>Applies when</ins></th></tr><tr><td class="bitfield">0b00001</td><td><p>Alignment fault.</p></td></tr><tr><td class="bitfield">0b00010</td><td><p>Debug exception.</p></td></tr><tr><td class="bitfield">0b00011</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b00100</td><td><p>Fault on instruction cache maintenance.</p></td></tr><tr><td class="bitfield">0b00101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b00110</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b00111</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b01000</td><td><p>Synchronous External abort, not on translation table walk.</p></td></tr><tr><td class="bitfield">0b01001</td><td><p>Domain fault, level 1.</p></td></tr><tr><td class="bitfield">0b01011</td><td><p>Domain fault, level 2.</p></td></tr><tr><td class="bitfield">0b01100</td><td><p>Synchronous External abort, on translation table walk, level 1.</p></td></tr><tr><td class="bitfield">0b01101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b01110</td><td><p>Synchronous External abort, on translation table walk, level 2.</p></td></tr><tr><td class="bitfield">0b01111</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b10000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b10100</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Lockdown fault).</p></td></tr><tr><td class="bitfield">0b10101</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Unsupported Exclusive access fault).</p></td></tr><tr><td class="bitfield">0b10110</td><td><p>SError interrupt.</p></td></tr><tr><td class="bitfield">0b11000</td><td><p>SError interrupt, from a parity or ECC error on memory access.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b11001</td><td><p>Synchronous parity or ECC error on memory access, not on translation table walk.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b11100</td><td><p>Synchronous parity or ECC error on translation table walk, level 1.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b11110</td><td><p>Synchronous parity or ECC error on translation table walk, level 2.</p></td><td><ins>When RAS is not implemented</ins></td></tr></table><p>All other values are reserved.</p><p><del>When the RAS Extension is implemented, </del><span class="binarynumber"><del>0b11000</del></span><del>, </del><span class="binarynumber"><del>0b11001</del></span><del>, </del><span class="binarynumber"><del>0b11100</del></span><del>, and </del><span class="binarynumber"><del>0b11110</del></span><del>, are reserved.</del></p><p>For more information about the lookup level associated with a fault, see <span class="xref">'The level associated with MMU faults on a Short-descriptor translation table lookup' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>The FS field is split as follows:</p><ul><li>FS[4] is DFSR[10].
</li><li>FS[3:0] is DFSR[3:0].
</li></ul><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_LPAE_9">LPAE, bit [9]
              </h4><p>On taking a Data Abort exception, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Using the Short-descriptor translation table formats.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Using the Long-descriptor translation table formats.</p></td></tr></table><p>Hardware does not interpret this bit to determine the behavior of the memory system, and therefore software can set this bit to 0 or 1 without affecting operation.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_0_8">
                Bit [8]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenTTBCR.EAE0_Domain_7">Domain, bits [7:4]
                  </h4><p>The domain of the fault address.</p><p>Arm deprecates any use of this field, see <span class="xref">'The Domain field in the DFSR' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> for certain faults where the DFSR is updated and reported using the Short-descriptor FSR encodings, see <span class="xref">'Validity of Domain field on faults that update the DFSR when using the Short-descriptor encodings' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE0_FS3:0_3">FS[3:0], bits [3:0]
                  </h4><p>This field is bits[3:0] of FS[4:0].</p><p>See FS[4] for the field description.</p><div class="text_after_fields"></div><h3>When TTBCR.EAE == 1:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="15"><a href="#WhenTTBCR.EAE1_0_31">RES0</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_FnV_16">FnV</a></td><td class="lr" colspan="2"><a href="#WhenTTBCR.EAE1_AET_15">AET</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_CM_13">CM</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_ExT_12">ExT</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_WnR_11">WnR</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_0_10">RES0</a></td><td class="lr" colspan="1"><a href="#WhenTTBCR.EAE1_LPAE_9">LPAE</a></td><td class="lr" colspan="3"><a href="#WhenTTBCR.EAE1_0_8">RES0</a></td><td class="lr" colspan="6"><a href="#WhenTTBCR.EAE1_STATUS_5">STATUS</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="WhenTTBCR.EAE1_0_31">
                Bits [31:17]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenTTBCR.EAE1_FnV_16">FnV, bit [16]
              </h4><p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p><table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><a href="AArch32-dfar.html">DFAR</a> is valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="AArch32-dfar.html">DFAR</a> is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p></td></tr></table><p>This field is only valid for a synchronous External abort other than a synchronous External abort on a translation table walk. It is <span class="arm-defined-word">RES0</span> for all other Data Abort exceptions.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_AET_15">AET, bits [15:14]
                  </h4><p>Asynchronous Error Type. When the RAS Extension is implemented, this field describes the state of the PE after taking an asynchronous Data Abort exception. Possible values are:</p><table class="valuetable"><tr><th>AET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Uncontainable error (UC) or uncategorized.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Unrecoverable error (UEU).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Restartable error (UEO) or Corrected error (CE).</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Recoverable error (UER).</p></td></tr></table><p>When the RAS Extension is not implemented, or on a synchronous Data Abort, this field is <span class="arm-defined-word">RES0</span>.</p><div class="note"><span class="note-header">Note</span><p>Armv8.2 requires the implementation of the RAS Extension.</p></div><p>In the event of multiple errors taken as a single SError interrupt exception, the overall state of the PE is reported.</p><div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. The recovery software must also examine any implemented fault records to determine the location and extent of the error.</p></div><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_CM_13">CM, bit [13]
              </h4><p>Cache maintenance fault. For synchronous faults, this bit indicates whether a cache maintenance instruction generated the fault. The possible values of this bit are:</p><table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort not caused by execution of a cache maintenance instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by execution of a cache maintenance instruction.</p></td></tr></table><p>On a synchronous Data Abort on a translation table walk, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>On an asynchronous fault, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_ExT_12">ExT, bit [12]
              </h4><p>External abort type. This bit can be used to provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p><p>In an implementation that does not provide any classification of External aborts, this bit is <span class="arm-defined-word">RES0</span>.</p><p>For aborts other than External aborts this bit always returns 0.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_WnR_11">WnR, bit [11]
              </h4><p>Write not Read bit. Indicates whether the abort was caused by a write or a read instruction. The possible values of this bit are:</p><table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort caused by a read instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by a write instruction.</p></td></tr></table><p>For faults on the cache maintenance and address translation System instructions in the (coproc==<span class="binarynumber">0b1111</span>) encoding space this bit always returns a value of 1.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_0_10">
                Bit [10]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenTTBCR.EAE1_LPAE_9">LPAE, bit [9]
              </h4><p>On taking a Data Abort exception, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Using the Short-descriptor translation table formats.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Using the Long-descriptor translation table formats.</p></td></tr></table><p>Hardware does not interpret this bit to determine the behavior of the memory system, and therefore software can set this bit to 0 or 1 without affecting operation.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenTTBCR.EAE1_0_8">
                Bits [8:6]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenTTBCR.EAE1_STATUS_5">STATUS, bits [5:0]
                  </h4><p>Fault status bits. Possible values of this field are:</p><table class="valuetable"><tr><th>STATUS</th><th>Meaning</th><th><ins>Applies when</ins></th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault in<ins> translation table base register.</ins><a href="AArch32-ttbr0.html"><del>TTBR0</del></a><del> or </del><a href="AArch32-ttbr1.html"><del>TTBR1</del></a><del>.</del></p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010000</td><td><p>Synchronous External abort, not on translation table walk.</p></td></tr><tr><td class="bitfield">0b010001</td><td><p><ins>Asynchronous </ins>SError interrupt.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort, on translation table walk, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort, on translation table walk, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort, on translation table walk, level 3.</p></td></tr><tr><td class="bitfield">0b011000</td><td><p>Synchronous parity or ECC error on memory access, not on translation table walk.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b011001</td><td><p><ins>Asynchronous </ins>SError interrupt, from a parity or ECC error on memory access.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk, level 1.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk, level 2.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk, level 3.</p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield">0b100001</td><td><p>Alignment fault.</p></td></tr><tr><td class="bitfield">0b100010</td><td><p>Debug exception.</p></td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110100</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Lockdown<del> fault</del>).</p></td></tr><tr><td class="bitfield">0b110101</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Unsupported Exclusive access<del> fault</del>).</p></td></tr></table><p>All other values are reserved.</p><p><del>When the RAS Extension is implemented, </del><span class="binarynumber"><del>0b011000</del></span><del>, </del><span class="binarynumber"><del>0b011001</del></span><del>, </del><span class="binarynumber"><del>0b011101</del></span><del>, </del><span class="binarynumber"><del>0b011110</del></span><del>, and </del><span class="binarynumber"><del>0b011111</del></span><del>, are reserved.</del></p><p>For more information about the lookup level associated with a fault, see <span class="xref">'The level associated with MMU faults on a Long-descriptor translation table lookup' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the DFSR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0101</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T5 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            return DFSR_S;
        else
            </del>return DFSR_NS;
    else
        return DFSR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return DFSR_NS;
    else
        return DFSR;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        return DFSR_S;
    else
        return DFSR_NS;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0101</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T5 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T5 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            DFSR_S = R[t];
        else
            </del>DFSR_NS = R[t];
    else
        DFSR = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        DFSR_NS = R[t];
    else
        DFSR = R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        DFSR_S = R[t];
    else
        DFSR_NS = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>