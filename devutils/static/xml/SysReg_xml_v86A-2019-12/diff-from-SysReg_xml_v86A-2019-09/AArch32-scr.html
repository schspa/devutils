<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>SCR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SCR, Secure Configuration Register</h1><p>The SCR characteristics are:</p><h2>Purpose</h2><p>When EL3 is implemented and can use AArch32, defines the configuration of the current Security state. It specifies:</p><ul><li>The Security state, either Secure or Non-secure.
</li><li>What mode the PE branches to if an IRQ, FIQ, or External abort occurs.
</li><li>Whether the CPSR.F or CPSR.A bits can be modified when SCR.NS==1.
</li></ul><h2>Configuration</h2><p>AArch32 System register SCR bits [31:0]
            
            can be mapped to
            AArch64 System register <a href="AArch64-scr_el3.html">SCR_EL3[31:0]
            </a>, but this is not architecturally mandated.
          </p><p><ins>This</ins><del>Some</del> <del>or all RW fields of this </del>register <ins>is</ins><del>have</del> <ins>present</ins><del>defined</del> <ins>only
    when</ins><del>reset</del> <ins>AArch32</ins><del>values.
                
        These</del> <del>apply
      
                whenever the register </del>is <ins>supported</ins><del>accessible.
                This</del> <ins>at</ins><del>means</del> <ins>any</ins><del>they</del> <ins>Exception</ins><del>apply</del> <ins>level.
      
    Otherwise,</ins><del>when</del> <ins>direct</ins><del>the</del> <ins>accesses</ins><del>PE</del> <ins>to</ins><del>resets</del> <ins>SCR</ins><del>into</del> <ins>are</ins><del>EL3 using AArch32.</del> <span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><h2>Attributes</h2><p>SCR is a 32-bit register.</p><h2>Field descriptions</h2><p>The SCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#TERR_15">TERR</a></td><td class="lr" colspan="1"><a href="#0_14">RES0</a></td><td class="lr" colspan="1"><a href="#TWE_13">TWE</a></td><td class="lr" colspan="1"><a href="#TWI_12">TWI</a></td><td class="lr" colspan="2"><a href="#0_11">RES0</a></td><td class="lr" colspan="1"><a href="#SIF_9">SIF</a></td><td class="lr" colspan="1"><a href="#HCE_8">HCE</a></td><td class="lr" colspan="1"><a href="#SCD_7">SCD</a></td><td class="lr" colspan="1"><a href="#nET_6">nET</a></td><td class="lr" colspan="1"><a href="#AW_5">AW</a></td><td class="lr" colspan="1"><a href="#FW_4">FW</a></td><td class="lr" colspan="1"><a href="#EA_3">EA</a></td><td class="lr" colspan="1"><a href="#FIQ_2">FIQ</a></td><td class="lr" colspan="1"><a href="#IRQ_1">IRQ</a></td><td class="lr" colspan="1"><a href="#NS_0">NS</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_31">
                Bits [31:16]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TERR_15">TERR, bit [15]
              <div style="font-size:smaller;"><br/>When RAS is implemented:
                </div></h4><p>Trap Error record accesses. Generate a Monitor Trap exception on accesses to the following registers from modes other than Monitor mode:</p><p><a href="AArch32-erridr.html">ERRIDR</a>, <a href="AArch32-errselr.html">ERRSELR</a>, <a href="AArch32-erxaddr.html">ERXADDR</a>, <a href="AArch32-erxaddr2.html">ERXADDR2</a>, <a href="AArch32-erxctlr.html">ERXCTLR</a>, <a href="AArch32-erxctlr2.html">ERXCTLR2</a>, <a href="AArch32-erxfr.html">ERXFR</a>, <a href="AArch32-erxfr2.html">ERXFR2</a>, <a href="AArch32-erxmisc0.html">ERXMISC0</a>, <a href="AArch32-erxmisc1.html">ERXMISC1</a>, <a href="AArch32-erxmisc2.html">ERXMISC2</a>, <a href="AArch32-erxmisc3.html">ERXMISC3</a>, and <a href="AArch32-erxstatus.html">ERXSTATUS</a>. When ARMv8.4-RAS is implemented, <a href="AArch32-erxmisc4.html">ERXMISC4</a>, <a href="AArch32-erxmisc5.html">ERXMISC5</a>, <a href="AArch32-erxmisc6.html">ERXMISC6</a>, <a href="AArch32-erxmisc7.html">ERXMISC7</a>.</p><table class="valuetable"><tr><th>TERR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to the specified registers from modes other than Monitor mode generate a Monitor Trap exception.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_15"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="0_14">
                Bit [14]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="TWE_13">TWE, bit [13]
              </h4><p>Traps WFE instructions to Monitor mode.</p><table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFE instruction in any mode other than Monitor mode is trapped to Monitor mode, if the instruction would otherwise have caused the PE to enter a low-power state and the attempted execution does not generate an exception that is taken to EL1 or EL2 by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE or <a href="AArch32-hcr.html">HCR</a>.TWE.</p><p>Any exception that is taken to EL1 or to EL2 has priority over this trap.</p></td></tr></table><p>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="TWI_12">TWI, bit [12]
              </h4><p>Traps WFI instructions to Monitor mode.</p><table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFI instruction in any mode other than Monitor mode is trapped to Monitor mode, if the instruction would otherwise have caused the PE to enter a low-power state and the attempted execution does not generate an exception that is taken to EL1 or EL2 by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI or <a href="AArch32-hcr.html">HCR</a>.TWI.</p><p>Any exception that is taken to EL1 or to EL2 has priority over this trap.</p></td></tr></table><p>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p><div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="0_11">
                Bits [11:10]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="SIF_9">SIF, bit [9]
              </h4><p>Secure instruction fetch. When the PE is in Secure state, this bit disables instruction fetch from Non-secure memory. The possible values for this bit are:</p><table class="valuetable"><tr><th>SIF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Secure state instruction fetches from Non-secure memory are permitted.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Secure state instruction fetches from Non-secure memory are not permitted.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="HCE_8">HCE, bit [8]
              </h4><p>Hypervisor Call instruction enable. If EL2 is implemented, enables execution of HVC instructions at Non-secure EL1 and EL2.</p><table class="valuetable"><tr><th>HCE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>HVC instructions are:</p><ul><li><span class="arm-defined-word">UNDEFINED</span> at Non-secure EL1. The Undefined Instruction exception is taken from PL1 to PL1.
</li><li><span class="arm-defined-word">UNPREDICTABLE</span> at EL2. Behavior is one of the following:<ul><li>The instruction is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>The instruction executes as a NOP.
</li></ul></li></ul></td></tr><tr><td class="bitfield">0b1</td><td><p>HVC instructions are enabled at Non-secure EL1 and EL2.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0 and in Secure state.</p></div><p>If EL2 is not implemented, this bit is <span class="arm-defined-word">RES0</span> and HVC is <span class="arm-defined-word">UNDEFINED</span>.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="SCD_7">SCD, bit [7]
              </h4><p>Secure Monitor Call disable. Disables SMC instructions.</p><table class="valuetable"><tr><th>SCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>SMC instructions are enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>In Non-secure state, SMC instructions are <span class="arm-defined-word">UNDEFINED</span>. The Undefined Instruction exception is taken from the current Exception level to the current Exception level.</p><p>In Secure state, behavior is one of the following:</p><ul><li>The instruction is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>The instruction executes as a NOP.
</li></ul></td></tr></table><div class="note"><span class="note-header">Note</span><p>SMC instructions are always <span class="arm-defined-word">UNDEFINED</span> at PL0.</p></div><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="nET_6">nET, bit [6]
              </h4><p>Not Early Termination. This bit disables early termination. The possible values of this bit are:</p><table class="valuetable"><tr><th>nET</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Early termination permitted. Execution time of data operations can depend on the data values.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Disable early termination. The number of cycles required for data operations is forced to be independent of the data values.</p></td></tr></table><p>This <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> mechanism can disable data dependent timing optimizations from multiplies and data operations. It can provide system support against information leakage that might be exploited by timing correlation types of attack.</p><p>On implementations that do not support early termination or do not support disabling early termination, this bit is <span class="arm-defined-word">RES0</span>.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="AW_5">AW, bit [5]
              </h4><p>When the value of SCR.EA is 1 and the value of <a href="AArch32-hcr.html">HCR</a>.AMO is 0, this bit controls whether <a href="AArch32-cpsr.html">CPSR</a>.A masks an External abort taken from Non-secure state, and the possible values of this bit are:</p><table class="valuetable"><tr><th>AW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External aborts taken from Non-secure state are not masked by <a href="AArch32-cpsr.html">CPSR</a>.A, and are taken to EL3.</p><p>External aborts taken from Secure state are masked by <a href="AArch32-cpsr.html">CPSR</a>.A.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>External aborts taken from either Security state are masked by <a href="AArch32-cpsr.html">CPSR</a>.A. When <a href="AArch32-cpsr.html">CPSR</a>.A is 0, the abort is taken to EL3.</p></td></tr></table><p>When SCR.EA is 0 or <a href="AArch32-hcr.html">HCR</a>.AMO is 1, this bit has no effect.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="FW_4">FW, bit [4]
              </h4><p>When the value of SCR.FIQ is 1 and the value of <a href="AArch32-hcr.html">HCR</a>.FMO is 0, this bit controls whether <a href="AArch32-cpsr.html">CPSR</a>.F masks an FIQ interrupt taken from Non-secure state, and the possible values of this bit are:</p><table class="valuetable"><tr><th>FW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>An FIQ taken from Non-secure state is not masked by CPSR.F, and is taken to EL3.</p><p>An FIQ taken from Secure state is masked by <a href="AArch32-cpsr.html">CPSR</a>.F.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>An FIQ taken from either Security state is masked by <a href="AArch32-cpsr.html">CPSR</a>.F. When <a href="AArch32-cpsr.html">CPSR</a>.F is 0, the FIQ is taken to EL3.</p></td></tr></table><p>When SCR.FIQ is 0 or <a href="AArch32-hcr.html">HCR</a>.FMO is 1, this bit has no effect.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="EA_3">EA, bit [3]
              </h4><p>External Abort handler. This bit controls which mode takes External aborts. The possible values of this bit are:</p><table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External aborts taken to Abort mode.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>External aborts taken to Monitor mode.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="FIQ_2">FIQ, bit [2]
              </h4><p>FIQ handler. This bit controls which mode takes FIQ exceptions. The possible values of this bit are:</p><table class="valuetable"><tr><th>FIQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>FIQs taken to FIQ mode.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>FIQs taken to Monitor mode.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="IRQ_1">IRQ, bit [1]
              </h4><p>IRQ handler. This bit controls which mode takes IRQ exceptions. The possible values of this bit are:</p><table class="valuetable"><tr><th>IRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>IRQs taken to IRQ mode.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>IRQs taken to Monitor mode.</p></td></tr></table><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="NS_0">NS, bit [0]
              </h4><p>Non-secure bit. Except when the PE is in Monitor mode, this bit determines the Security state of the PE:</p><table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>PE is in Secure state.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>PE is in Non-secure state.</p></td></tr></table><p>If the <a href="AArch32-hcr.html">HCR</a>.TGE bit is set, an attempt to change from a Secure PL1 mode to a Non-secure EL1 mode by changing the SCR.NS bit from 0 to 1 results in the SCR.NS bit remaining as 0.</p><p>In a system where the PE resets into EL3, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the SCR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif !ELUsingAArch32(EL2) &amp;&amp; SCR_EL3.&lt;NS,EEL2> == '01' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    return SCR;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif !ELUsingAArch32(EL2) &amp;&amp; SCR_EL3.&lt;NS,EEL2> == '01' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    SCR = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>