<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>PMUSERENR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMUSERENR, Performance Monitors User Enable Register</h1><p>The PMUSERENR characteristics are:</p><h2>Purpose</h2><p>Enables or disables User mode access to the Performance Monitors.</p><h2>Configuration</h2><p>AArch32 System register PMUSERENR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0[31:0]
            </a>.
          </p><p><del>
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> values.
              </del></p><p>This register is present only
    when <ins>AArch32 is supported at any Exception level and </ins>PMUv3 is implemented.
      
    Otherwise, direct accesses to PMUSERENR are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>PMUSERENR is a 32-bit register.</p><h2>Field descriptions</h2><p>The PMUSERENR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="28"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#ER_3">ER</a></td><td class="lr" colspan="1"><a href="#CR_2">CR</a></td><td class="lr" colspan="1"><a href="#SW_1">SW</a></td><td class="lr" colspan="1"><a href="#EN_0">EN</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_31">
                Bits [31:4]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="ER_3">ER, bit [3]
              </h4><p>Event counter read trap control:</p><table class="valuetable"><tr><th>ER</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL0 reads of the <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a> and <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>, and EL0 RW access to the <a href="AArch32-pmselr.html">PMSELR</a>, are trapped to Undefined mode if PMUSERENR.EN is also 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Overrides PMUSERENR.EN and enables RO access to <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a> and <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>, and RW access to <a href="AArch32-pmselr.html">PMSELR</a>.</p></td></tr></table><p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="CR_2">CR, bit [2]
              </h4><p>Cycle counter read trap control:</p><table class="valuetable"><tr><th>CR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL0 reads of the <a href="AArch32-pmccntr.html">PMCCNTR</a> are trapped to Undefined mode if PMUSERENR.EN is also 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Overrides PMUSERENR.EN and enables access to <a href="AArch32-pmccntr.html">PMCCNTR</a>.</p></td></tr></table><p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="SW_1">SW, bit [1]
              </h4><p>Software increment write trap control:</p><table class="valuetable"><tr><th>SW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL0 writes to the <a href="AArch32-pmswinc.html">PMSWINC</a> are trapped to Undefined mode if PMUSERENR.EN is also 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Overrides PMUSERENR.EN and enables access to <a href="AArch32-pmswinc.html">PMSWINC</a>.</p></td></tr></table><p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><h4 id="EN_0">EN, bit [0]
              </h4><p>Traps EL0 accesses to the Performance Monitors registers to Undefined mode<ins>, as follows</ins>:</p><ul><li><p><a href="AArch32-pmcr.html"><ins>PMCR</ins></a><ins>, </ins><a href="AArch32-pmovsr.html"><ins>PMOVSR</ins></a><ins>, </ins><a href="AArch32-pmselr.html"><ins>PMSELR</ins></a><ins>, </ins><a href="AArch32-pmceid0.html"><ins>PMCEID0</ins></a><ins>, </ins><a href="AArch32-pmceid1.html"><ins>PMCEID1</ins></a><ins>, </ins><a href="AArch32-pmccntr.html"><ins>PMCCNTR</ins></a><ins>, </ins><a href="AArch32-pmxevtyper.html"><ins>PMXEVTYPER</ins></a><ins>, </ins><a href="AArch32-pmxevntr.html"><ins>PMXEVNTR</ins></a><ins>, </ins><a href="AArch32-pmcntenset.html"><ins>PMCNTENSET</ins></a><ins>, </ins><a href="AArch32-pmcntenclr.html"><ins>PMCNTENCLR</ins></a><ins>, </ins><a href="AArch32-pmovsset.html"><ins>PMOVSSET</ins></a><ins>, </ins><a href="AArch32-pmevcntrn.html"><ins>PMEVCNTR&lt;n></ins></a><ins>, </ins><a href="AArch32-pmevtypern.html"><ins>PMEVTYPER&lt;n></ins></a><ins>, </ins><a href="AArch32-pmccfiltr.html"><ins>PMCCFILTR</ins></a><ins>, </ins><a href="AArch32-pmswinc.html"><ins>PMSWINC</ins></a><ins>.</ins></p></li><li><p><ins>If ARMv8.1-PMU is implemented, </ins><a href="AArch32-pmceid2.html"><ins>PMCEID2</ins></a><ins>, and </ins><a href="AArch32-pmceid3.html"><ins>PMCEID3</ins></a><ins>.</ins></p></li><li><p><ins>If ARMv8.4-PMU is implemented, </ins><a href="AArch32-pmmir.html"><ins>PMMIR</ins></a><ins>.</ins></p></li></ul><table class="valuetable"><tr><th>EN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>While at EL0, <ins>accesses</ins><del>PMUSERENR</del> <del>is always RO. Accesses </del>to the <ins>specified</ins><del>other</del> <ins>registers</ins><del>Performance</del> <ins>at</ins><del>Monitors</del> <ins>EL0</ins><del>registers</del> are trapped to Undefined mode, unless <ins>overridden</ins><del>enabled</del> by one of PMUSERENR.{ER, CR, SW}.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>While at EL0, software can access all <ins>of</ins><del>PMU</del> <ins>the</ins><del>registers</del> <ins>specified registers.</ins><del>except</del><a href="AArch32-pmintenset.html"><del>PMINTENSET</del></a><del> and </del><a href="AArch32-pmintenclr.html"><del>PMINTENCLR</del></a><del>.</del></p></td></tr></table><p>On a Warm reset, this field resets to <span class="binarynumber">0</span>.
</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the PMUSERENR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1001</td><td>0b1110</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL1) &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMUSERENR_EL0 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMUSERENR;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMUSERENR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        return PMUSERENR;
elsif PSTATE.EL == EL3 then
    return PMUSERENR;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1001</td><td>0b1110</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T9 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T9 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.TPM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        PMUSERENR = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        PMUSERENR = R[t];
elsif PSTATE.EL == EL3 then
    PMUSERENR = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>