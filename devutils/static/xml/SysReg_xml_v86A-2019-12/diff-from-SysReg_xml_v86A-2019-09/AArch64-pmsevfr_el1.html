<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>PMSEVFR_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMSEVFR_EL1, Sampling Event Filter Register</h1><p>The PMSEVFR_EL1 characteristics are:</p><h2>Purpose</h2><p>Controls sample filtering by events. The overall filter is the logical AND of these filters. For example, if E[3] and E[5] are both set to 1, only samples that have both event 3 (Level 1 unified or data cache refill) and event 5 set (TLB walk) are recorded</p><h2>Configuration</h2><p>This register is present only
    when SPE is implemented.
      
    Otherwise, direct accesses to PMSEVFR_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>PMSEVFR_EL1 is a 64-bit register.</p><h2>Field descriptions</h2><p>The PMSEVFR_EL1 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#E63_63"><ins class="nocount">E[63]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[63</del></a></td><td class="lr" colspan="1"><a href="#E62_62"><ins class="nocount">E[62]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[62</del></a></td><td class="lr" colspan="1"><a href="#E61_61"><ins class="nocount">E[61]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[61</del></a></td><td class="lr" colspan="1"><a href="#E60_60"><ins class="nocount">E[60]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[60</del></a></td><td class="lr" colspan="1"><a href="#E59_59"><ins class="nocount">E[59]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[59</del></a></td><td class="lr" colspan="1"><a href="#E58_58"><ins class="nocount">E[58]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[58</del></a></td><td class="lr" colspan="1"><a href="#E57_57"><ins class="nocount">E[57]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[57</del></a></td><td class="lr" colspan="1"><a href="#E56_56"><ins class="nocount">E[56]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[56</del></a></td><td class="lr" colspan="1"><a href="#E55_55"><ins class="nocount">E[55]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[55</del></a></td><td class="lr" colspan="1"><a href="#E54_54"><ins class="nocount">E[54]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[54</del></a></td><td class="lr" colspan="1"><a href="#E53_53"><ins class="nocount">E[53]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[53</del></a></td><td class="lr" colspan="1"><a href="#E52_52"><ins class="nocount">E[52]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[52</del></a></td><td class="lr" colspan="1"><a href="#E51_51"><ins class="nocount">E[51]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[51</del></a></td><td class="lr" colspan="1"><a href="#E50_50"><ins class="nocount">E[50]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[50</del></a></td><td class="lr" colspan="1"><a href="#E49_49"><ins class="nocount">E[49]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[49</del></a></td><td class="lr" colspan="1"><a href="#E48_48"><ins class="nocount">E[48]</ins></a><a href="#E&lt;z>_63"><del class="nocount">E[48</del></a></td><td class="lr" colspan="16"><a href="#0_47">RAZ/WI</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#E31_31"><ins class="nocount">E[31]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[31</del></a></td><td class="lr" colspan="1"><a href="#E30_30"><ins class="nocount">E[30]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[30</del></a></td><td class="lr" colspan="1"><a href="#E29_29"><ins class="nocount">E[29]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[29</del></a></td><td class="lr" colspan="1"><a href="#E28_28"><ins class="nocount">E[28]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[28</del></a></td><td class="lr" colspan="1"><a href="#E27_27"><ins class="nocount">E[27]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[27</del></a></td><td class="lr" colspan="1"><a href="#E26_26"><ins class="nocount">E[26]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[26</del></a></td><td class="lr" colspan="1"><a href="#E25_25"><ins class="nocount">E[25]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[25</del></a></td><td class="lr" colspan="1"><a href="#E24_24"><ins class="nocount">E[24]</ins></a><a href="#E&lt;y>_31"><del class="nocount">E[24</del></a></td><td class="lr" colspan="5"><a href="#0_23">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E18_18">E[18]</a></td><td class="lr" colspan="1"><a href="#E17_17">E[17]</a></td><td class="lr" colspan="1"><a href="#0_16">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E15_15"><ins class="nocount">E[15]</ins></a><a href="#E&lt;x>_15"><del class="nocount">E[15</del></a></td><td class="lr" colspan="1"><a href="#E14_14"><ins class="nocount">E[14]</ins></a><a href="#E&lt;x>_15"><del class="nocount">E[14</del></a></td><td class="lr" colspan="1"><a href="#E13_13"><ins class="nocount">E[13]</ins></a><a href="#E&lt;x>_15"><del class="nocount">E[13</del></a></td><td class="lr" colspan="1"><a href="#E12_12"><ins class="nocount">E[12]</ins></a><a href="#E&lt;x>_15"><del class="nocount">E[12</del></a></td><td class="lr" colspan="1"><a href="#E11_11">E[11]</a></td><td class="lr" colspan="3"><a href="#0_10">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E7_7">E[7]</a></td><td class="lr" colspan="1"><a href="#0_6">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E5_5">E[5]</a></td><td class="lr" colspan="1"><a href="#0_4">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E3_3">E[3]</a></td><td class="lr" colspan="1"><a href="#0_2">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#E1_1">E[1]</a></td><td class="lr" colspan="1"><a href="#0_0">RAZ/WI</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="E63_63">E<del>[&lt;z>], bit </del>[<ins>63</ins><del>z</del>], <ins>bit</ins><del>for</del> <ins>[</ins><del>z = 48 to </del>63<ins>]</ins>
              </h4><p>E<ins>[63]</ins><del>[&lt;z>]</del> is the event filter for event <ins>63.</ins><del>&lt;z>.</del> If event <ins>63</ins><del>&lt;z></del> is not implemented, or filtering on event <ins>63</ins><del>&lt;z></del> is not supported, the corresponding bit is RAZ/WI.</p><table class="valuetable"><tr><th>E<ins>[63]</ins><del>[&lt;z>]</del></th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event <ins>63</ins><del>&lt;z></del> is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have event <ins>63</ins><del>&lt;z></del> == 0.</p></td></tr></table><p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p><p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="E62_62"><ins>E[62], bit [62]
              </ins></h4><p><ins>E[62] is the event filter for event 62. If event 62 is not implemented, or filtering on event 62 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[62]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 62 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 62 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E61_61"><ins>E[61], bit [61]
              </ins></h4><p><ins>E[61] is the event filter for event 61. If event 61 is not implemented, or filtering on event 61 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[61]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 61 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 61 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E60_60"><ins>E[60], bit [60]
              </ins></h4><p><ins>E[60] is the event filter for event 60. If event 60 is not implemented, or filtering on event 60 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[60]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 60 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 60 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E59_59"><ins>E[59], bit [59]
              </ins></h4><p><ins>E[59] is the event filter for event 59. If event 59 is not implemented, or filtering on event 59 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[59]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 59 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 59 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E58_58"><ins>E[58], bit [58]
              </ins></h4><p><ins>E[58] is the event filter for event 58. If event 58 is not implemented, or filtering on event 58 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[58]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 58 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 58 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E57_57"><ins>E[57], bit [57]
              </ins></h4><p><ins>E[57] is the event filter for event 57. If event 57 is not implemented, or filtering on event 57 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[57]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 57 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 57 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E56_56"><ins>E[56], bit [56]
              </ins></h4><p><ins>E[56] is the event filter for event 56. If event 56 is not implemented, or filtering on event 56 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[56]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 56 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 56 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E55_55"><ins>E[55], bit [55]
              </ins></h4><p><ins>E[55] is the event filter for event 55. If event 55 is not implemented, or filtering on event 55 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[55]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 55 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 55 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E54_54"><ins>E[54], bit [54]
              </ins></h4><p><ins>E[54] is the event filter for event 54. If event 54 is not implemented, or filtering on event 54 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[54]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 54 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 54 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E53_53"><ins>E[53], bit [53]
              </ins></h4><p><ins>E[53] is the event filter for event 53. If event 53 is not implemented, or filtering on event 53 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[53]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 53 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 53 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E52_52"><ins>E[52], bit [52]
              </ins></h4><p><ins>E[52] is the event filter for event 52. If event 52 is not implemented, or filtering on event 52 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[52]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 52 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 52 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E51_51"><ins>E[51], bit [51]
              </ins></h4><p><ins>E[51] is the event filter for event 51. If event 51 is not implemented, or filtering on event 51 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[51]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 51 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 51 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E50_50"><ins>E[50], bit [50]
              </ins></h4><p><ins>E[50] is the event filter for event 50. If event 50 is not implemented, or filtering on event 50 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[50]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 50 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 50 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E49_49"><ins>E[49], bit [49]
              </ins></h4><p><ins>E[49] is the event filter for event 49. If event 49 is not implemented, or filtering on event 49 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[49]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 49 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 49 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E48_48"><ins>E[48], bit [48]
              </ins></h4><p><ins>E[48] is the event filter for event 48. If event 48 is not implemented, or filtering on event 48 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[48]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 48 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 48 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="0_47">
                Bits [47:32]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E31_31">E<del>[&lt;y>], bit </del>[<ins>31</ins><del>y</del>], <ins>bit</ins><del>for</del> <ins>[</ins><del>y = 24 to </del>31<ins>]</ins>
              </h4><p>E<ins>[31]</ins><del>[&lt;y>]</del> is the event filter for event <ins>31.</ins><del>&lt;y>.</del> If event <ins>31</ins><del>&lt;y></del> is not implemented, or filtering on event <ins>31</ins><del>&lt;y></del> is not supported, the corresponding bit is RAZ/WI.</p><table class="valuetable"><tr><th>E<ins>[31]</ins><del>[&lt;y>]</del></th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event <ins>31</ins><del>&lt;y></del> is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have event <ins>31</ins><del>&lt;y></del> == 0.</p></td></tr></table><p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p><p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="E30_30"><ins>E[30], bit [30]
              </ins></h4><p><ins>E[30] is the event filter for event 30. If event 30 is not implemented, or filtering on event 30 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[30]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 30 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 30 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E29_29"><ins>E[29], bit [29]
              </ins></h4><p><ins>E[29] is the event filter for event 29. If event 29 is not implemented, or filtering on event 29 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[29]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 29 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 29 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E28_28"><ins>E[28], bit [28]
              </ins></h4><p><ins>E[28] is the event filter for event 28. If event 28 is not implemented, or filtering on event 28 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[28]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 28 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 28 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E27_27"><ins>E[27], bit [27]
              </ins></h4><p><ins>E[27] is the event filter for event 27. If event 27 is not implemented, or filtering on event 27 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[27]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 27 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 27 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E26_26"><ins>E[26], bit [26]
              </ins></h4><p><ins>E[26] is the event filter for event 26. If event 26 is not implemented, or filtering on event 26 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[26]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 26 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 26 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E25_25"><ins>E[25], bit [25]
              </ins></h4><p><ins>E[25] is the event filter for event 25. If event 25 is not implemented, or filtering on event 25 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[25]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 25 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 25 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E24_24"><ins>E[24], bit [24]
              </ins></h4><p><ins>E[24] is the event filter for event 24. If event 24 is not implemented, or filtering on event 24 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[24]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 24 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 24 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="0_23">
                Bits [23:19]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E18_18">E[18], bit [18]
              <div style="font-size:smaller;"><br/>When ARMv8.3-SPE is implemented and SVE is implemented:
                </div></h4><p>Empty predicate.</p><table class="valuetable"><tr><th>E[18]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Empty predicate event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Empty predicate event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_18"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E17_17">E[17], bit [17]
              <div style="font-size:smaller;"><br/>When ARMv8.3-SPE is implemented and SVE is implemented:
                </div></h4><p>Partial predicate.</p><table class="valuetable"><tr><th>E[17]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Partial predicate event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Partial predicate event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_17"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="0_16">
                Bit [16]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E15_15">E<del>[&lt;x>], bit </del>[<ins>15</ins><del>x</del>], <ins>bit</ins><del>for</del> <ins>[</ins><del>x = 12 to </del>15<ins>]</ins>
              </h4><p>E<ins>[15]</ins><del>[&lt;x>]</del> is the event filter for event <ins>15.</ins><del>&lt;x>.</del> If event <ins>15</ins><del>&lt;x></del> is not implemented, or filtering on event <ins>15</ins><del>&lt;x></del> is not supported, the corresponding bit is RAZ/WI.</p><table class="valuetable"><tr><th>E<ins>[15]</ins><del>[&lt;x>]</del></th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event <ins>15</ins><del>&lt;x></del> is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have event <ins>15</ins><del>&lt;x></del> == 0.</p></td></tr></table><p>An <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> filter for the event.</p><p>This field is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="E14_14"><ins>E[14], bit [14]
              </ins></h4><p><ins>E[14] is the event filter for event 14. If event 14 is not implemented, or filtering on event 14 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[14]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 14 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 14 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E13_13"><ins>E[13], bit [13]
              </ins></h4><p><ins>E[13] is the event filter for event 13. If event 13 is not implemented, or filtering on event 13 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[13]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 13 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 13 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E12_12"><ins>E[12], bit [12]
              </ins></h4><p><ins>E[12] is the event filter for event 12. If event 12 is not implemented, or filtering on event 12 is not supported, the corresponding bit is RAZ/WI.</ins></p><table class="valuetable"><tr><th><ins>E[12]</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Event 12 is ignored.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Do not record samples that have event 12 == 0.</ins></p></td></tr></table><p><ins>An </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> event might be recorded as a multi-bit field. In this case, if the corresponding bits of PMSEVFR_EL1 define an </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> filter for the event.</ins></p><p><ins>This field is ignored by the PE when </ins><a href="AArch64-pmsfcr_el1.html"><ins>PMSFCR_EL1</ins></a><ins>.FE == 0</ins></p><p><ins>On a Warm reset, this field resets to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="E11_11">E[11], bit [11]
              <div style="font-size:smaller;"><br/>When ARMv8.3-SPE is implemented:
                </div></h4><p>Alignment.</p><table class="valuetable"><tr><th>E[11]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Alignment event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Alignment event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_11"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="0_10">
                Bits [10:8]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E7_7">E[7], bit [7]
              </h4><p>Mispredicted.</p><table class="valuetable"><tr><th>E[7]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Mispredicted event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Mispredicted event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bit [6]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E5_5">E[5], bit [5]
              </h4><p>TLB walk.</p><table class="valuetable"><tr><th>E[5]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>TLB walk event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the TLB walk event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_4">
                Bit [4]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E3_3">E[3], bit [3]
              </h4><p>Level 1 data or unified cache refill.</p><table class="valuetable"><tr><th>E[3]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Level 1 data or unified cache refill event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Level 1 data or unified cache refill event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_2">
                Bit [2]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><h4 id="E1_1">E[1], bit [1]
              <div style="font-size:smaller;"><br/>When the PE supports sampling of speculative instructions:
                </div></h4><p>Architecturally retired.</p><p>When the PE supports sampling of speculative instructions:</p><table class="valuetable"><tr><th>E[1]</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Architecturally retired event is ignored.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Do not record samples that have the Architecturally retired event == 0.</p></td></tr></table><p>This bit is ignored by the PE when <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>.FE == 0.</p><p>If the PE does not support the sampling of speculative instructions, or always discards the sample record for speculative instructions, this bit reads as an <span class="arm-defined-word">UNKNOWN</span> value and the PE ignores its value.</p><p>On a Warm reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UNKNOWN_1"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0_0">
                Bit [0]
              </h4><p>Reserved, <span class="arm-defined-word">RAZ/WI</span>.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the PMSEVFR_EL1</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, PMSEVFR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMSEVFR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '1x1' then
        return NVMem[0x830];
    else
        return PMSEVFR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        return PMSEVFR_EL1;
elsif PSTATE.EL == EL3 then
    return PMSEVFR_EL1;
              </p><h4 class="assembler">MSR PMSEVFR_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMSEVFR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV> == '1x1' then
        NVMem[0x830] = X[t];
    else
        PMSEVFR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; MDCR_EL3.NSPB != '01' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; MDCR_EL3.NSPB != '11' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMSEVFR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    PMSEVFR_EL1 = X[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>