<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>DBGPRCR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DBGPRCR, Debug Power Control Register</h1><p>The DBGPRCR characteristics are:</p><h2>Purpose</h2><p>Controls behavior of the PE on powerdown request.</p><h2>Configuration</h2><p>AArch32 System register DBGPRCR bits [31:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1[31:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to DBGPRCR are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>Bit [0] of this register is mapped to <a href="ext-edprcr.html">EDPRCR</a>.CORENPDRQ, bit [0] of the external view of this register.</p><p>The other bits in these registers are not mapped to each other.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>DBGPRCR is a 32-bit register.</p><h2>Field descriptions</h2><p>The DBGPRCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="31"><a href="#0_31">RES0</a></td><td class="lr" colspan="1"><a href="#CORENPDRQ_0">CORENPDRQ</a></td></tr></tbody></table><div class="text_before_fields"></div><h4 id="0_31">
                Bits [31:1]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="CORENPDRQ_0">CORENPDRQ, bit [0]
              <div style="font-size:smaller;"><br/>When ARMv8.3-DoPD is implemented:
                </div></h4><p>Core no powerdown request. Requests emulation of powerdown.</p><p>This request is typically passed to an external power controller. This means that whether a request causes power up is dependent on the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> nature of the system. The power controller must not allow the Core power domain to switch off while this bit is 1.</p><table class="valuetable"><tr><th>CORENPDRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If the system responds to a powerdown request, it powers down Core power domain.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If the system responds to a powerdown request, it does not powerdown the Core power domain, but instead emulates a powerdown of that domain.</p></td></tr></table><p>In an implementation that includes the recommended external debug interface, this bit drives the DBGNOPWRDWN signal.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is reset to the Cold reset value on exit from an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> software-visible retention state. For more information about retention states see <span class="xref">Core power domain power states</span>.</p><div class="note"><span class="note-header">Note</span><p>Writes to this bit are not prohibited by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface. This means that a debugger can request emulation of powerdown regardless of whether invasive debug is permitted.</p></div><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field is set to 1 if the powerup request is implemented and the powerup request has been asserted, and is set to 0 otherwise.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="CORENPDRQ_0"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Core no powerdown request. Requests emulation of powerdown.</p><p>This request is typically passed to an external power controller. This means that whether a request causes power up is dependent on the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> nature of the system. The power controller must not allow the Core power domain to switch off while this bit is 1.</p><table class="valuetable"><tr><th>CORENPDRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If the system responds to a powerdown request, it powers down Core power domain.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If the system responds to a powerdown request, it does not powerdown the Core power domain, but instead emulates a powerdown of that domain.</p></td></tr></table><p>In an implementation that includes the recommended external debug interface, this bit drives the DBGNOPWRDWN signal.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is reset to the value of <a href="ext-edprcr.html">EDPRCR</a>.COREPURQ on exit from an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> software-visible retention state. For more information about retention states see <span class="xref">Core power domain power states</span>.</p><div class="note"><span class="note-header">Note</span><p>Writes to this bit are not prohibited by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface. This means that a debugger can request emulation of powerdown regardless of whether invasive debug is permitted.</p></div><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to the value in <a href="ext-edprcr.html">EDPRCR</a>.COREPURQ.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the DBGPRCR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0001</td><td>0b0100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDOSA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDOSA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    else
        return DBGPRCR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    else
        return DBGPRCR;
elsif PSTATE.EL == EL3 then
    return DBGPRCR;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1110</td><td>0b000</td><td>0b0001</td><td>0b0100</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDOSA> != '00' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x05);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HDCR.&lt;TDE,TDOSA> != '00' then
        AArch32.TakeHypTrapException(0x05);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    else
        DBGPRCR = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDOSA == '1' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x05);
    else
        DBGPRCR = R[t];
elsif PSTATE.EL == EL3 then
    DBGPRCR = R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>