<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>DBGBVR&lt;n>_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DBGBVR&lt;n>_EL1, Debug Breakpoint Value Registers, n =
      0 - 15</h1><p>The DBGBVR&lt;n>_EL1 characteristics are:</p><h2>Purpose</h2><p>Holds a virtual address, or a VMID and/or a context ID, for use in breakpoint matching. Forms breakpoint n together with control register <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.</p><h2>Configuration</h2><p>AArch64 System register DBGBVR&lt;n>_EL1 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n>[31:0]
            </a>.
          </p><p>AArch64 System register DBGBVR&lt;n>_EL1 bits [63:32]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n>[31:0]
            </a>.
          </p><p>AArch64 System register DBGBVR&lt;n>_EL1 bits [63:0]
            
                are architecturally mapped to
              External register <a href="ext-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1[63:0]
            </a>.
          </p><p>If breakpoint n is not implemented then accesses to this register are <span class="arm-defined-word">UNDEFINED</span>.</p><p><del class="nocount">
                Some or all RW fields of this register have defined reset values.
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch64.
                Otherwise,
                
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>How this register is interpreted depends on the value of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT.</p><ul><li>When <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT is <span class="binarynumber">0b000x</span>, this register holds a virtual address.
</li><li>When <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT is <span class="binarynumber">0b001x</span>, <span class="binarynumber">0b011x</span>, or <span class="binarynumber">0b110x</span>, this register holds a Context ID.
</li><li>When <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT is <span class="binarynumber">0b100x</span>, this register holds a VMID.
</li><li>When <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT is <span class="binarynumber">0b101x</span>, this register holds a VMID and a Context ID.
</li><li>When <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT is <span class="binarynumber">0b111x</span>, this register holds two Context ID values.
</li></ul><p>For other values of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a>.BT, this register is <span class="arm-defined-word">RES0</span>.</p><h2>Field descriptions</h2><p>The DBGBVR&lt;n>_EL1 bit assignments are:</p><h3>When DBGBCR&lt;n>_EL1.BT == 0b000x:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="11"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b000x_RESS14:4_63">RESS[14:4]</a></td><td class="lr" colspan="4"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b000x_VA52:49_52">VA[52:49]</a></td><td class="lr" colspan="17"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b000x_VA48:2_48">VA[48:2]</a></td></tr><tr class="firstrow"><td class="lr" colspan="30"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b000x_VA48:2_48">VA[48:2]</a></td><td class="lr" colspan="2"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b000x_0_1">RES0</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b000x_RESS14:4_63">RESS[14:4], bits [63:53]
                  </h4><p>Reserved, Sign extended. Software must treat this field as <span class="arm-defined-word">RES0</span> if the most significant bit of VA is 0 or <span class="arm-defined-word">RES0</span>, and as <span class="arm-defined-word">RES1</span> if the most significant bit of VA is 1.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:</p><ul><li>Reads return the value of the most significant bit of the VA for every bit in this field.
</li><li>Reads return the last value written.
</li></ul><p>The PE ignores this field.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b000x_VA52:49_52">VA[52:49], bits [52:49]
                  <div style="font-size:smaller;"><br/>When ARMv8.2-LVA is implemented:
                </div></h4><p>Extension to VA[48:2]. See VA[48:2] for more details.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b000x_RESS3:0_52"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Extension to RESS[14:4]. See RESS[14:4] for more details.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b000x_VA48:2_48">VA[48:2], bits [48:2]
                  </h4><p>Bits[48:2] of the address value for comparison.</p><p>When <span class="xref">ARMv8.2-LVA</span> is implemented, VA[52:49] forms the upper part of the address value. Otherwise, VA[52:49] are RESS.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b000x_0_1">
                Bits [1:0]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b001x:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b001x_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b001x_ContextID_31">ContextID</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b001x_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b001x_ContextID_31">ContextID, bits [31:0]
                  </h4><p>Context ID value for comparison.</p><p>The value is compared against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> when <span class="xref">ARMv8.1-VHE</span> is implemented, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, and either:</p><ul><li>The PE is executing at EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, the PE is executing at EL0, and EL2 is enabled in the current Security state.
</li></ul><p>Otherwise, the value is compared against <a href="AArch64-contextidr_el1.html">CONTEXTIDR_EL1</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b011x:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b011x_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b011x_ContextID_31">ContextID</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b011x_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b011x_ContextID_31">ContextID, bits [31:0]
                  </h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el1.html">CONTEXTIDR_EL1</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b100x and <del>HaveEL(</del>EL2<ins> is implemented:</ins><del>):</del></h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_0_63">RES0</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_VMID15:8_47">VMID[15:8]</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_VMID7:0_39">VMID[7:0]</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_0_31">RES0</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_0_63">
                Bits [63:48]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_VMID15:8_47">VMID[15:8], bits [47:40]
                  <div style="font-size:smaller;"><br/>When ARMv8.1-VMID16 is implemented<ins> and VTCR_EL2.VS == 1</ins>:
                </div></h4><p>Extension to VMID[7:0]. See <ins>DBGBVR&lt;n>_EL1.VMID</ins><del>VMID</del>[7:0] for more details.</p><p><ins>If EL2 is using AArch32, this field is </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_0_47"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_VMID7:0_39">VMID[7:0], bits [39:32]
                  </h4><p>VMID value for comparison.</p><p>The VMID is 8 bits <ins>when</ins><del>in</del> <ins>any of </ins>the following <ins>are true:</ins><del>cases.</del></p><ul><li>EL2 is using AArch32.
</li><li><a href="AArch64-vtcr_el2.html"><ins>VTCR_EL2</ins></a><ins>.VS is 0.
</ins></li><li><span class="xref">ARMv8.1-VMID16</span> is not implemented.
</li></ul><p><del>When </del><span class="xref"><del>ARMv8.1-VMID16</del></span><del> is implemented and EL2 is using AArch64, it is </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> whether the VMID is 8 bits or 16 bits.</del></p><p><del>VMID[15:8] is </del><span class="arm-defined-word"><del>RES0</del></span><del> if any of the following applies:</del></p><ul><li><del>The implementation has an 8-bit VMID.
</del></li><li><a href="AArch64-vtcr_el2.html"><del>VTCR_EL2</del></a><del>.VS has a value of 0.
</del></li><li><del>EL2 is using AArch32.
</del></li></ul><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b100xandEL2isimplemented_0_31">
                Bits [31:0]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b101x and <del>HaveEL(</del>EL2<ins> is implemented:</ins><del>):</del></h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_0_63">RES0</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_VMID15:8_47">VMID[15:8]</a></td><td class="lr" colspan="8"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_VMID7:0_39">VMID[7:0]</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_ContextID_31">ContextID</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_0_63">
                Bits [63:48]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_VMID15:8_47">VMID[15:8], bits [47:40]
                  <div style="font-size:smaller;"><br/>When ARMv8.1-VMID16 is implemented<ins> and VTCR_EL2.VS == 1</ins>:
                </div></h4><p>Extension to VMID[7:0]. See <ins>DBGBVR&lt;n>_EL1.VMID</ins><del>VMID</del>[7:0] for more details.</p><p><ins>If EL2 is using AArch32, or if the implementation has an 8-bit VMID, this field is </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_0_47"><div style="font-size:smaller;"><br/>
              Otherwise:
            </div></h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_VMID7:0_39">VMID[7:0], bits [39:32]
                  </h4><p>VMID value for comparison.</p><p>The VMID is 8 bits <ins>when</ins><del>in</del> <ins>any of </ins>the following <ins>are true:</ins><del>cases.</del></p><ul><li>EL2 is using AArch32.
</li><li><a href="AArch64-vtcr_el2.html"><ins>VTCR_EL2</ins></a><ins>.VS is 0.
</ins></li><li><span class="xref">ARMv8.1-VMID16</span> is not implemented.
</li></ul><p><del>When </del><span class="xref"><del>ARMv8.1-VMID16</del></span><del> is implemented and EL2 is using AArch64, it is </del><span class="arm-defined-word"><del>IMPLEMENTATION DEFINED</del></span><del> whether the VMID is 8 bits or 16 bits.</del></p><p><del>VMID[15:8] is </del><span class="arm-defined-word"><del>RES0</del></span><del> if any of the following applies:</del></p><ul><li><del>The implementation has an 8-bit VMID.
</del></li><li><a href="AArch64-vtcr_el2.html"><del>VTCR_EL2</del></a><del>.VS has a value of 0.
</del></li><li><del>EL2 is using AArch32.
</del></li></ul><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b101xandEL2isimplemented_ContextID_31">ContextID, bits [31:0]
                  </h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el1.html">CONTEXTIDR_EL1</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b110x<ins>,</ins> <ins>EL2 is implemented </ins>and <del>HaveEL</del>(<ins>ARMv8.1-VHE is implemented or ARMv8.2-Debug is implemented</ins><del>EL2</del>):</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b110x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID2_63">ContextID2</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b110x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_0_31">RES0</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b110x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID2_63">ContextID2, bits [63:32]
                  <div style="font-size:smaller;"><br/><del>When ARMv8.1-VHE is implemented:
                </del></div></h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b110xandHaveEL(EL2)_0_63"><div style="font-size:smaller;"><br/><del>
              Otherwise:
            </del></div></h4><p><del>Reserved, </del><span class="arm-defined-word"><del>RES0</del></span><del>.</del></p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b110x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_0_31">
                Bits [31:0]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><div class="text_after_fields"></div><h3>When DBGBCR&lt;n>_EL1.BT == 0b111x, <del>HaveEL(</del>EL2<del>)</del> <ins>is implemented </ins>and <ins>(</ins>ARMv8.1-VHE is implemented<ins> or ARMv8.2-Debug is implemented):</ins><del>:</del></h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b111x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID2_63">ContextID2</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#WhenDBGBCR&lt;n>_EL1.BT0b111x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID_31">ContextID</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"></div><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b111x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID2_63">ContextID2, bits [63:32]
                  <div style="font-size:smaller;"><br/><del>When ARMv8.1-VHE is implemented:
                </del></div></h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b111x,HaveEL(EL2)andARMv8.1-VHEisimplemented_0_63"><div style="font-size:smaller;"><br/><del>
              Otherwise:
            </del></div></h4><p><del>Reserved, </del><span class="arm-defined-word"><del>RES0</del></span><del>.</del></p><h4 id="WhenDBGBCR&lt;n>_EL1.BT0b111x,EL2isimplementedand(ARMv8.1-VHEisimplementedorARMv8.2-Debugisimplemented)_ContextID_31">ContextID, bits [31:0]
                  </h4><p>Context ID value for comparison against <a href="AArch64-contextidr_el1.html">CONTEXTIDR_EL1</a>.</p><p>The following resets apply:</p><ul><li><p>On a Cold reset, this field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p></li><li><p>On a Warm reset, the value of this field is unchanged.</p></li></ul><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the DBGBVR&lt;n>_EL1</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt>, DBGBVR&lt;n>_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.DBGBVRn_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR_EL1[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR_EL1[UInt(CRm&lt;3:0>)];
elsif PSTATE.EL == EL3 then
    if !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        return DBGBVR_EL1[UInt(CRm&lt;3:0>)];
              </p><h4 class="assembler">MSR DBGBVR&lt;n>_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0000</td><td>n[3:0]</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.DBGBVRn_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; MDCR_EL2.&lt;TDE,TDA> != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR_EL1[UInt(CRm&lt;3:0>)] = X[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        AArch64.SystemAccessTrap(EL3, 0x18);
    elsif !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR_EL1[UInt(CRm&lt;3:0>)] = X[t];
elsif PSTATE.EL == EL3 then
    if !ELUsingAArch32(EL1) &amp;&amp; OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        DBGBVR_EL1[UInt(CRm&lt;3:0>)] = X[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>