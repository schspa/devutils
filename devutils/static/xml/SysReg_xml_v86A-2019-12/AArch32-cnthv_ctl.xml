<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register execution_state="AArch32" is_register="True" is_internal="True" is_banked="False" is_optional="False" is_stub_entry="False">
      <reg_short_name>CNTHV_CTL</reg_short_name>
      <reg_long_name>Counter-timer Virtual Timer Control register (EL2)</reg_long_name>
        <reg_condition otherwise="UNDEFINED">when AArch32 is supported at any Exception level and ARMv8.1-VHE is implemented</reg_condition>
      

          <reg_reset_value></reg_reset_value>
      <reg_mappings>
          <reg_mapping>
              
            <mapped_name filename="AArch64-cnthv_ctl_el2.xml">CNTHV_CTL_EL2</mapped_name>
            <mapped_type>Architectural</mapped_type>
              <mapped_execution_state>AArch64</mapped_execution_state>
              <mapped_from_startbit>31</mapped_from_startbit>
              <mapped_from_endbit>0</mapped_from_endbit>

              <mapped_to_startbit>31</mapped_to_startbit>
              <mapped_to_endbit>0</mapped_to_endbit>

          </reg_mapping>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Provides AArch32 access to the control register for the EL2 virtual timer.</para>

      </purpose_text>
      <purpose_text>
        <note><para>The EL2 virtual timer is implemented by <xref browsertext="ARMv8.1-VHE" filename="A_armv8_architecture_extensions.fm" linkend="v8.1.VHE"/>. It is only accessible from AArch32 state when EL0 is using AArch32, EL2 is using AArch64, and the value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.{E2H, TGE} is {1, 1}.</para></note>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
          <reg_group>Generic Timer registers</reg_group>
      </reg_groups>
      <reg_configuration>
        

      </reg_configuration>
      <reg_attributes>
          <attributes_text>
            <para>CNTHV_CTL is a 32-bit register.</para>
          </attributes_text>
      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="32">
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_31_3"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>3</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ISTATUS_2_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>ISTATUS</field_name>
          <field_msb>2</field_msb>
          <field_lsb>2</field_lsb>
          <field_description order="before">
          
  <para>The status of the timer. This bit indicates whether the timer condition is met:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Timer condition is not met.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Timer condition is met.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When the value of the ENABLE bit is 1, ISTATUS indicates whether the timer condition is met. ISTATUS takes no account of the value of the IMASK bit. If the value of ISTATUS is 1 and the value of IMASK is 0 then the timer interrupt is asserted.</para>
<para>When the value of the ENABLE bit is 0, the ISTATUS field is <arm-defined-word>UNKNOWN</arm-defined-word>.</para>
<para>For more information see <xref linkend="CHDDAEAJ" browsertext="'Operation of the CompareValue views of the timers'" filename="D_the_generic_timer"/> and <xref linkend="CHDCFCJF" browsertext="'Operation of the TimerValue views of the timers' in the ArmÂ® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, chapter D6" filename="D_the_generic_timer"/>.</para>
<para>This bit is read-only.</para>

          </field_description>
          <field_resets>
  
  
</field_resets>
      </field>
        <field
           id="IMASK_1_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>IMASK</field_name>
          <field_msb>1</field_msb>
          <field_lsb>1</field_lsb>
          <field_description order="before">
          
  <para>Timer interrupt mask bit. Permitted values are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Timer interrupt is not masked by the IMASK bit.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Timer interrupt is masked by the IMASK bit.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>For more information, see the description of the ISTATUS bit.</para>

          </field_description>
          <field_resets>
  
  
</field_resets>
      </field>
        <field
           id="ENABLE_0_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>ENABLE</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>Enables the timer. Permitted values are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Timer disabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Timer enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>Setting this bit to 0 disables the timer output signal, but the timer value accessible from <register_link state="AArch32" id="AArch32-cnthv_tval.xml">CNTHV_TVAL</register_link> continues to count down.</para>
<note><para>Disabling the output signal might be a power-saving option.</para></note>

          </field_description>
          <field_resets>
  
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <reg_fieldset length="32">
      
        <fieldat id="0_31_3" msb="31" lsb="3"/>
        <fieldat id="ISTATUS_2_2" msb="2" lsb="2"/>
        <fieldat id="IMASK_1_1" msb="1" lsb="1"/>
        <fieldat id="ENABLE_0_0" msb="0" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
      


<access_mechanisms>
  
    
      <access_permission_text>
        <para>This register is accessed using the encoding for <register_link state="AArch32" id="AArch32-cntv_ctl.xml">CNTV_CTL</register_link>.</para>
      </access_permission_text>


      <access_mechanism accessor="MRC CNTV_CTL">
        <encoding>
          
          <access_instruction>MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="opc1" v="0b000"/>
            
            <enc n="CRn" v="0b1110"/>
            
            <enc n="CRm" v="0b0011"/>
            
            <enc n="opc2" v="0b001"/>
        </encoding>
          <access_permission>
            <ps name="MRC" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    if !ELUsingAArch32(EL1) &amp;&amp; !(EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') &amp;&amp; CNTKCTL_EL1.EL0VTEN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; CNTKCTL.PL0VTEN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; CNTHCTL_EL2.EL0VTEN == '0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL1) &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; CNTHCTL_EL2.EL1TVT == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; IsFeatureImplemented("ARMv8.4-SecEL2") then
        return CNTHVS_CTL_EL2;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; SCR_EL3.NS == '1' then
        return CNTHV_CTL_EL2;
    else
        return CNTV_CTL;
elsif PSTATE.EL == EL1 then
    if !ELUsingAArch32(EL1) &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; CNTHCTL_EL2.EL1TVT == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    else
        return CNTV_CTL;
elsif PSTATE.EL == EL2 then
    return CNTV_CTL;
elsif PSTATE.EL == EL3 then
    return CNTV_CTL;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MCR CNTV_CTL">
        <encoding>
          
          <access_instruction>MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="opc1" v="0b000"/>
            
            <enc n="CRn" v="0b1110"/>
            
            <enc n="CRm" v="0b0011"/>
            
            <enc n="opc2" v="0b001"/>
        </encoding>
          <access_permission>
            <ps name="MCR" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    if !ELUsingAArch32(EL1) &amp;&amp; !(EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') &amp;&amp; CNTKCTL_EL1.EL0VTEN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; CNTKCTL.PL0VTEN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; CNTHCTL_EL2.EL0VTEN == '0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL1) &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; CNTHCTL_EL2.EL1TVT == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; SCR_EL3.NS == '0' &amp;&amp; IsFeatureImplemented("ARMv8.4-SecEL2") then
        CNTHVS_CTL_EL2 = R[t];
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' &amp;&amp; SCR_EL3.NS == '1' then
        CNTHV_CTL_EL2 = R[t];
    else
        CNTV_CTL = R[t];
elsif PSTATE.EL == EL1 then
    if !ELUsingAArch32(EL1) &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; CNTHCTL_EL2.EL1TVT == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    else
        CNTV_CTL = R[t];
elsif PSTATE.EL == EL2 then
    CNTV_CTL = R[t];
elsif PSTATE.EL == EL3 then
    CNTV_CTL = R[t];
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</timestamp>
</register_page>