<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register execution_state="AArch32" is_register="True" is_internal="True" is_banked="False" is_optional="False" is_stub_entry="False">
      <reg_short_name>ICC_RPR</reg_short_name>
      <reg_long_name>Interrupt Controller Running Priority Register</reg_long_name>
        <reg_condition otherwise="UNKNOWN">when AArch32 is supported at any Exception level</reg_condition>
      

          <reg_reset_value></reg_reset_value>
      <reg_mappings>
          <reg_mapping>
              
            <mapped_name filename="AArch64-icc_rpr_el1.xml">ICC_RPR_EL1</mapped_name>
            <mapped_type>Functional</mapped_type>
              <mapped_execution_state>AArch64</mapped_execution_state>


          </reg_mapping>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Indicates the Running priority of the CPU interface.</para>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
            <reg_group>GIC control registers</reg_group>
            <reg_group>GIC system registers</reg_group>
      </reg_groups>
      <reg_configuration>
        

      </reg_configuration>
      <reg_attributes>
          <attributes_text>
            <para>ICC_RPR is a 32-bit register.</para>
          </attributes_text>
      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="32">
    <text_before_fields>
      
  

    </text_before_fields>
    
        <field
           id="0_31_8"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>8</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="Priority_7_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>Priority</field_name>
          <field_msb>7</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>The current running priority on the CPU interface. This is the group priority of the current active interrupt.</para>
<para>The priority returned is the group priority as if the BPR for the current Exception level and Security state was set to the minimum value of BPR for the number of implemented priority bits.</para>
<note><para>If 8 bits of priority are implemented the group priority is bits[7:1] of the priority.</para></note>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <reg_fieldset length="32">
      
        <fieldat id="0_31_8" msb="31" lsb="8"/>
        <fieldat id="Priority_7_0" msb="7" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
      


<access_mechanisms>
  
    
      <access_permission_text>
        <para>If there are no active interrupts on the CPU interface, or all active interrupts have undergone a priority drop, the value returned is the Idle priority.</para>

      </access_permission_text>
      <access_permission_text>
        <para>Software cannot determine the number of implemented priority bits from a read of this register.</para>
      </access_permission_text>


      <access_mechanism accessor="MRC ICC_RPR">
        <encoding>
          
          <access_instruction>MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
            
            <enc n="coproc" v="0b1111"/>
            
            <enc n="opc1" v="0b000"/>
            
            <enc n="CRn" v="0b1100"/>
            
            <enc n="CRm" v="0b1011"/>
            
            <enc n="opc2" v="0b011"/>
        </encoding>
          <access_permission>
            <ps name="MRC" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T12 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T12 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; ICH_HCR_EL2.TC == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ICH_HCR.TC == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.FMO == '1' then
        return ICV_RPR;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.IMO == '1' then
        return ICV_RPR;
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.FMO == '1' then
        return ICV_RPR;
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.IMO == '1' then
        return ICV_RPR;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.&lt;IRQ,FIQ&gt; == '11' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) &amp;&amp; PSTATE.M != M32_Monitor &amp;&amp; SCR.&lt;IRQ,FIQ&gt; == '11' then
        AArch32.TakeMonitorTrapException();
    else
        return ICC_RPR;
elsif PSTATE.EL == EL2 then
    if ICC_HSRE.SRE == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.&lt;IRQ,FIQ&gt; == '11' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) &amp;&amp; SCR.&lt;IRQ,FIQ&gt; == '11' then
        AArch32.TakeMonitorTrapException();
    else
        return ICC_RPR;
elsif PSTATE.EL == EL3 then
    if ICC_MSRE.SRE == '0' then
        UNDEFINED;
    else
        return ICC_RPR;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</timestamp>
</register_page>